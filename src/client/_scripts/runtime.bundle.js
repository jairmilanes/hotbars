(function () {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw ((a.code = "MODULE_NOT_FOUND"), a);
        }
        var p = (n[i] = { exports: {} });
        e[i][0].call(
          p.exports,
          function (r) {
            var n = e[i][1][r];
            return o(n || r);
          },
          p,
          p.exports,
          r,
          e,
          n,
          t
        );
      }
      return n[i].exports;
    }
    for (
      var u = "function" == typeof require && require, i = 0;
      i < t.length;
      i++
    )
      o(t[i]);
    return o;
  }
  return r;
})()(
  {
    1: [
      function (require, module, exports) {
        /*!
         * arr-diff <https://github.com/jonschlinkert/arr-diff>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        module.exports = function diff(arr /*, arrays*/) {
          var len = arguments.length;
          var idx = 0;
          while (++idx < len) {
            arr = diffArray(arr, arguments[idx]);
          }
          return arr;
        };

        function diffArray(one, two) {
          if (!Array.isArray(two)) {
            return one.slice();
          }

          var tlen = two.length;
          var olen = one.length;
          var idx = -1;
          var arr = [];

          while (++idx < olen) {
            var ele = one[idx];

            var hasEle = false;
            for (var i = 0; i < tlen; i++) {
              var val = two[i];

              if (ele === val) {
                hasEle = true;
                break;
              }
            }

            if (hasEle === false) {
              arr.push(ele);
            }
          }
          return arr;
        }
      },
      {},
    ],
    2: [
      function (require, module, exports) {
        /*!
         * arr-flatten <https://github.com/jonschlinkert/arr-flatten>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        module.exports = function (arr) {
          return flat(arr, []);
        };

        function flat(arr, res) {
          var i = 0,
            cur;
          var len = arr.length;
          for (; i < len; i++) {
            cur = arr[i];
            Array.isArray(cur) ? flat(cur, res) : res.push(cur);
          }
          return res;
        }
      },
      {},
    ],
    3: [
      function (require, module, exports) {
        "use strict";

        module.exports = function union(init) {
          if (!Array.isArray(init)) {
            throw new TypeError(
              "arr-union expects the first argument to be an array."
            );
          }

          var len = arguments.length;
          var i = 0;

          while (++i < len) {
            var arg = arguments[i];
            if (!arg) continue;

            if (!Array.isArray(arg)) {
              arg = [arg];
            }

            for (var j = 0; j < arg.length; j++) {
              var ele = arg[j];

              if (init.indexOf(ele) >= 0) {
                continue;
              }
              init.push(ele);
            }
          }
          return init;
        };
      },
      {},
    ],
    4: [
      function (require, module, exports) {
        /*!
         * array-sort <https://github.com/jonschlinkert/array-sort>
         *
         * Copyright (c) 2015-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var defaultCompare = require("default-compare");
        var typeOf = require("kind-of");
        var get = require("get-value");

        /**
         * Sort an array of objects by one or more properties.
         *
         * @param  {Array} `arr` The Array to sort.
         * @param  {String|Array|Function} `props` One or more object paths or comparison functions.
         * @param  {Object} `opts` Pass `{ reverse: true }` to reverse the sort order.
         * @return {Array} Returns a sorted array.
         * @api public
         */

        function arraySort(arr, props, opts) {
          if (arr == null) {
            return [];
          }

          if (!Array.isArray(arr)) {
            throw new TypeError("array-sort expects an array.");
          }

          if (arguments.length === 1) {
            return arr.sort();
          }

          var args = flatten([].slice.call(arguments, 1));

          // if the last argument appears to be a plain object,
          // it's not a valid `compare` arg, so it must be options.
          if (typeOf(args[args.length - 1]) === "object") {
            opts = args.pop();
          }
          return arr.sort(sortBy(args, opts));
        }

        /**
         * Iterate over each comparison property or function until `1` or `-1`
         * is returned.
         *
         * @param  {String|Array|Function} `props` One or more object paths or comparison functions.
         * @param  {Object} `opts` Pass `{ reverse: true }` to reverse the sort order.
         * @return {Array}
         */

        function sortBy(props, opts) {
          opts = opts || {};

          return function compareFn(a, b) {
            var len = props.length,
              i = -1;
            var result;

            while (++i < len) {
              result = compare(props[i], a, b);
              if (result !== 0) {
                break;
              }
            }
            if (opts.reverse === true) {
              return result * -1;
            }
            return result;
          };
        }

        /**
         * Compare `a` to `b`. If an object `prop` is passed, then
         * `a[prop]` is compared to `b[prop]`
         */

        function compare(prop, a, b) {
          if (typeof prop === "function") {
            // expose `compare` to custom function
            return prop(a, b, compare.bind(null, null));
          }
          // compare object values
          if (prop && typeof a === "object" && typeof b === "object") {
            return compare(null, get(a, prop), get(b, prop));
          }
          return defaultCompare(a, b);
        }

        /**
         * Flatten the given array.
         */

        function flatten(arr) {
          return [].concat.apply([], arr);
        }

        /**
         * Expose `arraySort`
         */

        module.exports = arraySort;
      },
      { "default-compare": 45, "get-value": 79, "kind-of": 5 },
    ],
    5: [
      function (require, module, exports) {
        var toString = Object.prototype.toString;

        /**
         * Get the native `typeof` a value.
         *
         * @param  {*} `val`
         * @return {*} Native javascript type
         */

        module.exports = function kindOf(val) {
          var type = typeof val;

          // primitivies
          if (type === "undefined") {
            return "undefined";
          }
          if (val === null) {
            return "null";
          }
          if (val === true || val === false || val instanceof Boolean) {
            return "boolean";
          }
          if (type === "string" || val instanceof String) {
            return "string";
          }
          if (type === "number" || val instanceof Number) {
            return "number";
          }

          // functions
          if (type === "function" || val instanceof Function) {
            if (
              typeof val.constructor.name !== "undefined" &&
              val.constructor.name.slice(0, 9) === "Generator"
            ) {
              return "generatorfunction";
            }
            return "function";
          }

          // array
          if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
            return "array";
          }

          // check for instances of RegExp and Date before calling `toString`
          if (val instanceof RegExp) {
            return "regexp";
          }
          if (val instanceof Date) {
            return "date";
          }

          // other objects
          type = toString.call(val);

          if (type === "[object RegExp]") {
            return "regexp";
          }
          if (type === "[object Date]") {
            return "date";
          }
          if (type === "[object Arguments]") {
            return "arguments";
          }
          if (type === "[object Error]") {
            return "error";
          }
          if (type === "[object Promise]") {
            return "promise";
          }

          // buffer
          if (isBuffer(val)) {
            return "buffer";
          }

          // es6: Map, WeakMap, Set, WeakSet
          if (type === "[object Set]") {
            return "set";
          }
          if (type === "[object WeakSet]") {
            return "weakset";
          }
          if (type === "[object Map]") {
            return "map";
          }
          if (type === "[object WeakMap]") {
            return "weakmap";
          }
          if (type === "[object Symbol]") {
            return "symbol";
          }

          if (type === "[object Map Iterator]") {
            return "mapiterator";
          }
          if (type === "[object Set Iterator]") {
            return "setiterator";
          }
          if (type === "[object String Iterator]") {
            return "stringiterator";
          }
          if (type === "[object Array Iterator]") {
            return "arrayiterator";
          }

          // typed arrays
          if (type === "[object Int8Array]") {
            return "int8array";
          }
          if (type === "[object Uint8Array]") {
            return "uint8array";
          }
          if (type === "[object Uint8ClampedArray]") {
            return "uint8clampedarray";
          }
          if (type === "[object Int16Array]") {
            return "int16array";
          }
          if (type === "[object Uint16Array]") {
            return "uint16array";
          }
          if (type === "[object Int32Array]") {
            return "int32array";
          }
          if (type === "[object Uint32Array]") {
            return "uint32array";
          }
          if (type === "[object Float32Array]") {
            return "float32array";
          }
          if (type === "[object Float64Array]") {
            return "float64array";
          }

          // must be a plain object
          return "object";
        };

        /**
         * If you need to support Safari 5-7 (8-10 yr-old browser),
         * take a look at https://github.com/feross/is-buffer
         */

        function isBuffer(val) {
          return (
            val.constructor &&
            typeof val.constructor.isBuffer === "function" &&
            val.constructor.isBuffer(val)
          );
        }
      },
      {},
    ],
    6: [
      function (require, module, exports) {
        /*!
         * array-unique <https://github.com/jonschlinkert/array-unique>
         *
         * Copyright (c) 2014-2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        module.exports = function unique(arr) {
          if (!Array.isArray(arr)) {
            throw new TypeError("array-unique expects an array.");
          }

          var len = arr.length;
          var i = -1;

          while (i++ < len) {
            var j = i + 1;

            for (; j < arr.length; ++j) {
              if (arr[i] === arr[j]) {
                arr.splice(j--, 1);
              }
            }
          }
          return arr;
        };

        module.exports.immutable = function uniqueImmutable(arr) {
          if (!Array.isArray(arr)) {
            throw new TypeError("array-unique expects an array.");
          }

          var arrLen = arr.length;
          var newArr = new Array(arrLen);

          for (var i = 0; i < arrLen; i++) {
            newArr[i] = arr[i];
          }

          return module.exports(newArr);
        };
      },
      {},
    ],
    7: [
      function (require, module, exports) {
        /*!
         * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
         *
         * Copyright (c) 2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        module.exports = function (receiver, objects) {
          if (receiver === null || typeof receiver === "undefined") {
            throw new TypeError("expected first argument to be an object.");
          }

          if (typeof objects === "undefined" || typeof Symbol === "undefined") {
            return receiver;
          }

          if (typeof Object.getOwnPropertySymbols !== "function") {
            return receiver;
          }

          var isEnumerable = Object.prototype.propertyIsEnumerable;
          var target = Object(receiver);
          var len = arguments.length,
            i = 0;

          while (++i < len) {
            var provider = Object(arguments[i]);
            var names = Object.getOwnPropertySymbols(provider);

            for (var j = 0; j < names.length; j++) {
              var key = names[j];

              if (isEnumerable.call(provider, key)) {
                target[key] = provider[key];
              }
            }
          }
          return target;
        };
      },
      {},
    ],
    8: [
      function (require, module, exports) {
        (function (global) {
          (function () {
            "use strict";

            var possibleNames = [
              "BigInt64Array",
              "BigUint64Array",
              "Float32Array",
              "Float64Array",
              "Int16Array",
              "Int32Array",
              "Int8Array",
              "Uint16Array",
              "Uint32Array",
              "Uint8Array",
              "Uint8ClampedArray",
            ];

            var g = typeof globalThis === "undefined" ? global : globalThis;

            module.exports = function availableTypedArrays() {
              var out = [];
              for (var i = 0; i < possibleNames.length; i++) {
                if (typeof g[possibleNames[i]] === "function") {
                  out[out.length] = possibleNames[i];
                }
              }
              return out;
            };
          }.call(this));
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      {},
    ],
    9: [
      function (require, module, exports) {
        "use strict";

        var util = require("util");
        var define = require("define-property");
        var CacheBase = require("cache-base");
        var Emitter = require("component-emitter");
        var isObject = require("isobject");
        var merge = require("mixin-deep");
        var pascal = require("pascalcase");
        var cu = require("class-utils");

        /**
         * Optionally define a custom `cache` namespace to use.
         */

        function namespace(name) {
          var Cache = name ? CacheBase.namespace(name) : CacheBase;
          var fns = [];

          /**
           * Create an instance of `Base` with the given `config` and `options`.
           *
           * ```js
           * // initialize with `config` and `options`
           * var app = new Base({isApp: true}, {abc: true});
           * app.set('foo', 'bar');
           *
           * // values defined with the given `config` object will be on the root of the instance
           * console.log(app.baz); //=> undefined
           * console.log(app.foo); //=> 'bar'
           * // or use `.get`
           * console.log(app.get('isApp')); //=> true
           * console.log(app.get('foo')); //=> 'bar'
           *
           * // values defined with the given `options` object will be on `app.options
           * console.log(app.options.abc); //=> true
           * ```
           *
           * @param {Object} `config` If supplied, this object is passed to [cache-base][] to merge onto the the instance upon instantiation.
           * @param {Object} `options` If supplied, this object is used to initialize the `base.options` object.
           * @api public
           */

          function Base(config, options) {
            if (!(this instanceof Base)) {
              return new Base(config, options);
            }
            Cache.call(this, config);
            this.is("base");
            this.initBase(config, options);
          }

          /**
           * Inherit cache-base
           */

          util.inherits(Base, Cache);

          /**
           * Add static emitter methods
           */

          Emitter(Base);

          /**
           * Initialize `Base` defaults with the given `config` object
           */

          Base.prototype.initBase = function (config, options) {
            this.options = merge({}, this.options, options);
            this.cache = this.cache || {};
            this.define("registered", {});
            if (name) this[name] = {};

            // make `app._callbacks` non-enumerable
            this.define("_callbacks", this._callbacks);
            if (isObject(config)) {
              this.visit("set", config);
            }
            Base.run(this, "use", fns);
          };

          /**
           * Set the given `name` on `app._name` and `app.is*` properties. Used for doing
           * lookups in plugins.
           *
           * ```js
           * app.is('foo');
           * console.log(app._name);
           * //=> 'foo'
           * console.log(app.isFoo);
           * //=> true
           * app.is('bar');
           * console.log(app.isFoo);
           * //=> true
           * console.log(app.isBar);
           * //=> true
           * console.log(app._name);
           * //=> 'bar'
           * ```
           * @name .is
           * @param {String} `name`
           * @return {Boolean}
           * @api public
           */

          Base.prototype.is = function (name) {
            if (typeof name !== "string") {
              throw new TypeError("expected name to be a string");
            }
            this.define("is" + pascal(name), true);
            this.define("_name", name);
            this.define("_appname", name);
            return this;
          };

          /**
           * Returns true if a plugin has already been registered on an instance.
           *
           * Plugin implementors are encouraged to use this first thing in a plugin
           * to prevent the plugin from being called more than once on the same
           * instance.
           *
           * ```js
           * var base = new Base();
           * base.use(function(app) {
           *   if (app.isRegistered('myPlugin')) return;
           *   // do stuff to `app`
           * });
           *
           * // to also record the plugin as being registered
           * base.use(function(app) {
           *   if (app.isRegistered('myPlugin', true)) return;
           *   // do stuff to `app`
           * });
           * ```
           * @name .isRegistered
           * @emits `plugin` Emits the name of the plugin being registered. Useful for unit tests, to ensure plugins are only registered once.
           * @param {String} `name` The plugin name.
           * @param {Boolean} `register` If the plugin if not already registered, to record it as being registered pass `true` as the second argument.
           * @return {Boolean} Returns true if a plugin is already registered.
           * @api public
           */

          Base.prototype.isRegistered = function (name, register) {
            if (this.registered.hasOwnProperty(name)) {
              return true;
            }
            if (register !== false) {
              this.registered[name] = true;
              this.emit("plugin", name);
            }
            return false;
          };

          /**
           * Define a plugin function to be called immediately upon init. Plugins are chainable
           * and expose the following arguments to the plugin function:
           *
           * - `app`: the current instance of `Base`
           * - `base`: the [first ancestor instance](#base) of `Base`
           *
           * ```js
           * var app = new Base()
           *   .use(foo)
           *   .use(bar)
           *   .use(baz)
           * ```
           * @name .use
           * @param {Function} `fn` plugin function to call
           * @return {Object} Returns the item instance for chaining.
           * @api public
           */

          Base.prototype.use = function (fn) {
            fn.call(this, this);
            return this;
          };

          /**
           * The `.define` method is used for adding non-enumerable property on the instance.
           * Dot-notation is **not supported** with `define`.
           *
           * ```js
           * // arbitrary `render` function using lodash `template`
           * app.define('render', function(str, locals) {
           *   return _.template(str)(locals);
           * });
           * ```
           * @name .define
           * @param {String} `key` The name of the property to define.
           * @param {any} `value`
           * @return {Object} Returns the instance for chaining.
           * @api public
           */

          Base.prototype.define = function (key, val) {
            if (isObject(key)) {
              return this.visit("define", key);
            }
            define(this, key, val);
            return this;
          };

          /**
           * Mix property `key` onto the Base prototype. If base is inherited using
           * `Base.extend` this method will be overridden by a new `mixin` method that will
           * only add properties to the prototype of the inheriting application.
           *
           * ```js
           * app.mixin('foo', function() {
           *   // do stuff
           * });
           * ```
           * @name .mixin
           * @param {String} `key`
           * @param {Object|Array} `val`
           * @return {Object} Returns the `base` instance for chaining.
           * @api public
           */

          Base.prototype.mixin = function (key, val) {
            Base.prototype[key] = val;
            return this;
          };

          /**
           * Non-enumberable mixin array, used by the static [Base.mixin]() method.
           */

          Base.prototype.mixins = Base.prototype.mixins || [];

          /**
           * Getter/setter used when creating nested instances of `Base`, for storing a reference
           * to the first ancestor instance. This works by setting an instance of `Base` on the `parent`
           * property of a "child" instance. The `base` property defaults to the current instance if
           * no `parent` property is defined.
           *
           * ```js
           * // create an instance of `Base`, this is our first ("base") instance
           * var first = new Base();
           * first.foo = 'bar'; // arbitrary property, to make it easier to see what's happening later
           *
           * // create another instance
           * var second = new Base();
           * // create a reference to the first instance (`first`)
           * second.parent = first;
           *
           * // create another instance
           * var third = new Base();
           * // create a reference to the previous instance (`second`)
           * // repeat this pattern every time a "child" instance is created
           * third.parent = second;
           *
           * // we can always access the first instance using the `base` property
           * console.log(first.base.foo);
           * //=> 'bar'
           * console.log(second.base.foo);
           * //=> 'bar'
           * console.log(third.base.foo);
           * //=> 'bar'
           * // and now you know how to get to third base ;)
           * ```
           * @name .base
           * @api public
           */

          Object.defineProperty(Base.prototype, "base", {
            configurable: true,
            get: function () {
              return this.parent ? this.parent.base : this;
            },
          });

          /**
           * Static method for adding global plugin functions that will
           * be added to an instance when created.
           *
           * ```js
           * Base.use(function(app) {
           *   app.foo = 'bar';
           * });
           * var app = new Base();
           * console.log(app.foo);
           * //=> 'bar'
           * ```
           * @name #use
           * @param {Function} `fn` Plugin function to use on each instance.
           * @return {Object} Returns the `Base` constructor for chaining
           * @api public
           */

          define(Base, "use", function (fn) {
            fns.push(fn);
            return Base;
          });

          /**
           * Run an array of functions by passing each function
           * to a method on the given object specified by the given property.
           *
           * @param  {Object} `obj` Object containing method to use.
           * @param  {String} `prop` Name of the method on the object to use.
           * @param  {Array} `arr` Array of functions to pass to the method.
           */

          define(Base, "run", function (obj, prop, arr) {
            var len = arr.length,
              i = 0;
            while (len--) {
              obj[prop](arr[i++]);
            }
            return Base;
          });

          /**
           * Static method for inheriting the prototype and static methods of the `Base` class.
           * This method greatly simplifies the process of creating inheritance-based applications.
           * See [static-extend][] for more details.
           *
           * ```js
           * var extend = cu.extend(Parent);
           * Parent.extend(Child);
           *
           * // optional methods
           * Parent.extend(Child, {
           *   foo: function() {},
           *   bar: function() {}
           * });
           * ```
           * @name #extend
           * @param {Function} `Ctor` constructor to extend
           * @param {Object} `methods` Optional prototype properties to mix in.
           * @return {Object} Returns the `Base` constructor for chaining
           * @api public
           */

          define(
            Base,
            "extend",
            cu.extend(Base, function (Ctor, Parent) {
              Ctor.prototype.mixins = Ctor.prototype.mixins || [];

              define(Ctor, "mixin", function (fn) {
                var mixin = fn(Ctor.prototype, Ctor);
                if (typeof mixin === "function") {
                  Ctor.prototype.mixins.push(mixin);
                }
                return Ctor;
              });

              define(Ctor, "mixins", function (Child) {
                Base.run(Child, "mixin", Ctor.prototype.mixins);
                return Ctor;
              });

              Ctor.prototype.mixin = function (key, value) {
                Ctor.prototype[key] = value;
                return this;
              };
              return Base;
            })
          );

          /**
           * Used for adding methods to the `Base` prototype, and/or to the prototype of child instances.
           * When a mixin function returns a function, the returned function is pushed onto the `.mixins`
           * array, making it available to be used on inheriting classes whenever `Base.mixins()` is
           * called (e.g. `Base.mixins(Child)`).
           *
           * ```js
           * Base.mixin(function(proto) {
           *   proto.foo = function(msg) {
           *     return 'foo ' + msg;
           *   };
           * });
           * ```
           * @name #mixin
           * @param {Function} `fn` Function to call
           * @return {Object} Returns the `Base` constructor for chaining
           * @api public
           */

          define(Base, "mixin", function (fn) {
            var mixin = fn(Base.prototype, Base);
            if (typeof mixin === "function") {
              Base.prototype.mixins.push(mixin);
            }
            return Base;
          });

          /**
           * Static method for running global mixin functions against a child constructor.
           * Mixins must be registered before calling this method.
           *
           * ```js
           * Base.extend(Child);
           * Base.mixins(Child);
           * ```
           * @name #mixins
           * @param {Function} `Child` Constructor function of a child class
           * @return {Object} Returns the `Base` constructor for chaining
           * @api public
           */

          define(Base, "mixins", function (Child) {
            Base.run(Child, "mixin", Base.prototype.mixins);
            return Base;
          });

          /**
           * Similar to `util.inherit`, but copies all static properties, prototype properties, and
           * getters/setters from `Provider` to `Receiver`. See [class-utils][]{#inherit} for more details.
           *
           * ```js
           * Base.inherit(Foo, Bar);
           * ```
           * @name #inherit
           * @param {Function} `Receiver` Receiving (child) constructor
           * @param {Function} `Provider` Providing (parent) constructor
           * @return {Object} Returns the `Base` constructor for chaining
           * @api public
           */

          define(Base, "inherit", cu.inherit);
          define(Base, "bubble", cu.bubble);
          return Base;
        }

        /**
         * Expose `Base` with default settings
         */

        module.exports = namespace();

        /**
         * Allow users to define a namespace
         */

        module.exports.namespace = namespace;
      },
      {
        "cache-base": 11,
        "class-utils": 14,
        "component-emitter": 23,
        "define-property": 47,
        isobject: 131,
        "mixin-deep": 155,
        pascalcase: 176,
        util: 264,
      },
    ],
    10: [function (require, module, exports) {}, {}],
    11: [
      function (require, module, exports) {
        "use strict";

        var isObject = require("isobject");
        var Emitter = require("component-emitter");
        var visit = require("collection-visit");
        var toPath = require("to-object-path");
        var union = require("union-value");
        var del = require("unset-value");
        var get = require("get-value");
        var has = require("has-value");
        var set = require("set-value");

        /**
         * Create a `Cache` constructor that when instantiated will
         * store values on the given `prop`.
         *
         * ```js
         * var Cache = require('cache-base').namespace('data');
         * var cache = new Cache();
         *
         * cache.set('foo', 'bar');
         * //=> {data: {foo: 'bar'}}
         * ```
         * @param {String} `prop` The property name to use for storing values.
         * @return {Function} Returns a custom `Cache` constructor
         * @api public
         */

        function namespace(prop) {
          /**
           * Create a new `Cache`. Internally the `Cache` constructor is created using
           * the `namespace` function, with `cache` defined as the storage object.
           *
           * ```js
           * var app = new Cache();
           * ```
           * @param {Object} `cache` Optionally pass an object to initialize with.
           * @constructor
           * @api public
           */

          function Cache(cache) {
            if (prop) {
              this[prop] = {};
            }
            if (cache) {
              this.set(cache);
            }
          }

          /**
           * Inherit Emitter
           */

          Emitter(Cache.prototype);

          /**
           * Assign `value` to `key`. Also emits `set` with
           * the key and value.
           *
           * ```js
           * app.on('set', function(key, val) {
           *   // do something when `set` is emitted
           * });
           *
           * app.set(key, value);
           *
           * // also takes an object or array
           * app.set({name: 'Halle'});
           * app.set([{foo: 'bar'}, {baz: 'quux'}]);
           * console.log(app);
           * //=> {name: 'Halle', foo: 'bar', baz: 'quux'}
           * ```
           *
           * @name .set
           * @emits `set` with `key` and `value` as arguments.
           * @param {String} `key`
           * @param {any} `value`
           * @return {Object} Returns the instance for chaining.
           * @api public
           */

          Cache.prototype.set = function (key, val) {
            if (Array.isArray(key) && arguments.length === 2) {
              key = toPath(key);
            }
            if (isObject(key) || Array.isArray(key)) {
              this.visit("set", key);
            } else {
              set(prop ? this[prop] : this, key, val);
              this.emit("set", key, val);
            }
            return this;
          };

          /**
           * Union `array` to `key`. Also emits `set` with
           * the key and value.
           *
           * ```js
           * app.union('a.b', ['foo']);
           * app.union('a.b', ['bar']);
           * console.log(app.get('a'));
           * //=> {b: ['foo', 'bar']}
           * ```
           * @name .union
           * @param {String} `key`
           * @param {any} `value`
           * @return {Object} Returns the instance for chaining.
           * @api public
           */

          Cache.prototype.union = function (key, val) {
            if (Array.isArray(key) && arguments.length === 2) {
              key = toPath(key);
            }
            var ctx = prop ? this[prop] : this;
            union(ctx, key, arrayify(val));
            this.emit("union", val);
            return this;
          };

          /**
           * Return the value of `key`. Dot notation may be used
           * to get [nested property values][get-value].
           *
           * ```js
           * app.set('a.b.c', 'd');
           * app.get('a.b');
           * //=> {c: 'd'}
           *
           * app.get(['a', 'b']);
           * //=> {c: 'd'}
           * ```
           *
           * @name .get
           * @emits `get` with `key` and `value` as arguments.
           * @param {String} `key` The name of the property to get. Dot-notation may be used.
           * @return {any} Returns the value of `key`
           * @api public
           */

          Cache.prototype.get = function (key) {
            key = toPath(arguments);

            var ctx = prop ? this[prop] : this;
            var val = get(ctx, key);

            this.emit("get", key, val);
            return val;
          };

          /**
           * Return true if app has a stored value for `key`,
           * false only if value is `undefined`.
           *
           * ```js
           * app.set('foo', 'bar');
           * app.has('foo');
           * //=> true
           * ```
           *
           * @name .has
           * @emits `has` with `key` and true or false as arguments.
           * @param {String} `key`
           * @return {Boolean}
           * @api public
           */

          Cache.prototype.has = function (key) {
            key = toPath(arguments);

            var ctx = prop ? this[prop] : this;
            var val = get(ctx, key);

            var has = typeof val !== "undefined";
            this.emit("has", key, has);
            return has;
          };

          /**
           * Delete one or more properties from the instance.
           *
           * ```js
           * app.del(); // delete all
           * // or
           * app.del('foo');
           * // or
           * app.del(['foo', 'bar']);
           * ```
           * @name .del
           * @emits `del` with the `key` as the only argument.
           * @param {String|Array} `key` Property name or array of property names.
           * @return {Object} Returns the instance for chaining.
           * @api public
           */

          Cache.prototype.del = function (key) {
            if (Array.isArray(key)) {
              this.visit("del", key);
            } else {
              del(prop ? this[prop] : this, key);
              this.emit("del", key);
            }
            return this;
          };

          /**
           * Reset the entire cache to an empty object.
           *
           * ```js
           * app.clear();
           * ```
           * @api public
           */

          Cache.prototype.clear = function () {
            if (prop) {
              this[prop] = {};
            }
          };

          /**
           * Visit `method` over the properties in the given object, or map
           * visit over the object-elements in an array.
           *
           * @name .visit
           * @param {String} `method` The name of the `base` method to call.
           * @param {Object|Array} `val` The object or array to iterate over.
           * @return {Object} Returns the instance for chaining.
           * @api public
           */

          Cache.prototype.visit = function (method, val) {
            visit(this, method, val);
            return this;
          };

          return Cache;
        }

        /**
         * Cast val to an array
         */

        function arrayify(val) {
          return val ? (Array.isArray(val) ? val : [val]) : [];
        }

        /**
         * Expose `Cache`
         */

        module.exports = namespace();

        /**
         * Expose `Cache.namespace`
         */

        module.exports.namespace = namespace;
      },
      {
        "collection-visit": 22,
        "component-emitter": 23,
        "get-value": 79,
        "has-value": 103,
        isobject: 131,
        "set-value": 200,
        "to-object-path": 246,
        "union-value": 254,
        "unset-value": 255,
      },
    ],
    12: [
      function (require, module, exports) {
        "use strict";

        var GetIntrinsic = require("get-intrinsic");

        var callBind = require("./");

        var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));

        module.exports = function callBoundIntrinsic(name, allowMissing) {
          var intrinsic = GetIntrinsic(name, !!allowMissing);
          if (
            typeof intrinsic === "function" &&
            $indexOf(name, ".prototype.") > -1
          ) {
            return callBind(intrinsic);
          }
          return intrinsic;
        };
      },
      { "./": 13, "get-intrinsic": 75 },
    ],
    13: [
      function (require, module, exports) {
        "use strict";

        var bind = require("function-bind");
        var GetIntrinsic = require("get-intrinsic");

        var $apply = GetIntrinsic("%Function.prototype.apply%");
        var $call = GetIntrinsic("%Function.prototype.call%");
        var $reflectApply =
          GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);

        var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
        var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
        var $max = GetIntrinsic("%Math.max%");

        if ($defineProperty) {
          try {
            $defineProperty({}, "a", { value: 1 });
          } catch (e) {
            // IE 8 has a broken defineProperty
            $defineProperty = null;
          }
        }

        module.exports = function callBind(originalFunction) {
          var func = $reflectApply(bind, $call, arguments);
          if ($gOPD && $defineProperty) {
            var desc = $gOPD(func, "length");
            if (desc.configurable) {
              // original length, plus the receiver, minus any additional arguments (after the receiver)
              $defineProperty(func, "length", {
                value:
                  1 + $max(0, originalFunction.length - (arguments.length - 1)),
              });
            }
          }
          return func;
        };

        var applyBind = function applyBind() {
          return $reflectApply(bind, $apply, arguments);
        };

        if ($defineProperty) {
          $defineProperty(module.exports, "apply", { value: applyBind });
        } else {
          module.exports.apply = applyBind;
        }
      },
      { "function-bind": 74, "get-intrinsic": 75 },
    ],
    14: [
      function (require, module, exports) {
        "use strict";

        var util = require("util");
        var union = require("arr-union");
        var define = require("define-property");
        var staticExtend = require("static-extend");
        var isObj = require("isobject");

        /**
         * Expose class utils
         */

        var cu = module.exports;

        /**
         * Expose class utils: `cu`
         */

        cu.isObject = function isObject(val) {
          return isObj(val) || typeof val === "function";
        };

        /**
         * Returns true if an array has any of the given elements, or an
         * object has any of the give keys.
         *
         * ```js
         * cu.has(['a', 'b', 'c'], 'c');
         * //=> true
         *
         * cu.has(['a', 'b', 'c'], ['c', 'z']);
         * //=> true
         *
         * cu.has({a: 'b', c: 'd'}, ['c', 'z']);
         * //=> true
         * ```
         * @param {Object} `obj`
         * @param {String|Array} `val`
         * @return {Boolean}
         * @api public
         */

        cu.has = function has(obj, val) {
          val = cu.arrayify(val);
          var len = val.length;

          if (cu.isObject(obj)) {
            for (var key in obj) {
              if (val.indexOf(key) > -1) {
                return true;
              }
            }

            var keys = cu.nativeKeys(obj);
            return cu.has(keys, val);
          }

          if (Array.isArray(obj)) {
            var arr = obj;
            while (len--) {
              if (arr.indexOf(val[len]) > -1) {
                return true;
              }
            }
            return false;
          }

          throw new TypeError("expected an array or object.");
        };

        /**
         * Returns true if an array or object has all of the given values.
         *
         * ```js
         * cu.hasAll(['a', 'b', 'c'], 'c');
         * //=> true
         *
         * cu.hasAll(['a', 'b', 'c'], ['c', 'z']);
         * //=> false
         *
         * cu.hasAll({a: 'b', c: 'd'}, ['c', 'z']);
         * //=> false
         * ```
         * @param {Object|Array} `val`
         * @param {String|Array} `values`
         * @return {Boolean}
         * @api public
         */

        cu.hasAll = function hasAll(val, values) {
          values = cu.arrayify(values);
          var len = values.length;
          while (len--) {
            if (!cu.has(val, values[len])) {
              return false;
            }
          }
          return true;
        };

        /**
         * Cast the given value to an array.
         *
         * ```js
         * cu.arrayify('foo');
         * //=> ['foo']
         *
         * cu.arrayify(['foo']);
         * //=> ['foo']
         * ```
         *
         * @param {String|Array} `val`
         * @return {Array}
         * @api public
         */

        cu.arrayify = function arrayify(val) {
          return val ? (Array.isArray(val) ? val : [val]) : [];
        };

        /**
         * Noop
         */

        cu.noop = function noop() {
          return;
        };

        /**
         * Returns the first argument passed to the function.
         */

        cu.identity = function identity(val) {
          return val;
        };

        /**
         * Returns true if a value has a `contructor`
         *
         * ```js
         * cu.hasConstructor({});
         * //=> true
         *
         * cu.hasConstructor(Object.create(null));
         * //=> false
         * ```
         * @param  {Object} `value`
         * @return {Boolean}
         * @api public
         */

        cu.hasConstructor = function hasConstructor(val) {
          return cu.isObject(val) && typeof val.constructor !== "undefined";
        };

        /**
         * Get the native `ownPropertyNames` from the constructor of the
         * given `object`. An empty array is returned if the object does
         * not have a constructor.
         *
         * ```js
         * cu.nativeKeys({a: 'b', b: 'c', c: 'd'})
         * //=> ['a', 'b', 'c']
         *
         * cu.nativeKeys(function(){})
         * //=> ['length', 'caller']
         * ```
         *
         * @param  {Object} `obj` Object that has a `constructor`.
         * @return {Array} Array of keys.
         * @api public
         */

        cu.nativeKeys = function nativeKeys(val) {
          if (!cu.hasConstructor(val)) return [];
          var keys = Object.getOwnPropertyNames(val);
          if ("caller" in val) keys.push("caller");
          return keys;
        };

        /**
         * Returns property descriptor `key` if it's an "own" property
         * of the given object.
         *
         * ```js
         * function App() {}
         * Object.defineProperty(App.prototype, 'count', {
         *   get: function() {
         *     return Object.keys(this).length;
         *   }
         * });
         * cu.getDescriptor(App.prototype, 'count');
         * // returns:
         * // {
         * //   get: [Function],
         * //   set: undefined,
         * //   enumerable: false,
         * //   configurable: false
         * // }
         * ```
         *
         * @param {Object} `obj`
         * @param {String} `key`
         * @return {Object} Returns descriptor `key`
         * @api public
         */

        cu.getDescriptor = function getDescriptor(obj, key) {
          if (!cu.isObject(obj)) {
            throw new TypeError("expected an object.");
          }
          if (typeof key !== "string") {
            throw new TypeError("expected key to be a string.");
          }
          return Object.getOwnPropertyDescriptor(obj, key);
        };

        /**
         * Copy a descriptor from one object to another.
         *
         * ```js
         * function App() {}
         * Object.defineProperty(App.prototype, 'count', {
         *   get: function() {
         *     return Object.keys(this).length;
         *   }
         * });
         * var obj = {};
         * cu.copyDescriptor(obj, App.prototype, 'count');
         * ```
         * @param {Object} `receiver`
         * @param {Object} `provider`
         * @param {String} `name`
         * @return {Object}
         * @api public
         */

        cu.copyDescriptor = function copyDescriptor(receiver, provider, name) {
          if (!cu.isObject(receiver)) {
            throw new TypeError("expected receiving object to be an object.");
          }
          if (!cu.isObject(provider)) {
            throw new TypeError("expected providing object to be an object.");
          }
          if (typeof name !== "string") {
            throw new TypeError("expected name to be a string.");
          }

          var val = cu.getDescriptor(provider, name);
          if (val) Object.defineProperty(receiver, name, val);
        };

        /**
         * Copy static properties, prototype properties, and descriptors
         * from one object to another.
         *
         * @param {Object} `receiver`
         * @param {Object} `provider`
         * @param {String|Array} `omit` One or more properties to omit
         * @return {Object}
         * @api public
         */

        cu.copy = function copy(receiver, provider, omit) {
          if (!cu.isObject(receiver)) {
            throw new TypeError("expected receiving object to be an object.");
          }
          if (!cu.isObject(provider)) {
            throw new TypeError("expected providing object to be an object.");
          }
          var props = Object.getOwnPropertyNames(provider);
          var keys = Object.keys(provider);
          var len = props.length,
            key;
          omit = cu.arrayify(omit);

          while (len--) {
            key = props[len];

            if (cu.has(keys, key)) {
              define(receiver, key, provider[key]);
            } else if (!(key in receiver) && !cu.has(omit, key)) {
              cu.copyDescriptor(receiver, provider, key);
            }
          }
        };

        /**
         * Inherit the static properties, prototype properties, and descriptors
         * from of an object.
         *
         * @param {Object} `receiver`
         * @param {Object} `provider`
         * @param {String|Array} `omit` One or more properties to omit
         * @return {Object}
         * @api public
         */

        cu.inherit = function inherit(receiver, provider, omit) {
          if (!cu.isObject(receiver)) {
            throw new TypeError("expected receiving object to be an object.");
          }
          if (!cu.isObject(provider)) {
            throw new TypeError("expected providing object to be an object.");
          }

          var keys = [];
          for (var key in provider) {
            keys.push(key);
            receiver[key] = provider[key];
          }

          keys = keys.concat(cu.arrayify(omit));

          var a = provider.prototype || provider;
          var b = receiver.prototype || receiver;
          cu.copy(b, a, keys);
        };

        /**
         * Returns a function for extending the static properties,
         * prototype properties, and descriptors from the `Parent`
         * constructor onto `Child` constructors.
         *
         * ```js
         * var extend = cu.extend(Parent);
         * Parent.extend(Child);
         *
         * // optional methods
         * Parent.extend(Child, {
         *   foo: function() {},
         *   bar: function() {}
         * });
         * ```
         * @param {Function} `Parent` Parent ctor
         * @param {Function} `extend` Optional extend function to handle custom extensions. Useful when updating methods that require a specific prototype.
         *   @param {Function} `Child` Child ctor
         *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.
         *   @return {Object}
         * @api public
         */

        cu.extend = function () {
          // keep it lazy, instead of assigning to `cu.extend`
          return staticExtend.apply(null, arguments);
        };

        /**
         * Bubble up events emitted from static methods on the Parent ctor.
         *
         * @param {Object} `Parent`
         * @param {Array} `events` Event names to bubble up
         * @api public
         */

        cu.bubble = function (Parent, events) {
          events = events || [];
          Parent.bubble = function (Child, arr) {
            if (Array.isArray(arr)) {
              events = union([], events, arr);
            }
            var len = events.length;
            var idx = -1;
            while (++idx < len) {
              var name = events[idx];
              Parent.on(name, Child.emit.bind(Child, name));
            }
            cu.bubble(Child, events);
          };
        };
      },
      {
        "arr-union": 3,
        "define-property": 15,
        isobject: 131,
        "static-extend": 235,
        util: 264,
      },
    ],
    15: [
      function (require, module, exports) {
        /*!
         * define-property <https://github.com/jonschlinkert/define-property>
         *
         * Copyright (c) 2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        var isDescriptor = require("is-descriptor");

        module.exports = function defineProperty(obj, prop, val) {
          if (typeof obj !== "object" && typeof obj !== "function") {
            throw new TypeError("expected an object or function.");
          }

          if (typeof prop !== "string") {
            throw new TypeError("expected `prop` to be a string.");
          }

          if (isDescriptor(val) && ("set" in val || "get" in val)) {
            return Object.defineProperty(obj, prop, val);
          }

          return Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: val,
          });
        };
      },
      { "is-descriptor": 20 },
    ],
    16: [
      function (require, module, exports) {
        /*!
         * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
         *
         * Copyright (c) 2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        var typeOf = require("kind-of");

        // accessor descriptor properties
        var accessor = {
          get: "function",
          set: "function",
          configurable: "boolean",
          enumerable: "boolean",
        };

        function isAccessorDescriptor(obj, prop) {
          if (typeof prop === "string") {
            var val = Object.getOwnPropertyDescriptor(obj, prop);
            return typeof val !== "undefined";
          }

          if (typeOf(obj) !== "object") {
            return false;
          }

          if (has(obj, "value") || has(obj, "writable")) {
            return false;
          }

          if (!has(obj, "get") || typeof obj.get !== "function") {
            return false;
          }

          // tldr: it's valid to have "set" be undefined
          // "set" might be undefined if `Object.getOwnPropertyDescriptor`
          // was used to get the value, and only `get` was defined by the user
          if (
            has(obj, "set") &&
            typeof obj[key] !== "function" &&
            typeof obj[key] !== "undefined"
          ) {
            return false;
          }

          for (var key in obj) {
            if (!accessor.hasOwnProperty(key)) {
              continue;
            }

            if (typeOf(obj[key]) === accessor[key]) {
              continue;
            }

            if (typeof obj[key] !== "undefined") {
              return false;
            }
          }
          return true;
        }

        function has(obj, key) {
          return {}.hasOwnProperty.call(obj, key);
        }

        /**
         * Expose `isAccessorDescriptor`
         */

        module.exports = isAccessorDescriptor;
      },
      { "kind-of": 17 },
    ],
    17: [
      function (require, module, exports) {
        var isBuffer = require("is-buffer");
        var toString = Object.prototype.toString;

        /**
         * Get the native `typeof` a value.
         *
         * @param  {*} `val`
         * @return {*} Native javascript type
         */

        module.exports = function kindOf(val) {
          // primitivies
          if (typeof val === "undefined") {
            return "undefined";
          }
          if (val === null) {
            return "null";
          }
          if (val === true || val === false || val instanceof Boolean) {
            return "boolean";
          }
          if (typeof val === "string" || val instanceof String) {
            return "string";
          }
          if (typeof val === "number" || val instanceof Number) {
            return "number";
          }

          // functions
          if (typeof val === "function" || val instanceof Function) {
            return "function";
          }

          // array
          if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
            return "array";
          }

          // check for instances of RegExp and Date before calling `toString`
          if (val instanceof RegExp) {
            return "regexp";
          }
          if (val instanceof Date) {
            return "date";
          }

          // other objects
          var type = toString.call(val);

          if (type === "[object RegExp]") {
            return "regexp";
          }
          if (type === "[object Date]") {
            return "date";
          }
          if (type === "[object Arguments]") {
            return "arguments";
          }
          if (type === "[object Error]") {
            return "error";
          }

          // buffer
          if (isBuffer(val)) {
            return "buffer";
          }

          // es6: Map, WeakMap, Set, WeakSet
          if (type === "[object Set]") {
            return "set";
          }
          if (type === "[object WeakSet]") {
            return "weakset";
          }
          if (type === "[object Map]") {
            return "map";
          }
          if (type === "[object WeakMap]") {
            return "weakmap";
          }
          if (type === "[object Symbol]") {
            return "symbol";
          }

          // typed arrays
          if (type === "[object Int8Array]") {
            return "int8array";
          }
          if (type === "[object Uint8Array]") {
            return "uint8array";
          }
          if (type === "[object Uint8ClampedArray]") {
            return "uint8clampedarray";
          }
          if (type === "[object Int16Array]") {
            return "int16array";
          }
          if (type === "[object Uint16Array]") {
            return "uint16array";
          }
          if (type === "[object Int32Array]") {
            return "int32array";
          }
          if (type === "[object Uint32Array]") {
            return "uint32array";
          }
          if (type === "[object Float32Array]") {
            return "float32array";
          }
          if (type === "[object Float64Array]") {
            return "float64array";
          }

          // must be a plain object
          return "object";
        };
      },
      { "is-buffer": 114 },
    ],
    18: [
      function (require, module, exports) {
        /*!
         * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
         *
         * Copyright (c) 2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        var typeOf = require("kind-of");

        // data descriptor properties
        var data = {
          configurable: "boolean",
          enumerable: "boolean",
          writable: "boolean",
        };

        function isDataDescriptor(obj, prop) {
          if (typeOf(obj) !== "object") {
            return false;
          }

          if (typeof prop === "string") {
            var val = Object.getOwnPropertyDescriptor(obj, prop);
            return typeof val !== "undefined";
          }

          if (!("value" in obj) && !("writable" in obj)) {
            return false;
          }

          for (var key in obj) {
            if (key === "value") continue;

            if (!data.hasOwnProperty(key)) {
              continue;
            }

            if (typeOf(obj[key]) === data[key]) {
              continue;
            }

            if (typeof obj[key] !== "undefined") {
              return false;
            }
          }
          return true;
        }

        /**
         * Expose `isDataDescriptor`
         */

        module.exports = isDataDescriptor;
      },
      { "kind-of": 19 },
    ],
    19: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    20: [
      function (require, module, exports) {
        /*!
         * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
         *
         * Copyright (c) 2015-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var typeOf = require("kind-of");
        var isAccessor = require("is-accessor-descriptor");
        var isData = require("is-data-descriptor");

        module.exports = function isDescriptor(obj, key) {
          if (typeOf(obj) !== "object") {
            return false;
          }
          if ("get" in obj) {
            return isAccessor(obj, key);
          }
          return isData(obj, key);
        };
      },
      { "is-accessor-descriptor": 16, "is-data-descriptor": 18, "kind-of": 21 },
    ],
    21: [
      function (require, module, exports) {
        arguments[4][5][0].apply(exports, arguments);
      },
      { dup: 5 },
    ],
    22: [
      function (require, module, exports) {
        /*!
         * collection-visit <https://github.com/jonschlinkert/collection-visit>
         *
         * Copyright (c) 2015, 2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var visit = require("object-visit");
        var mapVisit = require("map-visit");

        module.exports = function (collection, method, val) {
          var result;

          if (typeof val === "string" && method in collection) {
            var args = [].slice.call(arguments, 2);
            result = collection[method].apply(collection, args);
          } else if (Array.isArray(val)) {
            result = mapVisit.apply(null, arguments);
          } else {
            result = visit.apply(null, arguments);
          }

          if (typeof result !== "undefined") {
            return result;
          }

          return collection;
        };
      },
      { "map-visit": 135, "object-visit": 174 },
    ],
    23: [
      function (require, module, exports) {
        /**
         * Expose `Emitter`.
         */

        if (typeof module !== "undefined") {
          module.exports = Emitter;
        }

        /**
         * Initialize a new `Emitter`.
         *
         * @api public
         */

        function Emitter(obj) {
          if (obj) return mixin(obj);
        }

        /**
         * Mixin the emitter properties.
         *
         * @param {Object} obj
         * @return {Object}
         * @api private
         */

        function mixin(obj) {
          for (var key in Emitter.prototype) {
            obj[key] = Emitter.prototype[key];
          }
          return obj;
        }

        /**
         * Listen on the given `event` with `fn`.
         *
         * @param {String} event
         * @param {Function} fn
         * @return {Emitter}
         * @api public
         */

        Emitter.prototype.on = Emitter.prototype.addEventListener = function (
          event,
          fn
        ) {
          this._callbacks = this._callbacks || {};
          (this._callbacks["$" + event] =
            this._callbacks["$" + event] || []).push(fn);
          return this;
        };

        /**
         * Adds an `event` listener that will be invoked a single
         * time then automatically removed.
         *
         * @param {String} event
         * @param {Function} fn
         * @return {Emitter}
         * @api public
         */

        Emitter.prototype.once = function (event, fn) {
          function on() {
            this.off(event, on);
            fn.apply(this, arguments);
          }

          on.fn = fn;
          this.on(event, on);
          return this;
        };

        /**
         * Remove the given callback for `event` or all
         * registered callbacks.
         *
         * @param {String} event
         * @param {Function} fn
         * @return {Emitter}
         * @api public
         */

        Emitter.prototype.off =
          Emitter.prototype.removeListener =
          Emitter.prototype.removeAllListeners =
          Emitter.prototype.removeEventListener =
            function (event, fn) {
              this._callbacks = this._callbacks || {};

              // all
              if (0 == arguments.length) {
                this._callbacks = {};
                return this;
              }

              // specific event
              var callbacks = this._callbacks["$" + event];
              if (!callbacks) return this;

              // remove all handlers
              if (1 == arguments.length) {
                delete this._callbacks["$" + event];
                return this;
              }

              // remove specific handler
              var cb;
              for (var i = 0; i < callbacks.length; i++) {
                cb = callbacks[i];
                if (cb === fn || cb.fn === fn) {
                  callbacks.splice(i, 1);
                  break;
                }
              }

              // Remove event specific arrays for event types that no
              // one is subscribed for to avoid memory leak.
              if (callbacks.length === 0) {
                delete this._callbacks["$" + event];
              }

              return this;
            };

        /**
         * Emit `event` with the given args.
         *
         * @param {String} event
         * @param {Mixed} ...
         * @return {Emitter}
         */

        Emitter.prototype.emit = function (event) {
          this._callbacks = this._callbacks || {};

          var args = new Array(arguments.length - 1),
            callbacks = this._callbacks["$" + event];

          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }

          if (callbacks) {
            callbacks = callbacks.slice(0);
            for (var i = 0, len = callbacks.length; i < len; ++i) {
              callbacks[i].apply(this, args);
            }
          }

          return this;
        };

        /**
         * Return array of callbacks for `event`.
         *
         * @param {String} event
         * @return {Array}
         * @api public
         */

        Emitter.prototype.listeners = function (event) {
          this._callbacks = this._callbacks || {};
          return this._callbacks["$" + event] || [];
        };

        /**
         * Check if this emitter has `event` handlers.
         *
         * @param {String} event
         * @return {Boolean}
         * @api public
         */

        Emitter.prototype.hasListeners = function (event) {
          return !!this.listeners(event).length;
        };
      },
      {},
    ],
    24: [
      function (require, module, exports) {
        /*!
         * copy-descriptor <https://github.com/jonschlinkert/copy-descriptor>
         *
         * Copyright (c) 2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        /**
         * Copy a descriptor from one object to another.
         *
         * ```js
         * function App() {
         *   this.cache = {};
         * }
         * App.prototype.set = function(key, val) {
         *   this.cache[key] = val;
         *   return this;
         * };
         * Object.defineProperty(App.prototype, 'count', {
         *   get: function() {
         *     return Object.keys(this.cache).length;
         *   }
         * });
         *
         * copy(App.prototype, 'count', 'len');
         *
         * // create an instance
         * var app = new App();
         *
         * app.set('a', true);
         * app.set('b', true);
         * app.set('c', true);
         *
         * console.log(app.count);
         * //=> 3
         * console.log(app.len);
         * //=> 3
         * ```
         * @name copy
         * @param {Object} `receiver` The target object
         * @param {Object} `provider` The provider object
         * @param {String} `from` The key to copy on provider.
         * @param {String} `to` Optionally specify a new key name to use.
         * @return {Object}
         * @api public
         */

        module.exports = function copyDescriptor(receiver, provider, from, to) {
          if (!isObject(provider) && typeof provider !== "function") {
            to = from;
            from = provider;
            provider = receiver;
          }
          if (!isObject(receiver) && typeof receiver !== "function") {
            throw new TypeError("expected the first argument to be an object");
          }
          if (!isObject(provider) && typeof provider !== "function") {
            throw new TypeError("expected provider to be an object");
          }

          if (typeof to !== "string") {
            to = from;
          }
          if (typeof from !== "string") {
            throw new TypeError("expected key to be a string");
          }

          if (!(from in provider)) {
            throw new Error('property "' + from + '" does not exist');
          }

          var val = Object.getOwnPropertyDescriptor(provider, from);
          if (val) Object.defineProperty(receiver, to, val);
        };

        function isObject(val) {
          return {}.toString.call(val) === "[object Object]";
        }
      },
      {},
    ],
    25: [
      function (require, module, exports) {
        /*!
         * create-frame <https://github.com/jonschlinkert/create-frame>
         *
         * Copyright (c) 2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        var utils = require("./utils");

        module.exports = function createFrame(data) {
          if (!utils.isObject(data)) {
            throw new TypeError("createFrame expects data to be an object");
          }

          var extend = utils.extend;
          var frame = extend({}, data);
          frame._parent = data;

          utils.define(frame, "extend", function (data) {
            extend(this, data);
          });

          if (arguments.length > 1) {
            var args = [].slice.call(arguments, 1);
            var len = args.length,
              i = -1;
            while (++i < len) {
              frame.extend(args[i] || {});
            }
          }
          return frame;
        };
      },
      { "./utils": 33 },
    ],
    26: [
      function (require, module, exports) {
        arguments[4][15][0].apply(exports, arguments);
      },
      { dup: 15, "is-descriptor": 31 },
    ],
    27: [
      function (require, module, exports) {
        arguments[4][16][0].apply(exports, arguments);
      },
      { dup: 16, "kind-of": 28 },
    ],
    28: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    29: [
      function (require, module, exports) {
        arguments[4][18][0].apply(exports, arguments);
      },
      { dup: 18, "kind-of": 30 },
    ],
    30: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    31: [
      function (require, module, exports) {
        arguments[4][20][0].apply(exports, arguments);
      },
      {
        dup: 20,
        "is-accessor-descriptor": 27,
        "is-data-descriptor": 29,
        "kind-of": 32,
      },
    ],
    32: [
      function (require, module, exports) {
        arguments[4][5][0].apply(exports, arguments);
      },
      { dup: 5 },
    ],
    33: [
      function (require, module, exports) {
        "use strict";

        var utils = require("lazy-cache")(require);
        var fn = require;
        require = utils;

        /**
         * Lazily required module dependencies
         */

        require("define-property", "define");
        require("extend-shallow", "extend");
        require("isobject", "isObject");
        require = fn;

        /**
         * Expose `utils` modules
         */

        module.exports = utils;
      },
      {
        "define-property": 26,
        "extend-shallow": 61,
        isobject: 131,
        "lazy-cache": 133,
      },
    ],
    34: [
      function (require, module, exports) {
        /**
         * Expose `Date`
         */

        module.exports = require("./lib/parser");
      },
      { "./lib/parser": 38 },
    ],
    35: [
      function (require, module, exports) {
        /**
         * Module Dependencies
         */

        var debug = require("debug")("date:date");

        /**
         * Time constants
         */

        var _second = 1000;
        var _minute = 60 * _second;
        var _hour = 60 * _minute;
        var _day = 24 * _hour;
        var _week = 7 * _day;
        var _year = 56 * _week;
        var _daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

        /**
         * Expose `date`
         */

        module.exports = date;

        /**
         * Initialize `date`
         *
         * @param {Date} offset (optional)
         * @return {Date}
         * @api publics
         */

        function date(offset) {
          if (!(this instanceof date)) return new date(offset);
          this._changed = {};
          this.date = new Date(offset);
        }

        /**
         * Clone the current date
         */

        date.prototype.clone = function () {
          return new Date(this.date);
        };

        /**
         * Has changed
         *
         * @param {String} str
         * @return {Boolean}
         */

        date.prototype.changed = function (str) {
          if (this._changed[str] === undefined) return false;
          return this._changed[str];
        };

        /**
         * add or subtract seconds
         *
         * @param {Number} n
         * @return {date}
         */

        date.prototype.second = function (n) {
          var seconds = +n * _second;
          this.update(seconds);
          this._changed["seconds"] = true;
          return this;
        };

        /**
         * add or subtract minutes
         *
         * @param {Number} n
         * @return {date}
         */

        date.prototype.minute = function (n) {
          var minutes = +n * _minute;
          this.update(minutes);
          this._changed["minutes"] = true;
          return this;
        };

        /**
         * add or subtract hours
         *
         * @param {Number} n
         * @return {date}
         */

        date.prototype.hour = function (n) {
          var hours = +n * _hour;
          this.update(hours);
          this._changed["hours"] = true;
          return this;
        };

        /**
         * add or subtract days
         *
         * @param {Number} n
         * @return {date}
         */

        date.prototype.day = function (n) {
          var days = +n * _day;
          this.update(days);
          this._changed["days"] = true;
          return this;
        };

        /**
         * add or subtract weeks
         *
         * @param {Number} n
         * @return {date}
         */

        date.prototype.week = function (n) {
          var weeks = +n * _week;
          this.update(weeks);
          this._changed["weeks"] = true;
          return this;
        };

        /**
         * add or subtract months
         *
         * @param {Number} n
         * @return {Date}
         */

        date.prototype.month = function (n) {
          var d = this.date;
          var day = d.getDate();
          d.setDate(1);
          var month = +n + d.getMonth();
          d.setMonth(month);

          // Handle dates with less days
          var dim = this.daysInMonth(month);
          d.setDate(Math.min(dim, day));
          return this;
        };

        /**
         * get the days in the month
         */

        date.prototype.daysInMonth = function (m) {
          var dim = _daysInMonth[m];
          var leap = leapyear(this.date.getFullYear());
          return 1 == m && leap ? 29 : 28;
        };

        /**
         * add or subtract years
         *
         * @param {Number} n
         * @return {date}
         */

        date.prototype.year = function (n) {
          var yr = this.date.getFullYear();
          yr += +n;
          this.date.setFullYear(yr);
          this._changed["years"] = true;
          return this;
        };

        /**
         * Set the time
         *
         * @param {String} h
         * @param {String} m
         * @param {String} s
         * @return {date}
         */

        date.prototype.time = function (h, m, s, meridiem) {
          if (h === false) {
            h = this.date.getHours();
          } else {
            h = +h || 0;
            this._changed["hours"] = h;
          }

          if (m === false) {
            m = this.date.getMinutes();
          } else {
            m = +m || 0;
            this._changed["minutes"] = m;
          }

          if (s === false) {
            s = this.date.getSeconds();
          } else {
            s = +s || 0;
            this._changed["seconds"] = s;
          }

          this.date.setHours(h, m, s);
          return this;
        };

        /**
         * Dynamically create day functions (sunday(n), monday(n), etc.)
         */

        var days = [
          "sunday",
          "monday",
          "tuesday",
          "wednesday",
          "thursday",
          "friday",
          "saturday",
        ];
        days.forEach(function (day, i) {
          date.prototype[days[i]] = function (n) {
            this._changed["days"] = true;
            this.updateDay(i, n);
          };
        });

        /**
         * go to day of week
         *
         * @param {Number} day
         * @param {Number} n
         * @return {date}
         */

        date.prototype.updateDay = function (d, n) {
          n = +(n || 1);
          var diff = (d - this.date.getDay() + 7) % 7;
          if (n > 0) --n;
          diff += 7 * n;
          this.update(diff * _day);
          return this;
        };

        /**
         * Update the date
         *
         * @param {Number} ms
         * @return {Date}
         * @api private
         */

        date.prototype.update = function (ms) {
          this.date = new Date(this.date.getTime() + ms);
          return this;
        };

        /**
         * leap year
         *
         * @param {Number} yr
         * @return {Boolean}
         */

        function leapyear(yr) {
          return (yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0;
        }
      },
      { debug: 43 },
    ],
    36: [
      function (require, module, exports) {
        module.exports = {
          op: {
            plus: ["and", "plus", "+", "add", "on"],
            minus: ["minus", "subtract"],
            times: ["times", "multiply"],
            divide: ["divide"],
          },
          o: {
            plus: [
              "at",
              "in",
              "past",
              "late",
              "later",
              "after",
              "next",
              "from",
              "start",
              "starting",
              "since",
              "coming",
            ],
            minus: ["last", "minus", "subtract", "ago", "before", "from"],
          },
          n: {
            0.25: ["quarter"],
            0.5: ["half", "1/2", "half an"],
            0: ["zero"],
            1: ["one", "a", "an", "first"],
            2: ["two", "second"],
            3: ["three", "third"],
            4: ["four", "fourth"],
            5: ["five", "fifth"],
            6: ["six", "sixth"],
            7: ["seven", "seventh"],
            8: ["eight", "eighth"],
            9: ["nine", "ninth"],
            10: ["ten", "tenth"],
            11: ["eleven", "eleventh"],
            12: ["twelve", "twelveth"],
            13: ["thirteen", "thirteenth"],
            14: ["fourteen", "fourteenth"],
            15: ["fifteen", "fifteenth"],
            16: ["sixteen", "sixteenth"],
            17: ["seventeen", "seventeenth"],
            18: ["eighteen", "eighteenth"],
            19: ["nineteen", "nineteenth"],
            20: ["twenty", "twentieth"],
            30: ["thirty", "thirtieth"],
            40: ["fourty", "fourtieth"],
            50: ["fifty", "fiftieth"],
            60: ["sixty", "sixtieth"],
            70: ["seventy", "seventieth"],
            80: ["eighty", "eightieth"],
            90: ["ninety", "ninetieth"],
            100: ["hundred", "hundreds", "hundredth"],
            1000: ["thousand", "thousands", "thousandth", "k", "K"],
          },
          t: {},
          dt: {
            s: ["second", "seconds", "s", "sec", "secs"],
            m: ["minute", "minutes", "m", "min", "mins"],
            h: ["hour", "hours", "h", "hr", "hrs"],
            d: ["day", "days", "d", "dai"],
            w: ["week", "weeks", "w", "wk", "wks"],
            M: ["month", "months", "monthes", "M", "mo", "moon", "moons"],
            y: ["year", "years", "y", "yr", "yrs"],
          },
          T: {
            "t:,dt:=3h": ["later", "soon"],
            "t:=1d,dt:": [
              "st",
              "nd",
              "rd",
              "th",
              "st day",
              "nd day",
              "rd day",
              "th day",
            ],
            "t:,dt:1w": ["st week", "nd week", "rd week", "th week"],
            "t:,dt:14d": ["day", "fortnight"],
            "t:=0h=0m=0s1mer,dt:": ["pm", "p.m", "p.m.", "noon"],
            "t:,dt:1d": ["tomorrow", "tmr"],
            "t:,dt:-1d": ["yesterday", "ytd"],
            "t:,0dt:": ["today"],
            "t:=2h=0m=0s1mer,dt:": ["afternoon"],
            "t:=6h=0m=0s0mer,dt:": ["dawn"],
            "t:=7h=0m=0s0mer,dt:": ["am", "a.m", "a.m."],
            "t:=7h=0m=0s1mer,dt:": ["evening"],
            "t:=8h=0m=0s0mer,dt:": ["morning"],
            "t:=9h=0m=0s1mer,dt:": ["tonight", "night"],
            "t:=0h=0m=0s0mer,dt:1d": ["midnight"],
            "t:,dt:=0w0wd": ["sunday", "sun"],
            "t:,dt:=0w1wd": ["monday", "mon"],
            "t:,dt:=0w2wd": ["tuesday", "tue", "tues"],
            "t:,dt:=0w3wd": ["wednesday", "wed"],
            "t:,dt:=0w4wd": ["thursday", "thu", "thur", "thurs"],
            "t:,dt:=0w5wd": ["friday", "fri"],
            "t:,dt:=0w6wd": ["saturday", "sat"],
            "t:1M=1d,dt:": ["january", "jan"],
            "t:2M=1d,dt:": ["february", "feb"],
            "t:3M=1d,dt:": ["march", "mar"],
            "t:4M=1d,dt:": ["april", "apr"],
            "t:5M=1d,dt:": ["may"],
            "t:6M=1d,dt:": ["june", "jun"],
            "t:7M=1d,dt:": ["july", "jul"],
            "t:8M=1d,dt:": ["august", "aug"],
            "t:9M=1d,dt:": ["september", "sept", "sep"],
            "t:10M=1d,dt:": ["october", "oct"],
            "t:11M=1d,dt:": ["november", "nov"],
            "t:12M=1d,dt:": ["december", "dec"],
            "t:12M25d,dt:": ["christmas"],
          },
          f: {
            1: ["once"],
            2: ["twice"],
          },
        };
      },
      {},
    ],
    37: [
      function (require, module, exports) {
        // Production rule module for the CFG
        // !leap year
        // !proper carry considering # of days per month

        /**
         * Module Dependencies
         */

        var _ = require("./subdash");
        var util = require("./util");
        var symbol = require("./symbol");
        var tokenize = require("./tokenize");

        /**
         * Export `norm`
         */

        module.exports = norm;

        // a partial implementation of norm
        /**
         * Preprocess a string using the human language for time CFG, return a triple of original str, preprocessed tokens, and the normal forms (extracted dates in normal forms)
         */
        function norm(str, offset) {
          try {
            // Production rules: CFG algorithm for human language for time
            var tokObj = tokenize(str);
            // console.log('p#0: parse normal forms', tokObj)
            var syms = pickTokens(tokObj.symbols) || [];
            // console.log('p#0: remove nulls, pick tokens', syms)
            syms = reduce(syms, ["n", "n"]);
            // console.log('p#1: arithmetics: <n1>[<op>]<n2> ~ <n>, + if n1 > n2, * else', syms)
            syms = nTnRedistribute(syms);
            // console.log('p#2: redistribute, <n1><T1>[<op>]<n2><!T2> ~ <n1>[<op>]<n2> <T1>', syms)
            syms = reduce(syms, ["o", "o"]);
            // console.log('p#3: <o><o> ~ <o>*<o>', syms)

            // preprocessing ends, now format output
            var restored = restoreTokens(syms, tokObj);
            return restored;
          } catch (e) {
            return {
              str: str,
              tokens: [],
              normals: [],
            };
          }
        }

        /**
         * format a preprocessed array of symbols back into string, using some info from tokObj
         */
        function restoreTokens(syms, tokObj) {
          var tokens = [],
            normals = [],
            tokensOut = tokObj.tokensOut,
            tokensIn = tokObj.tokensIn;

          syms = util.removeTnPlus(syms);
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i],
              sName = util.sName(s),
              token = "";
            switch (sName) {
              case "n":
                // if token is already numeric, use it
                token = s.token.match(/^\s*[\d\.\-\+]+\s*$/)
                  ? s.token.trim()
                  : s.value.toString();
                break;
              case "T":
                // handles shits like 1 am ~ t:1h00m,dt:, am (token returned)
                token = restoreNormal(s);
                break;
              default:
                // the other cases like op, o, cron, range
                token = s.token.toString();
            }

            // extract the protected normal string
            if (typeof token == "string") {
              tokens.push(token);
            } else {
              // get protected normal forms
              normals.push(token.normal);
            }
          }
          return {
            tokens: tokens,
            str: tokens.join(" ").replace(/\s+/g, " "),
            normals: normals,
          };
        }

        /**
         * Given a T symbol, try to restore its normal form (return wrapped in JSON if it's a complete date string {normal: <normal string>}), or just return the plain string as token
         */
        function restoreNormal(T) {
          var token = T.token;
          if (token.match(util.reT)) {
            // if it is normal form, convert back into the normal1 or normal2 strings
            var split = util.splitT(token);
            if (_.includes(split, undefined)) {
              // if it's normal2 form
              // either it's a date or time
              var dateArr = split.slice(0, 3),
                timeArr = split.slice(3);
              if (timeArr[0] != undefined) {
                // check time first, it's first signature (hour) is defined
                // return hh:mm
                return util.TtoStdT(token).match(/(\d+\:\d+)/)[1];
              } else {
                // else it's a date, parse arr and return complete stdT instead
                // return wrapped in JSON if it's a complete date string
                return { normal: util.TtoStdT(token) };
              }
            } else {
              // if it's normal1 form, use TtoStd
              // return wrapped in JSON if it's a complete date string
              return { normal: util.TtoStdT(token) };
            }
          } else if (
            !util.has_t(T) &&
            util.has_dt(T) &&
            util.has_pureTimeUnit(T)
          ) {
            // handle pure dt: T that are purel displacement, e.g. week, fortnight
            var dtStr = "",
              units = _.keys(T.dt),
              dt = T.dt;
            // accumulate dtStr
            for (var i = 0; i < units.length; i++) {
              var u = units[i],
                kval = parseFloat(dt[u]),
                // set number has default, or is 0, 1
                numStr =
                  kval != dt[u] || kval == 0 || Math.abs(kval) == 1
                    ? ""
                    : dt[u].toString() + " ";

              // set canon from lemma only if it exists, and key is word, else use u
              var canon = u;
              if (T.canon != undefined) {
                // and if it's also a timeUnit
                canon = T.canon;
              } else {
                // get the lemma for u, its canon and key
                var lemma = util.lemma(u),
                  lemmaCanon = lemma.canon,
                  lemmaKey = lemma.value;
                if (lemmaKey && lemmaKey.match(/^\w+$/)) {
                  canon = lemmaCanon;
                }
              }
              // set the units, number, and canonical form of the unit
              dtStr = dtStr + numStr + canon + " ";
            }
            return dtStr;
          } else {
            // else it's just plain english, return
            return token;
          }
        }
        // var fakes = { t: { h: '1', m: '00' }, dt: {}, token: 't:1h00m,dt:' }
        // var fakes = { t: { M: '12', d: '25', m: '00' }, dt: {}, token: 't:12M25d00m,dt:' }
        // console.log(restoreNormal(fakes))

        /**
         * !Backburner for future extension: Main method: Run the CFG algorithm to parse the string, return JSON of {input, output, diffStr}. Normalize the string before Matt's algorithm runs it.
         * @example
         * var str = 'having lunch today at 3 hours after 9am'
         * norm(str)
         * // => { input: 'having lunch today at 3 hours after 9am',
         *  output: '2016-03-04T05:00:09Z',
         *  difference: 'having lunch' }
         */
        function CFGproduce(str, offset) {
          // try all the below till all is elegantly fixed
          var diffStr = str,
            finalStr = null,
            output = str;
          // Production rules: CFG algorithm for human language for time
          // p#0: tokenize, remove nulls, pick tokens
          var tokObj = tokenize(str);
          var syms = pickTokens(tokObj.symbols);
          // console.log('p#0: parse normal forms, remove nulls, pick tokens', tokObj)

          try {
            syms = reduce(syms, ["n", "n"]);
            // console.log('p#1: arithmetics: <n1>[<op>]<n2> ~ <n>, + if n1 > n2, * else', syms)
            syms = nTnRedistribute(syms);
            // console.log('p#2: redistribute, <n1><T1>[<op>]<n2><!T2> ~ <n1>[<op>]<n2> <T1>', syms)
            output = util.tokenToStr(syms);

            // !okay replace back the normal forms in the str

            // // !Till future completion: Mute from below
            // syms = reduce(syms, ['n', 'T'])
            // // console.log('p#3: <n>[<op>]<T> ~ <T>, * if dt, + if t', syms)
            // syms = reduce(syms, ['T', 'T'])
            // // console.log('p#4: <T>[<op>]<T> ~ <T>', syms)
            // syms = nDefTSyms(syms)
            // // console.log('p#5: defaulter <o> <n> <o> ~ <o> <T> <o>, d defaults to t:h', syms)
            // syms = reduce(syms, ['o', 'o'])
            // // console.log('p#6: <o><o> ~ <o>*<o>', syms)
            // syms = autoHourModding(syms)
            // syms = weekModding(syms, offset)
            // // console.log('p#7: modding: meridiem, weeks', syms)
            // syms = optReduce(syms, ['T', 'T'], ['o'], null, symbol(util.nowT(offset)))
            // // console.log('p#8: <T><o><T> ~ <T>', syms)

            // // !future:
            // // syms = reduce(syms, ['T'], ['r'])
            // // syms = reduce(syms, ['f', 'T', 'rT'], ['c'])

            // console.log('tokObj', tokObj)
            syms = finalizeT(syms, offset);
            // console.log('p#9: finalizeT with origin', syms)

            finalStr = symsToStdT(syms, offset);
            // console.log('finalStr', finalStr)
          } catch (e) {}
          // extract the tokens for difference string later
          // diffStr = util.unparsedStr(tokObj.str, tokObj.symbols)
          // console.log('diffStr', diffStr)
          // !convert dt into proper terms

          return {
            input: str,
            // output: new Date(finalStr),
            output: output,
            difference: diffStr,
          };
        }

        /**
         * Production rule #0: pick tokens, remove nulls.
         * 1. break into chunks of arrs delimited by triple-null-or-more
         * 2. reorder chunks by arr length
         * 3.1 init candidate = []
         * 3.2 pull and push the chunks not containing <T> into candidate
         * 3.3 pull and push the chunks containing <T> into candidate
         * 4. pick the last candidate
         */
        function pickTokens(syms) {
          // 1. 2. 3.
          var delimited = util.delimSyms(syms),
            chunks = util.splitSyms(delimited, "trinull"),
            candidates = util.orderChunks(chunks);
          // 4.
          return candidates.pop();
        }

        /**
         * Reduce an array of symbols with binary operations between permissible symbols.
         * @param  {Array} syms   Array of input symbols
         * @param  {Array} varArr String names of permissible variables.
         * @param  {Array} opArr  String names of permissible operations.
         * @return {Array}        The reduced result.
         */
        function reduce(syms, varArr, opArr) {
          if (syms.length < 2) {
            return syms;
          }
          // the operator arrays
          var opArr = opArr || ["op"];
          // endmark for handling last symbol
          syms.push("null");
          // the result, past-pointer(previous non-null symbol), default-op, current-op, and whether current-op is inter-symbol op, i.e. will not be used up
          var res = [],
            past = null,
            defOp = null,
            op = defOp,
            interOp = false;
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i];
            if (!past || !s) {
              // edge case or null
              if (i == 0) {
                past = s;
              }
            } else if (util.isSym(s, opArr)) {
              // s is an op. mark op as won't be used yet
              op = s;
              interOp = true;
              // the nDefT for when past = 'n', s = 'o'
            } else if (
              util.isSym(past, [varArr[0]]) &&
              util.isSym(s, [varArr[1]])
            ) {
              // s and past are operable variables specified by varArr
              past = execOp(past, op, s);
              // reset after op is used
              op = defOp;
              interOp = false;
            } else {
              // no further legal operation made, push and continue
              // change of class, past is finalized, push to res
              res.push(past);
              if (Array.isArray(past)) {
                // if past was returned from execOp as array (not executed), then flatten it and dont push op to res, since it's already included in op
                res = _.flatten(res);
              } else {
                // if inter-op (not used), push a clone (prevent overwrite later)
                if (interOp) {
                  res.push(symbol(op.value));
                }
              }
              // reset
              op = defOp;
              interOp = false;
              past = s;
            }
          }
          return res;
        }

        /**
         * Optional reduce: similar to reduce() but either argument is optional.
         * algorithm: return a T
         * 1. for each t, dt, do:
         * 2. for each key in union of keys for Lt, Rt, do:
         * 3. _Rt = _Rt op _Lt
         * @param  {Array} syms   Array of input symbols
         * @param  {Array} varArr String names of permissible variables.
         * @param  {Array} opArr  String names of permissible operations.
         * @param  {symbol} Ldef   default for left argument
         * @param  {symbol} Rdef   default for right argument
         * @return {Array}        The reduced result.
         */
        function optReduce(syms, varArr, opArr, Ldef, Rdef) {
          if (syms.length < 2) {
            return syms;
          }
          // use peek
          var res = [],
            sum = null,
            L = null,
            R = null;
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i];
            if (util.isSym(s, opArr)) {
              if (sum == null) {
                L = syms[i - 1];
                sum = util.isSym(L, [varArr[0]]) ? L : Ldef;
              }
              R = syms[i + 1];
              // if is var skip it since will be consumed
              if (util.isSym(R, [varArr[1]])) {
                i++;
              }
              // else reset to default
              else {
                R = Rdef;
              }
              // compute:
              sum = execOp(sum, s, R);
              // before loop quits due to possible i++, push the last
              if (i == syms.length - 1) {
                res.push(sum);
              }
            } else {
              // s is not opArr, can't have been varArr either
              // edge case: at first dont push
              if (i > 0) {
                res.push(sum);
                res.push(s);
                sum = null;
              }
            }
          }
          return res;
        }

        /**
         * Execute non-commutative operation between 2 argument symbols and an op symbol; carry out respective ops according to symbol names.
         * @param  {symbol} L  Left argument
         * @param  {symbol} op operation
         * @param  {symbol} R  Right argument
         * @param  {str} offset The time origin offset
         * @return {symbol}    Result
         */
        function execOp(L, op, R, offset) {
          var otype = util.opType(L, op, R),
            res = null;
          if (_.includes(["nn"], otype)) {
            res = nnOp(L, op, R);
          } else if (_.includes(["nT"], otype)) {
            res = nTOp(L, op, R);
          } else if (_.includes(["TT"], otype)) {
            res = TTOp(L, op, R);
          } else if (_.includes(["ToT", "oT", "To"], otype)) {
            res = ToTOp(L, op, R, offset);
          } else if (_.includes(["oo"], otype)) {
            res = ooOp(L, R);
          } else if (_.includes(["rT", "TrT"], otype)) {
            // has optional arg
            res = rTOp(L, R);
          } else if (_.includes(["cT", "fcT", "crT", "fcrT"], otype)) {
            // has optional arg
            res = cTOp(L, R);
          } else {
            // not executable, e.g. not in the right order, return fully
            res = op == null ? [L, R] : [L, op, R];
          }
          return res;
        }

        /**
         * Atomic binary arithmetic operation on the numerical level, with default overriding the argument prepended with '='.
         * @param  {string|Number} Lval The left argument value.
         * @param  {symbol} op   The op symbol
         * @param  {string|Number} Rval The right argument value.
         * @return {Number}      Result from the operation.
         */
        function atomicOp(Lval, op, Rval, dontOp) {
          dontOp = dontOp || false;
          var oName = op.value;
          if (Lval == undefined) {
            // if L is missing, R must exist tho
            return oName == "minus"
              ? Rval.toString().replace(/(\d)/, "-$1")
              : Rval;
          } else if (Rval == undefined) {
            // if L exists, be it def or not, R missing
            return Lval;
          } else {
            // or R exist or is default (parse to NaN), L can be default too but ignore then
            var defL = Lval.toString().match(/^=/),
              defR = Rval.toString().match(/^=/);
            var l = parseFloat(Lval.toString().replace(/^=/, "")),
              r = parseFloat(Rval.toString().replace(/^=/, ""));
            if (defL && defR) {
              // if both are default, return r 'last come last serve'
              return r;
            } else if (defL && !defR) {
              // if either default, return the non-default
              return r;
            } else if (!defL && defR) {
              return l;
            } else {
              // none default
              if (dontOp) {
                // if is a don't operate together, i.e. for t, just return l
                // 'first come first serve'
                return l;
              } else {
                // make the into proper floats first
                if (oName == "minus") {
                  return l - r;
                } else if (oName == "plus") {
                  return l + r;
                } else if (oName == "times") {
                  return l * r;
                } else if (oName == "divide") {
                  return l / r;
                }
              }
            }
          }
        }

        /**
         * p#1: arithmetics: <n1>[<op>]<n2> ~ <n>, + if n1 > n2, * else
         */
        function nnOp(L, op, R) {
          var l = L.value,
            r = R.value;
          // set the default op according to value in nn op
          if (l > r) {
            op = op || symbol("plus");
          } else {
            op = op || symbol("times");
          }
          var res = atomicOp(l, op, r);
          return symbol(res);
        }

        /**
         * p#2: redistribute, <n1><T1>[<op>]<n2><!T2> ~ <n1>[<op>]<n2> <T1>
         * algorithm: note that from previous steps no <n>'s can occur adjacently
         * 1. scan array L to R, on each <n> found:
         * 2.1 if its R is <T>, continue
         * 2.2 else, this is the target. do:
         * 3.1 init carry = []. remove and push <n> into carry,
         * 3.2 if its L is <op>, remove and prepend <op> into carry,
         * 4.1 find the first <n> to the left, if not <n>, drop the carry and continue
         * 4.2 else merge the carry after the <n>
         * 5. At the end of loop, rerun production rule #1
         */
        function nTnRedistribute(syms) {
          if (syms.length < 2) {
            return syms;
          }
          // 1.
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i];
            if (util.sName(s) != "n") {
              continue;
            }
            // 1.

            var R = syms[i + 1];
            if (util.sName(R) == "T") {
              continue;
            }
            // 2.2

            // 3.1 prepare the carry
            var carry = [];
            // 3.2 the Left symbol
            var L = syms[i - 1],
              Li = -1;
            if (util.sName(L) == "op") {
              // if L is an 'op', remember to pull it later
              Li = i - 1;
            }
            // 4.1
            // find L...L of L that is 'n'
            var LLi = _.findLastIndex(syms.slice(0, i - 1), function (Ls) {
              return util.sName(Ls) == "n";
            });
            if (!syms[LLi] || util.sName(syms[LLi + 1]) != "T") {
              // if can't find 'n' (index = -1), or the R of 'n' isn't T, abort mission
              // syms.splice(i, 0, carry)
            } else {
              // 4.2
              // else, pull s at [i], optional L at [Li], and push at LLi+1
              carry.push(_.pullAt(syms, i)[0]);
              if (Li != -1) {
                carry.unshift(_.pullAt(syms, Li)[0]);
              }
              syms.splice(LLi + 1, 0, carry);
              syms = _.flatten(syms);
            }
          }

          // 5. redo the <n><n> op
          syms = reduce(syms, ["n", "n"]);
          return syms;
        }

        /**
         * p#3: <n>[<op>]<T> ~ <T>, * if dt, + if t
         * 1. if t can be overidden, start from the highest unit set to n, then return.
         * 2. otherwise, if <dt> not empty, <n><dt> = <n>*<dt>, then return
         * 3. else, if <t> not empty, <n><t> = <n>+<t>, then return
         */
        function nTOp(nL, op, TR) {
          var tOverrideUnit = util.highestOverride(TR.t);
          if (tOverrideUnit) {
            // 1.
            TR.t[tOverrideUnit] = nL.value;
          } else if (_.keys(TR.dt).length) {
            // 2.
            op = op || symbol("times");
            for (var k in TR.dt) {
              if (k == "wd") {
                continue;
              }
              TR.dt[k] = atomicOp(nL.value, op, TR.dt[k]);
            }
          } else if (_.keys(TR.t).length) {
            // 3.
            op = op || symbol("plus");
            for (var k in TR.t) {
              TR.t[k] = atomicOp(nL.value, op, TR.t[k]);
            }
          }
          return TR;
        }

        /**
         * p#4: <T>[<op>]<T> ~ <T>
         */
        function TTOp(TL, op, TR) {
          // set the default op
          op = op || symbol("plus");
          // util.sName
          // mutate into TL
          for (var k in TR.t) {
            // okay done add absolute time, just as you don't add origins together put u take gradual specificity, the 'true' param for dontOp if exist, return r
            // override default tho, taken care of by atomic
            TL.t[k] = atomicOp(TL.t[k], op, TR.t[k], true);
          }
          for (var k in TR.dt) {
            if (k == "wd") {
              continue;
            }
            TL.dt[k] = atomicOp(TL.dt[k], op, TR.dt[k]);
          }
          return TL;
        }

        /**
         * p#5: defaulter <o> <n> <o> ~ <o> <T> <o>, d defaults to t:h
         */
        function nDefTSyms(syms) {
          var res = [];
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i];
            res.push(util.isSym(s, ["n"]) ? nDefT(s) : s);
          }
          return res;
        }

        /**
         * Helper: default a singlet n to T, i.e. next available hour
         */
        function nDefT(n) {
          var deft = symbol("t:1h,dt:");
          var nVal = n.value;
          var currentHour = new Date().getHours();
          var nextnVal = Math.floor(currentHour / 12) * 12 + nVal;
          var tHour = execOp(symbol(nextnVal), symbol("times"), deft);
          return tHour;
        }

        /**
         * <o><o> ~ <o>*<o>
         * To handle 'before next' etc.
         */
        function ooOp(L, R) {
          var Lsign = L.value == "plus" ? +1 : -1,
            Rsign = R.value == "plus" ? +1 : -1,
            LRsign = Lsign * Rsign;
          return LRsign > 0 ? symbol("after") : symbol("before");
        }

        /**
         * Next available T', given an offset, by incrementing in dt the next unit ++1 from the current largest unit in t.
         */
        function nextAvailable(T, offset) {
          // find the current largest and next largest unit
          var nextUnit = util.nextLargestUnit(T);

          // first finalized T
          var finT1 = finalizeT([T], offset)[0],
            stdStr1 = util.TtoStdT(finT1),
            UTC1 = Date.parse(stdStr1),
            UTCnow = Date.parse(new Date()),
            UTCdiff = UTC1 - UTCnow;
          // if UTC1 is not in the future, add next unit
          if (UTCdiff < 0) {
            T.dt[nextUnit] = (T.dt[nextUnit] || 0) + 1;
            var finT2 = finalizeT([T], offset)[0];
            return finT2;
          } else {
            return finT1;
          }
        }

        /**
         * p#6: <T><o><T> ~ <T>
         */
        function ToTOp(L, op, R, offset) {
          if (L && !R) {
            // if R is missing, set to now
            R = symbol(util.nowT(offset));
          } else if (!L && R) {
            // if L missing
            if (util.has_t(R)) {
              // if R has t => part of origin, so L shd be the according dt
              var nextUnit = util.nextLargestUnit(R);
              R = nextAvailable(R, offset);
              // so arbitrarily set as 0.5 * next largest unit
              L = execOp(symbol(0.5), symbol("times"), symbol(nextUnit));
            } else {
              // R has dt only, make L an origin then
              L = symbol(util.nowT(offset));
            }
          } else if (!L && !R) {
            L = symbol(util.nowT(offset));
            R = symbol(util.nowT(offset));
          }

          var Ttype = ["t", "dt"];
          for (var i = 0; i < Ttype.length; i++) {
            var _Ttype = Ttype[i],
              // the dontOp for 't'
              dontOp = _Ttype == "t";
            var concatKeys = _.keys(L[_Ttype]).concat(_.keys(R[_Ttype]));
            var keys = _.unique(concatKeys);
            for (var j = 0; j < keys.length; j++) {
              var k = keys[j];
              // run atomic op, note the reversed order of R op L
              R[_Ttype][k] = atomicOp(R[_Ttype][k], op, L[_Ttype][k], dontOp);
            }
          }
          return R;
        }

        /**
         * p#7: auto-hour-modding: t:h mod 12
         * then add the meridiem to t:h if exist
         */
        function autoHourModding(syms) {
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i];
            if (util.isSym(s, ["T"])) {
              if (syms[i]["t"]["h"]) {
                // if t has 'h', mod it
                var value = syms[i]["t"]["h"].toString();
                var isDefault = (value.match(/^=/) || [])[0] || "";
                value = parseFloat(value.replace(/^=/, ""));
                value = value > 12 ? value % 12 : value;
                syms[i]["t"]["h"] = isDefault + value;
              }
              // apply the non-0 meridiem after modding:
              if (syms[i]["t"]["mer"]) {
                var dt_h = (syms[i]["dt"]["h"] || "0").toString();
                // dump default at last
                dt_h = dt_h.replace(/^=/, "");
                if (syms[i]["t"]["mer"] == 1) {
                  syms[i]["dt"]["h"] = parseFloat(dt_h) + 12;
                }
                // delete mer
                delete syms[i]["t"]["mer"];
              }
            }
          }
          return syms;
        }

        // do it at last, to use like '2nd week of march'
        function weekModding(syms, offset) {
          // weekday of the offset to calculate dt:d
          var offsetWD = new Date(util.TtoStdT(util.nowT())).getDay();
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i];
            if (util.isSym(s, ["T"])) {
              if (syms[i]["dt"]["wd"]) {
                // if dt has 'wd', mod it and turn into dt:d + %wd
                var WD = parseInt(syms[i]["dt"]["wd"]);
                var diffWD = (WD - offsetWD) % 7;
                if (diffWD < 0) {
                  diffWD = diffWD + 7;
                }
                syms[i]["dt"]["d"] = (syms[i]["dt"]["d"] || 0) + diffWD;
                delete syms[i]["dt"]["wd"];
              }
            }
          }
          return syms;
        }

        /**
         * p#8: Finalize each T in syms array:
         * 1. remove defaults from T
         * 2. add origin symbol.nowT() with given T.t, override missing units
         * 3. add t and dt
         */
        function finalizeT(syms, offset) {
          // remove defaults
          for (var i = 0; i < syms.length; i++) {
            syms[i] = removeDefaults(syms[i]);
          }
          // default with origin at end
          syms.push(symbol(util.nowT(offset)));
          syms = reduce(syms, ["T", "T"]);
          // combine t and dt
          var newSyms = [];
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i],
              sum = tdtAdd(s);
            sum.token = util.TtoStr(sum);
            newSyms.push(tdtAdd(s));
          }
          return syms;
        }

        /**
         * remove the defaults before adding with origin
         */
        function removeDefaults(T) {
          for (var k in T.dt) {
            T.dt[k] = T.dt[k].toString().replace(/^=/, "");
          }
          for (var k in T.t) {
            T.t[k] = T.t[k].toString().replace(/^=/, "");
          }
          // delete meridiem too
          delete T["t"]["mer"];

          return T;
        }

        /**
         * add t and dt within a T together, delete the dt keys
         */
        function tdtAdd(T) {
          // guard for non-T
          if (!util.isSym(T, ["T"])) {
            return T;
          }
          for (var k in T.dt) {
            // absolute add, disregard defaults
            var t_k = T.t[k] == undefined ? 0 : T.t[k],
              dt_k = T.dt[k];
            // cleanup the default
            t_k = t_k.toString().replace(/^=/, "");
            dt_k = dt_k.toString().replace(/^=/, "");
            var sum = parseFloat(t_k) + parseFloat(dt_k);
            // set the result, remove used dt
            T.t[k] = sum;
            delete T.dt[k];
          }
          return T;
        }

        /**
         * p#9: Convert an array of symbols to normalized stdT strings.
         * if token was normal form already, parse into stdT.
         * if is n: return n.value
         * else return org token
         */
        function symsToStdT(syms, offset) {
          var tokens = [];
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i],
              token = s.token.toString();
            // default, don't switch unless:
            if (util.isSym(s, ["n"])) {
              token = s.value;
            } else if (token.match(util.reT)) {
              // is normal T form
              token = util.TtoStdT(token, offset);
            }
            tokens.push(token);
          }
          return tokens.join(" ");
        }

        /**
         * !to be implemented for range
         */
        function rTOp(L, R) {
          var start, end;
          if (!R) {
            start = symbol(util.nowT());
            end = L;
          } else {
            start = L;
            end = R;
          }
          return symbol({ start: start, end: end });
        }

        /**
         * !to be implemented for cron
         */
        function cTOp(L, R) {}
      },
      { "./subdash": 39, "./symbol": 40, "./tokenize": 41, "./util": 42 },
    ],
    38: [
      function (require, module, exports) {
        /**
         * Module Dependencies
         */

        var debug = require("debug")("date:parser");
        var date = require("./date");
        var norm = require("./norm");

        /**
         * Days
         */

        var days = [
          "sunday",
          "monday",
          "tuesday",
          "wednesday",
          "thursday",
          "friday",
          "saturday",
        ];
        var months = [
          "january",
          "february",
          "march",
          "april",
          "may",
          "june",
          "july",
          "august",
          "september",
          "october",
          "november",
          "december",
        ];

        /**
         * Regexs
         */

        // 5, 05, 5:30, 5.30, 05:30:10, 05:30.10, 05.30.10, at 5
        var rMeridiem = /^(\d{1,2})([:.](\d{1,2}))?([:.](\d{1,2}))?\s*([ap]m)/;
        var rHourMinute = /^(\d{1,2})([:.](\d{1,2}))([:.](\d{1,2}))?/;
        var rAtHour = /^at\s?(\d{1,2})$/;
        var rDays =
          /\b(sun(day)?|mon(day)?|tues(day)?|wed(nesday)?|thur(sday|s)?|fri(day)?|sat(urday)?)s?\b/;
        var rMonths =
          /^((\d{1,2})\s*(st|nd|rd|th))\s(day\s)?(of\s)?(january|february|march|april|may|june|july|august|september|october|november|december)/i;
        var rPast = /\b(last|yesterday|ago)\b/;
        var rDayMod = /\b(morning|noon|afternoon|night|evening|midnight)\b/;
        var rAgo =
          /^(\d*)\s?\b(second|minute|hour|day|week|month|year)[s]?\b\s?ago$/;

        /**
         * Expose `parser`
         */

        module.exports = parser;

        /**
         * Initialize `parser`
         *
         * @param {String} str
         * @return {Date}
         * @api publics
         */

        function parser(str, offset) {
          if (!(this instanceof parser)) return new parser(str, offset);
          if (typeof offset == "string") offset = parser(offset);

          // CFG preprocessing into normalized format,
          // get {str, tokens, normals}
          // !future: return multiple parsed times, some from it
          var prepro = norm(str, offset);
          // console.log(prepro)
          // reset the str to prepro str
          str = prepro.str;
          // if proprocessed doesn't leave any str to be processed (non-date-time) format, check normals
          if (!str) {
            if (prepro.normals.length) {
              // if there's normal date parsed already,
              // !return the first
              return new Date(prepro.normals[0]);
            } else {
              // otherwise go back to below to return proper Error
              str = str;
            }
          }

          var d = offset || new Date();
          this.date = new date(d);
          this.original = str;
          this.str = str.toLowerCase();
          this.stash = [];
          this.tokens = [];
          while (this.advance() !== "eos") debug("tokens %j", this.tokens);
          this.nextTime(d);
          if (this.date.date == d) throw new Error("Invalid date");
          return this.date.date;
        }

        /**
         * Advance a token
         */

        parser.prototype.advance = function () {
          var tok =
            this.eos() ||
            this.space() ||
            this._next() ||
            this.last() ||
            this.dayByName() ||
            this.monthByName() ||
            this.timeAgo() ||
            this.ago() ||
            this.yesterday() ||
            this.tomorrow() ||
            this.noon() ||
            this.midnight() ||
            this.night() ||
            this.evening() ||
            this.afternoon() ||
            this.morning() ||
            this.tonight() ||
            this.meridiem() ||
            this.hourminute() ||
            this.athour() ||
            this.week() ||
            this.month() ||
            this.year() ||
            this.second() ||
            this.minute() ||
            this.hour() ||
            this.day() ||
            this.number() ||
            this.string() ||
            this.other();

          this.tokens.push(tok);
          return tok;
        };

        /**
         * Lookahead `n` tokens.
         *
         * @param {Number} n
         * @return {Object}
         * @api private
         */

        parser.prototype.lookahead = function (n) {
          var fetch = n - this.stash.length;
          if (fetch == 0) return this.lookahead(++n);
          while (fetch-- > 0) this.stash.push(this.advance());
          return this.stash[--n];
        };

        /**
         * Lookahead a single token.
         *
         * @return {Token}
         * @api private
         */

        parser.prototype.peek = function () {
          return this.lookahead(1);
        };

        /**
         * Fetch next token including those stashed by peek.
         *
         * @return {Token}
         * @api private
         */

        parser.prototype.next = function () {
          var tok = this.stashed() || this.advance();
          return tok;
        };

        /**
         * Return the next possibly stashed token.
         *
         * @return {Token}
         * @api private
         */

        parser.prototype.stashed = function () {
          var stashed = this.stash.shift();
          return stashed;
        };

        /**
         * Consume the given `len`.
         *
         * @param {Number|Array} len
         * @api private
         */

        parser.prototype.skip = function (len) {
          this.str = this.str.substr(Array.isArray(len) ? len[0].length : len);
        };

        /**
         * EOS
         */

        parser.prototype.eos = function () {
          if (this.str.length) return;
          return "eos";
        };

        /**
         * Space
         */

        parser.prototype.space = function () {
          var captures;
          if ((captures = /^([ \t]+)/.exec(this.str))) {
            this.skip(captures);
            return this.advance();
          }
        };

        /**
         * Second
         */

        parser.prototype.second = function () {
          var captures;
          if ((captures = /^s(ec|econd)?s?/.exec(this.str))) {
            this.skip(captures);
            return "second";
          }
        };

        /**
         * Minute
         */

        parser.prototype.minute = function () {
          var captures;
          if ((captures = /^m(in|inute)?s?/.exec(this.str))) {
            this.skip(captures);
            return "minute";
          }
        };

        /**
         * Hour
         */

        parser.prototype.hour = function () {
          var captures;
          if ((captures = /^h(r|our)s?/.exec(this.str))) {
            this.skip(captures);
            return "hour";
          }
        };

        /**
         * Day
         */

        parser.prototype.day = function () {
          var captures;
          if ((captures = /^d(ay)?s?/.exec(this.str))) {
            this.skip(captures);
            return "day";
          }
        };

        /**
         * Day by name
         */

        parser.prototype.dayByName = function () {
          var captures;
          var r = new RegExp("^" + rDays.source);
          if ((captures = r.exec(this.str))) {
            var day = captures[1];
            this.skip(captures);
            this.date[day](1);
            return captures[1];
          }
        };

        /**
         * Month by name
         */

        parser.prototype.monthByName = function () {
          var captures;
          if ((captures = rMonths.exec(this.str))) {
            var day = captures[2];
            var month = captures[6];
            this.date.date.setMonth(months.indexOf(month));
            if (day) this.date.date.setDate(parseInt(day));
            this.skip(captures);
            return captures[0];
          }
        };

        parser.prototype.timeAgo = function () {
          var captures;
          if ((captures = rAgo.exec(this.str))) {
            var num = captures[1];
            var mod = captures[2];
            this.date[mod](-num);
            this.skip(captures);
            return "timeAgo";
          }
        };

        /**
         * Week
         */

        parser.prototype.week = function () {
          var captures;
          if ((captures = /^w(k|eek)s?/.exec(this.str))) {
            this.skip(captures);
            return "week";
          }
        };

        /**
         * Month
         */

        parser.prototype.month = function () {
          var captures;
          if ((captures = /^mon(th)?(es|s)?\b/.exec(this.str))) {
            this.skip(captures);
            return "month";
          }
        };

        /**
         * Week
         */

        parser.prototype.year = function () {
          var captures;
          if ((captures = /^y(r|ear)s?/.exec(this.str))) {
            this.skip(captures);
            return "year";
          }
        };

        /**
         * Meridiem am/pm
         */

        parser.prototype.meridiem = function () {
          var captures;
          if ((captures = rMeridiem.exec(this.str))) {
            this.skip(captures);
            this.time(captures[1], captures[3], captures[5], captures[6]);
            return "meridiem";
          }
        };

        /**
         * Hour Minute (ex. 12:30)
         */

        parser.prototype.hourminute = function () {
          var captures;
          if ((captures = rHourMinute.exec(this.str))) {
            this.skip(captures);
            this.time(captures[1], captures[3], captures[5], this._meridiem);
            return "hourminute";
          }
        };

        /**
         * At Hour (ex. at 5)
         */

        parser.prototype.athour = function () {
          var captures;
          if ((captures = rAtHour.exec(this.str))) {
            this.skip(captures);
            this.time(captures[1], 0, 0, this._meridiem);
            this._meridiem = null;
            return "athour";
          }
        };

        /**
         * Time set helper
         */

        parser.prototype.time = function (h, m, s, meridiem) {
          var d = this.date;
          var before = d.clone();

          if (meridiem) {
            // convert to 24 hour
            h = "pm" == meridiem && 12 > h ? +h + 12 : h; // 6pm => 18
            h = "am" == meridiem && 12 == h ? 0 : h; // 12am => 0
          }

          m = !m && d.changed("minutes") ? false : m;
          s = !s && d.changed("seconds") ? false : s;
          d.time(h, m, s);
        };

        /**
         * Best attempt to pick the next time this date will occur
         *
         * TODO: place at the end of the parsing
         */

        parser.prototype.nextTime = function (before) {
          var d = this.date;
          var orig = this.original;

          if (before <= d.date || rPast.test(orig)) return this;

          // If time is in the past, we need to guess at the next time
          if (rDays.test(orig)) {
            d.day(7);
          } else if ((before - d.date) / 1000 > 60) {
            // If it is a month in the past, don't add a day
            if (rMonths.test(orig)) {
              d.day(0);
            } else {
              d.day(1);
            }
          }

          return this;
        };

        /**
         * Yesterday
         */

        parser.prototype.yesterday = function () {
          var captures;
          if ((captures = /^(yes(terday)?)/.exec(this.str))) {
            this.skip(captures);
            this.date.day(-1);
            return "yesterday";
          }
        };

        /**
         * Tomorrow
         */

        parser.prototype.tomorrow = function () {
          var captures;
          if ((captures = /^tom(orrow)?/.exec(this.str))) {
            this.skip(captures);
            this.date.day(1);
            return "tomorrow";
          }
        };

        /**
         * Noon
         */

        parser.prototype.noon = function () {
          var captures;
          if ((captures = /^noon\b/.exec(this.str))) {
            this.skip(captures);
            var before = this.date.clone();
            this.date.date.setHours(12, 0, 0);
            return "noon";
          }
        };

        /**
         * Midnight
         */

        parser.prototype.midnight = function () {
          var captures;
          if ((captures = /^midnight\b/.exec(this.str))) {
            this.skip(captures);
            var before = this.date.clone();
            this.date.date.setHours(0, 0, 0);
            return "midnight";
          }
        };

        /**
         * Night (arbitrarily set at 7pm)
         */

        parser.prototype.night = function () {
          var captures;
          if ((captures = /^night\b/.exec(this.str))) {
            this.skip(captures);
            this._meridiem = "pm";
            var before = this.date.clone();
            this.date.date.setHours(19, 0, 0);
            return "night";
          }
        };

        /**
         * Evening (arbitrarily set at 5pm)
         */

        parser.prototype.evening = function () {
          var captures;
          if ((captures = /^evening\b/.exec(this.str))) {
            this.skip(captures);
            this._meridiem = "pm";
            var before = this.date.clone();
            this.date.date.setHours(17, 0, 0);
            return "evening";
          }
        };

        /**
         * Afternoon (arbitrarily set at 2pm)
         */

        parser.prototype.afternoon = function () {
          var captures;
          if ((captures = /^afternoon\b/.exec(this.str))) {
            this.skip(captures);
            this._meridiem = "pm";
            var before = this.date.clone();

            if (this.date.changed("hours")) return "afternoon";

            this.date.date.setHours(14, 0, 0);
            return "afternoon";
          }
        };

        /**
         * Morning (arbitrarily set at 8am)
         */

        parser.prototype.morning = function () {
          var captures;
          if ((captures = /^morning\b/.exec(this.str))) {
            this.skip(captures);
            this._meridiem = "am";
            var before = this.date.clone();
            if (!this.date.changed("hours")) this.date.date.setHours(8, 0, 0);
            return "morning";
          }
        };

        /**
         * Tonight
         */

        parser.prototype.tonight = function () {
          var captures;
          if ((captures = /^tonight\b/.exec(this.str))) {
            this.skip(captures);
            this._meridiem = "pm";
            return "tonight";
          }
        };

        /**
         * Next time
         */

        parser.prototype._next = function () {
          var captures;
          if ((captures = /^next/.exec(this.str))) {
            this.skip(captures);
            var d = new Date(this.date.date);
            var mod = this.peek();

            // If we have a defined modifier, then update
            if (this.date[mod]) {
              this.next();
              // slight hack to modify already modified
              this.date = date(d);
              this.date[mod](1);
            } else if (rDayMod.test(mod)) {
              this.date.day(1);
            }

            return "next";
          }
        };

        /**
         * Last time
         */

        parser.prototype.last = function () {
          var captures;
          if ((captures = /^last/.exec(this.str))) {
            this.skip(captures);
            var d = new Date(this.date.date);
            var mod = this.peek();

            // If we have a defined modifier, then update
            if (this.date[mod]) {
              this.next();
              // slight hack to modify already modified
              this.date = date(d);
              this.date[mod](-1);
            } else if (rDayMod.test(mod)) {
              this.date.day(-1);
            }

            return "last";
          }
        };

        /**
         * Ago
         */

        parser.prototype.ago = function () {
          var captures;
          if ((captures = /^ago\b/.exec(this.str))) {
            this.skip(captures);
            return "ago";
          }
        };

        /**
         * Number
         */

        parser.prototype.number = function () {
          var captures;
          if ((captures = /^(\d+)/.exec(this.str))) {
            var n = captures[1];
            this.skip(captures);
            var mod = this.peek();

            // If we have a defined modifier, then update
            if (this.date[mod]) {
              if ("ago" == this.peek()) n = -n;
              this.date[mod](n);
            } else if (this._meridiem) {
              // when we don't have meridiem, possibly use context to guess
              this.time(n, 0, 0, this._meridiem);
              this._meridiem = null;
            } else if (this.original.indexOf("at") > -1) {
              this.time(n, 0, 0, this._meridiem);
              this._meridiem = null;
            }

            return "number";
          }
        };

        /**
         * String
         */

        parser.prototype.string = function () {
          var captures;
          if ((captures = /^\w+/.exec(this.str))) {
            this.skip(captures);
            return "string";
          }
        };

        /**
         * Other
         */

        parser.prototype.other = function () {
          var captures;
          if ((captures = /^./.exec(this.str))) {
            this.skip(captures);
            return "other";
          }
        };
      },
      { "./date": 35, "./norm": 37, debug: 43 },
    ],
    39: [
      function (require, module, exports) {
        /**
         * Substitutes for lodash methods
         */

        exports.difference = function (bigArr, smallArr) {
          var diff = [];
          for (var i = 0; i < bigArr.length; i++) {
            var ele = bigArr[i];
            if (smallArr.indexOf(ele) == -1) {
              diff.push(ele);
            }
          }
          return diff;
        };

        exports.flatten = function (arr) {
          return [].concat.apply([], arr);
        };

        exports.find = function (arr, fn) {
          var found = null;
          for (var i = 0; i < arr.length; i++) {
            if (fn(arr[i])) {
              found = arr[i];
              break;
            }
          }
          return found;
        };

        exports.findLastIndex = function (arr, fn) {
          var found = -1;
          for (var i = arr.length - 1; i >= 0; i--) {
            if (fn(arr[i])) {
              found = i;
              break;
            }
          }
          return found;
        };

        exports.includes = function (arr, item) {
          var found = false;
          for (var i = 0; i < arr.length; i++) {
            if (arr[i] === item) {
              found = true;
              break;
            }
          }
          return found;
        };

        exports.isNaN = function (n) {
          return Number.isNaN(n);
        };

        exports.keys = function (obj) {
          return Object.keys(obj);
        };

        exports.pullAt = function (arr, i) {
          var res = arr.splice(i, 1);
          return res;
        };

        exports.unique = function (arr, i) {
          return arr.filter(function (elem, pos) {
            return arr.indexOf(elem) == pos;
          });
        };
      },
      {},
    ],
    40: [
      function (require, module, exports) {
        // Module to enumerate all CFG symbols for the human language for time

        /**
         * Module Dependencies
         */

        var maps = require("./maps.json");
        var util = require("./util");

        /**
         * Constructors for all types of symbols
         */
        var symbolConstructors = {
          op: op,
          c: c,
          r: r,
          n: n,
          t: T,
          dt: T,
          T: T,
          f: f,
          o: o,
          rT: rT,
          cT: cT,
        };

        /**
         * Export `symbol`
         */

        module.exports = symbol;

        /**
         * The symbol constructor, given a string, lemmatize it, then return a symbol from {=null,op,c,r,n,t,dt,T,f}.
         * i.e. str -> parseFloat(str) -> new n(str) -> return
         * or str -> lemma(str) -> new <symbol-name>(symbol-value) -> return
         * @param {string}  str       the input string
         * @return {*} The object from the class of symbols
         * @example
         * symbol('90')
         * // => n { value: 10 }
         * symbol('hour')
         * // a <dt> time difference object
         * // => dt { h: '1' }
         * symbol('tonight')
         * // or equivalently, takes the T string too
         * symbol('t:=9h,dt:12h')
         * // a T object containing <t>, <dt>
         * // => T { t: t { h: '=9' }, dt: dt { h: '12' } }
         * symbol('unrecognized')
         * // an unrecognized string yields the null symbol 
         * // => null
         */
        function symbol(str) {
          var s;
          if (str == null) {
            // null gets null
            s = null;
          } else if (str["start"] && str["end"]) {
            // range: with 'start' and 'end'
            s = new symbolConstructors["rT"](str);
          } else if (parseFloat(str) == str) {
            // 'n'
            s = new symbolConstructors["n"](str);
          } else if (str.match(util.reT)) {
            // if is of the T string format t:<val>,dt:<val>
            s = str.match(/\s+/g) ? null : new symbolConstructors["T"](str);
          } else {
            var lem = util.lemma(str);
            s = lem.name
              ? new symbolConstructors[lem.name](lem.value, lem.name)
              : null;
            // set the canonical word from lemma
            if (s) {
              s.canon = lem.canon;
            }
            // set the original token for reference
          }
          if (s) {
            s.token = str;
          }
          return s;
        }

        // console.log(symbol('10'))
        // console.log(symbol('hour'))
        // console.log(symbol('tonight'))
        // console.log(symbol('t:=9h,dt:12h'))
        // console.log(symbol('unrecognized'))

        // ///////////////////
        // the CFG symbols //
        // ///////////////////

        /**
         * The op for arithmetic operator.
         * note that since scaling(*,/) is very rare, we omit its implementation for now.
         */
        function op(value) {
          this.value = value;
        }

        /**
         * The origin operator.
         */
        function o(value) {
          this.value = value;
        }

        /**
         * The range operator.
         */
        function r(value) {
          this.value = value;
        }

        /**
         * The cron operator.
         */
        function c(value) {
          this.value = value;
        }

        /**
         * The n number. Calls parseFloat.
         */
        function n(value) {
          this.value = parseFloat(value);
        }

        /**
         * The t for time t, i.e. a point in the timeline
         * units: ms, s, m, h, d, w, M, y
         * All values are string, to represent the "=" default in the units. so when performing numerical operation, use parseFloat.
         * @example
         * new t(undefined)
         * new t("")
         * // => t {}
         * new t("7h30m")
         * // => t { h: '7', m: '30' }
         * new t("7h=30m")
         * // => t { h: '7', m: '=30' }
         */
        function t(value) {
          // guard against falsy input
          if (!value) {
            return null;
          }
          // 1. see if unit is prepended with "=" for default, or set to ''
          // 2. then consume chunks of <number><timeUnit> like "30m"
          while (value) {
            var isDefault = (value.match(/^=/) || [])[0] || "";
            value = value.replace(/^=/, "");
            // default number is "1"
            var number = (value.match(/^\-?\d+(\.\d+)?/) || [])[0] || "1";
            value = value.replace(/^\-?\d+(\.\d+)?/, "");
            var unit = (value.match(/^[a-zA-Z]+/) || [])[0];
            value = value.replace(/^[a-zA-Z]+/, "");
            // prepend the number (string) with isDefault, i.e. "=" or ""
            this[unit] = isDefault + number;
          }
        }

        /**
         * The dt for time t, i.e. a displacement in the timeline
         * units: ms, s, m, h, d, w, M, y
         * All values are string, to represent the "=" default in the units. so when performing numerical operation, use parseFloat.
         * Same keys as <t> to allow for component-wise operation, e.g. t + dt = { ms+(d)ms, s+(d)s, ... }
         */
        function dt(value) {
          // guard against falsy input
          if (!value) {
            return null;
          }
          // 1. see if unit is prepended with "=" for default, or set to ''
          // 2. then consume chunks of <number><timeUnit> like "30m"
          while (value) {
            var isDefault = (value.match(/^=/) || [])[0] || "";
            value = value.replace(/^=/, "");
            // default number is "1"
            var number = (value.match(/^\-?\d+(\.\d+)?/) || [])[0] || "1";
            value = value.replace(/^\-?\d+(\.\d+)?/, "");
            var unit = (value.match(/^[a-zA-Z]+/) || [])[0];
            value = value.replace(/^[a-zA-Z]+/, "");
            // prepend the number (string) with isDefault, i.e. "=" or ""
            this[unit] = isDefault + number;
          }
        }

        // console.log(new t(undefined))
        // console.log(new t(""))
        // console.log(new t("7h30m"))
        // console.log(new t("=7h30m"))
        // console.log(new t().constructor.name)

        /**
         * The T, implementation-specific, is a linear combination of <t> and <dt>.
         * Used to capture the human Ts, e.g. noon, afternoon, dawn, evening, today, tonight, Sunday, fortnight, weekdays, weekends, christmas, spring, summer, holidays etc.
         * To specify T in maps.json, follow the syntax:
         * `:` means "set", `=` means "default", use t:<value>,dt:<value> for the symbol-value, e.g. "t:=7h,dt:0h"
         * evening ~ t:=7h,dt:12h, read as "t set to default 7h, dt set to 12h"
         * later ~ t:,dt:=3h, read as "t set to nothing, dt set to default 3h"
         * beware, "" and "0" are diferent, the former is empty, the later a numerical value.
         * @param  {string} value from the Symbol.
         * @param  {string} [name] from the Symbol.
         * @example
         * var T = new symbol("t:=7h,dt:0h")
         * // => T { t: t { h: '=7' }, dt: dt { h: '0' } }
         * T.t
         * // => t { h: '=7' }
         * T.dt
         * // => t { h: '0' }
         */
        function T(value, name) {
          if (name == "t") {
            this.t = new t(value);
            this.dt = new dt();
          } else if (name == "dt") {
            this.t = new t();
            this.dt = new dt(value);
          } else {
            var split = value.split(","),
              _t = split[0].split(":").pop(),
              _dt = split[1].split(":").pop();
            this.t = new t(_t);
            this.dt = new dt(_dt);
          }
        }

        // var T = new T("t:=7h,dt:0h")
        // console.log(T.t)
        // console.log(T.dt)

        /**
         * The product of <r><T>, gives a time interval
         */
        function rT(interval) {
          this.start = interval.start;
          this.end = interval.end;
        }

        /**
         * The f to capture frequency for <c>.
         */
        function f(value) {
          this.value = value;
        }

        /**
         * The product of <c><T> or <c><rT>, gives a cron time
         */
        function cT(cron) {
          this.cron = cron;
        }
      },
      { "./maps.json": 36, "./util": 42 },
    ],
    41: [
      function (require, module, exports) {
        // Module to tokenize a string into CFG symbols

        /**
         * Module Dependencies
         */
        var util = require("./util");
        var symbol = require("./symbol");
        var maps = require("./maps.json");

        /**
         * regexes for Subnormal forms
         */

        var re = {
          // 12/20 - 12/21, 2012/12 - 2013/12
          MMsDDdMMsDD:
            /(?!\d{1,4}\/\d{1,4}\s*-\s*\d{1,4}\/\d{1,4}\/)(\d{1,4})\/(\d{1,4})\s*-\s*(\d{1,4})\/(\d{1,4})/g,
          // 12/22 - 23, 2012/10 - 12
          MMsDDdDD:
            /(?!\d{1,4}\/\d{1,4}\s*-\s*\d{1,4}\/)(\d{1,4})\/(\d{1,4})\s*-\s*(\d{1,4})/g,
          // 12/24, 2012/12
          MMsDD: /(?!\d{1,4}\/\d{1,4}\/)(\d{1,4})\/(\d{1,4})/g,
          // 05:30pm, 0530pm, 1730, 1730pm, 1730[re:h], remove the [re:h]
          hhcmm: /(\s+\d{1,2}|^\d{1,2})\:?(\d{2})\s*(\S+)*/g,
        };

        /**
         * Export `tokenize`
         */

        module.exports = tokenize;

        /**
         * Parse and tokenize a string into array of valid CFG symbols, in these steps:
         * 1. parse normal forms
         * 2. parse subnormal forms
         * 3. parse english forms
         * @param  {string} str The input string.
         * @return {JSON}     {str, tokensIn, tokensOut, symbols}
         */
        function tokenize(str) {
          // split num from alphabets
          str = (" " + str)
            .replace(/\s+(\d+)([a-zA-Z]+)/g, " $1 $2")
            .replace(/\s+([a-zA-Z]+)(\d+)/g, " $1 $2")
            .replace(/\s+/g, " ")
            .replace(/^\s+/, "");
          // 1. 2. parse normal and subnormal forms
          var p = parseNormal12(str),
            pStr = p.str,
            tokens = pStr.split(" "),
            symbols = [];
          // clean the non-normal tokens a bit, allow to be wrapped by words only
          for (var i = 0; i < tokens.length; i++) {
            if (!tokens[i].match(util.reT)) {
              tokens[i] = tokens[i].replace(/^\W+/, "").replace(/\W+$/, "");
            }
          }

          // 3. parse english forms
          for (var i = 0; i < tokens.length; i++) {
            var tok = tokens[i];
            var oneGram = tok,
              twoGram = tok + " " + (tokens[i + 1] || ""),
              oneSym = symbol(oneGram),
              twoSym = symbol(twoGram);
            if (twoSym && twoSym.value == oneSym.value) {
              // if lemmatization must happen for both,
              // pick the longer, skip next token
              // skip this once, reset skip
              i++;
              symbols.push(symbol(twoGram));
            } else {
              symbols.push(symbol(oneGram));
            }
          }
          return {
            str: pStr,
            tokensOut: p.tokensOut,
            tokensIn: p.tokensIn,
            symbols: symbols,
          };
        }

        /**
         * Run 1. parseNormal then 2. parseNormal2, return the parsed string with T-format tokens.
         * @private
         * @param  {string} str The input string
         * @return {JSON}     Parsed string
         */
        function parseNormal12(str) {
          var p1 = parseNormal1(str);
          // find tokens that are purely normal, and reinject into string
          var p1TokensOut = p1.tokensOut.filter(notSubnormal);
          var p1Str = injectNormal(str, p1TokensOut);
          // now parse the subnormal
          var p2 = parseNormal2(p1Str, [], []);
          // the tokens that taken out, and their replacements, in order
          var pTokensOut = p1.tokensOut.concat(p2.tokensOut);
          var pTokensIn = p1.tokensIn.concat(p2.tokensIn);
          return {
            str: p2.str,
            tokensOut: pTokensOut,
            tokensIn: pTokensIn,
          };
        }

        /**
         * 1. Parse normal forms. Try to parse and return a normal Date, parseable from new Date(str), by continuously trimming off its tail and retry until either get a valid date, or string runs out.
         * Doesn't parse string with length <5
         * @private
         * @param  {string} str The input string.
         * @return {string}     A Date in stdT string, or null.
         */
        function parseNormal1(str) {
          // keep chopping off tail until either get a valid date, or string runs out
          // array of parsed date and the string consumed
          var tokensIn = [],
            tokensOut = [];
          // ensure single spacing
          str = str.replace(/\s+/g, " ");
          // tokenize by space
          var strArr = str.split(/\s+/g);

          // init the normalDate and head string used
          var normalDate = null,
            head = "";
          // do while there's still string to go
          while (strArr.length) {
            head = (head + " " + strArr.shift()).trim();
            try {
              normalDate = util.stdT(new Date(head));
              // Extend head: if parse successful, extend continuously until failure, then that's the longest parseable head string, ...<date>
              var advanceHead = head + " " + strArr[0];
              while (1) {
                try {
                  var advanceDate = util.stdT(new Date(advanceHead));
                  if (advanceDate != "Invalid Date") {
                    // if advanceDate is parseable, set to current, update heads
                    var normalDate = advanceDate;
                    head = head + " " + strArr.shift();
                    advanceHead = advanceHead + " " + strArr[0];
                  } else {
                    break;
                  }
                } catch (e) {
                  // when fail, just break
                  break;
                }
              }
              // Shrink head: from the whole parseable head ...<date>, trim front till we get <date>
              while (1) {
                try {
                  if (
                    util.stdT(new Date(head.replace(/^\s*\S+\s*/, ""))) !=
                    normalDate
                  ) {
                    // front token eaten causes change, dont update head
                    break;
                  } else {
                    // update head
                    head = head.replace(/^\s*\S+\s*/, "");
                  }
                } catch (e) {
                  break;
                }
              }
              // only consider a valid parse if the parsed str is long enough
              if (head.length > 6) {
                tokensIn.push(normalDate);
                // get head = <date> only, then reset
                tokensOut.push(head);
              }
              head = "";
            } catch (e) {}
          }
          return { tokensIn: tokensIn, tokensOut: tokensOut };
        }

        /**
         * 2. Parse subnormal forms after parseNormal. Gradually replace tokens of the input string while parseable.
         * @private
         */
        function parseNormal2(str, tokensIn, tokensOut) {
          var m, res;
          if ((m = re.MMsDDdMMsDD.exec(str))) {
            // 12/20 - 12/21
            var yMd1 = yMdParse(m[1], m[2]);
            var yMd2 = yMdParse(m[3], m[4]);
            res = " t:" + yMd1 + ",dt: - t:" + yMd2 + ",dt: ";
          } else if ((m = re.MMsDDdDD.exec(str))) {
            // 12/22 - 23
            var yMd1 = yMdParse(m[1], m[2]);
            var yMd2 = yMdParse(m[1], m[3]);
            res = " t:" + yMd1 + ",dt: - t:" + yMd2 + ",dt: ";
          } else if ((m = re.MMsDD.exec(str))) {
            // if year
            var yMd = yMdParse(m[1], m[2]);
            // 12/24
            res = " t:" + yMd + ",dt: ";
          } else if ((m = re.hhcmm.exec(str))) {
            // 05:30pm, 0530pm, 1730, 1730pm, 1730[re:h], remove the [re:h]
            res =
              " t:" + m[1].trim() + "h" + m[2] + "m" + ",dt: " + (m[3] || "");
          } else {
            // exit recursion if hits here
            return {
              str: str,
              tokensIn: tokensIn,
              tokensOut: tokensOut,
            };
          }
          // recurse down till no more substitution (CFG is not cyclic, so ok)
          tokensOut.push(m[0]);
          tokensIn.push(res);
          str = parseNormal2(str.replace(m[0], res), tokensIn, tokensOut).str;
          return {
            str: str,
            tokensIn: tokensIn,
            tokensOut: tokensOut,
          };
        }

        // ////////////////////
        // Helper functions //
        // ////////////////////

        /**
         * Try to parse two tokens for T form into MM/dd, or MM/yyyy if either token hsa length 4.
         * @private
         * @param  {string} token1
         * @param  {string} token2
         * @return {string}        in the form <y><M><d>
         */
        function yMdParse(token1, token2) {
          var part0 = [token1, token2].filter(function (token) {
            return token.length == 4;
          });
          var part1 = [token1, token2].filter(function (token) {
            return token.length != 4;
          });
          var y = part0[0] ? part0[0] + "y" : "";
          var M = part1[0] + "M";
          var d = part1[1] ? part1[1] + "d" : "";
          return y + M + d;
        }

        /**
         * Check if the dateStr is strictly normal and not subnormal. Used to extract parseNormal2 overrides.
         * @private
         * @param  {string} dateStr
         * @return {Boolean}
         */
        function notSubnormal(dateStr) {
          var subnormalStr = parseNormal2(dateStr, [], []).str;
          // remove T and see if still has words
          var noT = subnormalStr.replace(
            /t\:\S*,dt\:\S*(\s*-\s*t\:\S*,dt\:\S*)?/,
            ""
          );
          return /\w+/g.exec(noT) != null;
        }

        /**
         * Given a string and array of its parsed phrases, convert them into T stdT then T format, and inject into the original string, return.
         * @private
         * @param  {string} str       The original string.
         * @param  {Array} parsedArr The parsed phrases from the string.
         * @return {string}           The string with parsed phrases replaced in T format.
         *
         * @example
         * injectNormal('05 October 2011 14:48 UTC 08/11 2020', [ '05 October 2011 14:48 UTC', '08/11 2020' ])
         * // => 't:2011y10M05d14h48m00.000s,dt: t:2020y08M11d04h00m00.000s,dt: '
         */
        function injectNormal(str, parsedArr) {
          for (var i = 0; i < parsedArr.length; i++) {
            var parsed = parsedArr[i];
            var T = util.stdTtoT(util.stdT(new Date(parsed)));
            str = str.replace(parsed, T);
          }
          return str;
        }
      },
      { "./maps.json": 36, "./symbol": 40, "./util": 42 },
    ],
    42: [
      function (require, module, exports) {
        /**
         * Module Dependencies
         */

        var _ = require("./subdash");
        var maps = require("./maps.json");

        /**
         * The T string regex, e.g. "t:=9h,dt:12h", to encode T = <t> <dt>. Is case sensitive.
         */

        var reT = /t\:\S*,dt\:\S*/g;

        /**
         * The ordering of time units, large to small,
         * 'mer' is the meridiem, 0 for am, 1 for pm
         * and the units used for carrying
         */

        var timeUnitOrder = ["y", "M", "w", "d", "h", "m", "s", "ms"];
        var canonTimeUnitOrder = [];
        for (var i = 0; i < timeUnitOrder.length; i++) {
          var unit = timeUnitOrder[i];
          canonTimeUnitOrder.push(lemma(unit).canon);
        }
        var tOrdering = ["y", "M", "d", "h", "m", "s"];
        var tFactor = [365, 30, 24, 60, 60];

        /**
         * Delimiters for stdT string
         */

        var stdTdelim = ["-", "-", " ", ":", ":", ""];

        /**
         * Export `util`
         */

        module.exports = {
          TtoStdT: TtoStdT,
          TtoStr: TtoStr,
          delimSyms: delimSyms,
          hasSym: hasSym,
          has_dt: has_dt,
          has_pureTimeUnit: has_pureTimeUnit,
          has_t: has_t,
          highestOverride: highestOverride,
          isSym: isSym,
          largestUnit: largestUnit,
          lemma: lemma,
          nextLargestUnit: nextLargestUnit,
          nowT: nowT,
          opType: opType,
          orderChunks: orderChunks,
          removeTnPlus: removeTnPlus,
          reT: reT,
          sName: sName,
          splitByArr: splitByArr,
          splitSyms: splitSyms,
          splitT: splitT,
          stdT: stdT,
          stdTdelim: stdTdelim,
          stdTtoT: stdTtoT,
          tOrdering: tOrdering,
          timeUnitOrder: timeUnitOrder,
          canonTimeUnitOrder: canonTimeUnitOrder,
          tokenToStr: tokenToStr,
          unparsedStr: unparsedStr,
        };

        /**
         * Convert a T string to stdT string, with default filled by nowT().
         * @example
         * TtoStdT('t:10M05d14h48m00.000s,dt:')
         * // => 2016-10-05 14:48:00
         */
        function TtoStdT(str, offset) {
          if (typeof str != "string") {
            str = TtoStr(str);
          }
          var nowStr = nowT(offset),
            nowArr = splitT(nowStr),
            strArr = splitT(str);
          var resArr = [];
          for (var i = 0; i < nowArr.length; i++) {
            var val = parseFloat(strArr[i]);
            if (Number.isNaN(val)) {
              val = parseFloat(nowArr[i]);
            }
            resArr.push(val);
          }
          var resStr = "";
          for (var i = 0; i < stdTdelim.length; i++) {
            var num = resArr[i].toString();
            // e.g. '5.123' tends to be '05.123', fix it
            var predecimal = /(\d+)(\.\d+)?/.exec(num)[1],
              postdecimal = /(\d+)\.?(\d+)?/.exec(num)[2];
            if (predecimal.length == 1) {
              num = "0" + num;
            }
            if (postdecimal != null) {
              for (var j = 0; j < 3 - postdecimal.length; j++) {
                num = num + "0";
              }
            }
            resStr += num + stdTdelim[i];
          }
          // console.log('resStr', resStr)
          return resStr;
        }
        // console.log(TtoStdT('t:10M05d14h48m00.010s,dt:'))

        /**
         * Convert a T symbol into its T string.
         */
        function TtoStr(T) {
          var tStr = "t:",
            dtStr = ",dt:";
          for (var i = 0; i < timeUnitOrder.length; i++) {
            var tUnit = timeUnitOrder[i];
            // if unit exist, write to str
            if (T["t"][tUnit] != undefined) {
              tStr += T["t"][tUnit] + tUnit;
            }
            if (T["dt"][tUnit] != undefined) {
              dtStr += T["dt"][tUnit] + tUnit;
            }
          }
          return tStr + dtStr;
        }

        /**
         * Delimit the array of timeChunk symbols by combining consecutive nulls (>3) into one, and dumping those shorter. Result is then delimited by 'trinull'.
         * @param  {Array} syms Of parsed symbols aka time chunks.
         * @return {Array}      symbols delimited by 'trinull'
         */
        function delimSyms(syms) {
          // 1.
          // contract the nulls into trinulls in a single array
          var newSyms = [],
            count = 0;
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i];
            if (s == null) {
              count++;
            } else {
              if (count > 2) {
                newSyms.push("trinull");
              }
              newSyms.push(s);
              count = 0;
            }
          }
          return newSyms;
        }
        // console.log(delimSyms([1, 2, null, null, null, 3]))

        /**
         * Check if arr has symbol whose name is listen in symArr.
         * @param  {Array}  arr    Array of symbols.
         * @param  {Array}  symArr Array of symbol names.
         * @return {Boolean}
         */
        function hasSym(syms, symArr) {
          var found = false;
          for (var i = 0; i < syms.length; i++) {
            if (isSym(syms[i], symArr)) {
              found = true;
              break;
            }
          }
          return found;
        }

        /**
         * Check if T.dt is not empty
         */
        function has_dt(T) {
          return _.keys(T.dt).length > 0;
        }

        /**
         * Check if T has only t, dt with units from timeUnitOrder
         */
        function has_pureTimeUnit(T) {
          var dt = T.dt,
            t = T.t;
          var pure = true;
          for (var k in dt) {
            if (!_.includes(timeUnitOrder, k)) {
              pure = false;
              break;
            }
          }
          for (var k in t) {
            if (!_.includes(timeUnitOrder, k)) {
              pure = false;
              break;
            }
          }
          return pure;
        }

        /**
         * Check if T.t is not empty
         */
        function has_t(T) {
          return _.keys(T.t).length > 0;
        }

        /**
         * find the lowest overridable unit in t or dt
         */
        function highestOverride(t) {
          var lowestOverable = null;
          for (var i = 0; i < tOrdering.length; i++) {
            var unit = tOrdering[i];
            if (/^=/.exec(t[unit])) {
              lowestOverable = unit;
              break;
            }
          }
          return lowestOverable;
        }

        /**
         * Check if arr has the symbol name of s.
         * @param  {symbol}  s   symbol object
         * @param  {Array}  arr Of string symbol names
         * @return {Boolean}
         */
        function isSym(s, arr) {
          return _.includes(arr, sName(s));
        }

        /**
         * Find the largest enumerated unit in T.t, or if none, in T.dt
         */
        function largestUnit(T) {
          var lu = _.find(tOrdering, function (unit) {
            return T.t[unit];
          });
          if (lu == null) {
            lu = _.find(tOrdering, function (unit) {
              return T.dt[unit];
            });
          }
          return lu;
        }

        /**
         * Return the lemma symbol of a word string, i.e. the name and value of the symbol it belongs to in the CFG. Uses ./maps.json.
         * NLP Lemmatization refers here: htp://nlp.stanford.edu/Ir-book/html/htmledition/stemming-and-lemmatization-1.html. Inflections = all possible alternative words of a lemma.
         * @param  {string} str To lemmatize.
         * @return {JSON}     Lemma symbol {name, value} for CFG
         * @example
         * lemma('zero')
         * // => { value: '0', name: 'n' }
         */
        function lemma(str) {
          // change all to lower case except for 'M' for month
          str = str == "M" ? str : str.toLowerCase();
          var lem = {},
            name = null,
            value = null,
            canon = str;
          var mapsKeys = _.keys(maps);
          for (var i = 0; i < mapsKeys.length; i++) {
            var sMap = maps[mapsKeys[i]],
              sMapKeys = _.keys(sMap);
            for (var j = 0; j < sMapKeys.length; j++) {
              var inflectionArr = sMap[sMapKeys[j]];
              if (_.includes(inflectionArr, str)) {
                // set the canonical form as the first in inflectionArr
                canon = inflectionArr[0];
                // if str is in inflections
                value = sMapKeys[j];
                break;
              }
            }
            if (value != null) {
              name = mapsKeys[i];
              break;
            }
          }
          // set value
          lem["name"] = name;
          lem["value"] = value;
          lem["canon"] = canon;
          return lem;
        }
        // console.log(lemma('zero'))

        /**
         * Find the next largest enumerated unit in T.t, or if none, in T.dt
         */
        function nextLargestUnit(T) {
          var lu = largestUnit(T);
          return tOrdering[tOrdering.indexOf(lu) - 1];
        }

        /**
         * Convenient method to get current time in T format.
         * @return {string} T format string.
         */
        function nowT(offset) {
          var dateStr = offset == undefined ? stdT(new Date()) : stdT(offset);
          return stdTtoT(dateStr);
        }

        /**
         * Determine the op type based on arguments
         */
        function opType(L, op, R) {
          var LsName = sName(L) || "",
            RsName = sName(R) || "";
          var opsName = sName(op);
          if (opsName != "o" && opsName != "r" && opsName != "c") {
            opsName = "";
          }
          return LsName + opsName + RsName;
        }

        /**
         * Order time chunks by not containing T, short to long, then containing T, short to long. Used for .pop() to get the candidate timechunk for parsing.
         */
        function orderChunks(matrix) {
          // 2.
          // ok partition first then sort
          var hasNoT = matrix.filter(function (row) {
            return !hasSym(row, ["T"]);
          });
          var hasT = matrix.filter(function (row) {
            return hasSym(row, ["T"]);
          });
          // matrix, sorted short to long
          var lengthSortedNotTMat = hasNoT.sort(function (a, b) {
            return a.length - b.length;
          });
          var lengthSortedTMat = hasT.sort(function (a, b) {
            return a.length - b.length;
          });
          // 3.1 3.2 3.3
          return lengthSortedNotTMat.concat(lengthSortedTMat);
        }

        /**
         * !remove the defaul <o|op> that is 'plus' between <T>, <n> for defaulting to plus.
         * !is a quickfix for mat
         */
        function removeTnPlus(syms) {
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i];
            if (
              isSym(s, ["op"]) &&
              s.value == "plus" &&
              isSym(syms[i + 1], ["n"])
            ) {
              syms.splice(i, 1);
            }
          }
          return syms;
        }

        /**
         * Return the name of a symbol: {op,c,r,n,T,f}
         * @param  {Symbol} symbol A CFG symbol.
         * @return {string}        name of the symbol.
         */
        function sName(symbol) {
          return symbol ? symbol.constructor.name : null;
        }

        /**
         * Split a string by an array of tokens.
         * @param  {string} str       The input string.
         * @param  {Array} tokenArr Array of tokens to split the string by.
         * @return {Array}           The split string array.
         */
        function splitByArr(str, tokenArr) {
          var delim = "#{REPLACE}";
          // inject into tokens
          for (var i = 0; i < tokenArr.length; i++) {
            var token = tokenArr[i];
            str = str.replace(token, delim);
          }
          // split into arr
          return str.split(delim);
        }
        // console.log(splitByArr('lorem 1 ipsum 2 dolor 3', [1,2,3]))

        /**
         * Split an array of symbols by delimiter into matrix.
         * @param  {Array} syms      The input array
         * @param  {string|symbol} delimiter To split the array by
         * @return {matrix}           delimited arrays.
         */
        function splitSyms(syms, delimiter) {
          // split the single array into matrix
          var matrix = [],
            newRow = [];
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i];
            if (s == delimiter || sName(s) == delimiter) {
              // delimit and push to matrix
              matrix.push(newRow);
              newRow = [];
            } else if (i == syms.length - 1) {
              // edge case, push res
              newRow.push(s);
              matrix.push(newRow);
            } else {
              // accumulate in row
              newRow.push(s);
            }
          }
          return matrix;
        }

        /**
         * Split a T string into array of [_y, _M, _d, _h, _m, _s]
         */
        function splitT(str) {
          if (!str.match(reT)) {
            return null;
          }
          var _y = (/(\d+(\.\d+)?)y/.exec(str) || [])[1],
            _M = (/(\d+(\.\d+)?)M/.exec(str) || [])[1],
            _w = (/(\d+(\.\d+)?)w/.exec(str) || [])[1],
            _d = (/(\d+(\.\d+)?)d/.exec(str) || [])[1],
            _h = (/(\d+(\.\d+)?)h/.exec(str) || [])[1],
            _m = (/(\d+(\.\d+)?)m/.exec(str) || [])[1],
            _s = (/(\d+(\.\d+)?)s/.exec(str) || [])[1];

          // The Time Object
          var TO = {
            y: _y,
            M: _M,
            w: _w,
            d: _d,
            h: _h,
            m: _m,
            s: _s,
          };
          // do the carries
          TO = carry(TO);

          // compose results
          var res = [];
          for (var i = 0; i < tOrdering.length; i++) {
            var k = tOrdering[i];
            res.push(TO[k]);
          }
          return res;
        }

        /**
         * Function to properly down- and up- carry Time Object
         * 1. dumpweek, 2. carryDown, 3. carryUp
         */
        function carry(TO) {
          TO = dumpWeek(TO);
          TO = carryDown(TO);
          TO = carryUp(TO);
          return TO;
        }

        /**
         * 1. dumpWeek
         */
        function dumpWeek(TO) {
          var _w = parseFloat(TO["w"] || "0"),
            _d = parseFloat(TO["d"] || "0");
          TO["d"] = _d + _w * 7;
          delete TO["w"];
          return TO;
        }

        /**
         * 2. carryDown
         */
        function carryDown(TO) {
          // shall reverse the ordering and factors for opp direction
          var ordering = tOrdering,
            factor = tFactor;
          var carry = 0;
          for (var i = 0; i < ordering.length; i++) {
            // the time unit in the ordering
            var u = ordering[i];
            // skip the rest of loopbody if this unit is undefined and nothing to carry
            if (TO[u] == undefined && carry == 0) {
              continue;
            }
            // carry
            TO[u] = parseFloat(TO[u] || "0") + carry;
            // dont go in after the last one
            if (i == ordering.length - 1) {
              // overlong s decimal will be fixed in TtoStdT
              break;
            }
            var decimal = parseFloat(TO[u] || "0") - parseInt(TO[u] || "0");
            if (decimal > 0) {
              // set next carry
              carry = decimal * factor[i];
              // update current u
              TO[u] = parseInt(TO[u]);
            } else {
              // else reset to 0 if no carry
              carry = 0;
            }
          }
          return TO;
        }

        /**
         * 3. carryUp
         */
        function carryUp(TO) {
          // shall reverse the ordering and factors for opp direction
          var ordering = tOrdering.slice().reverse(),
            factor = tFactor.slice().reverse();
          var carry = 0;
          for (var i = 0; i < ordering.length; i++) {
            // the time unit in the ordering
            var u = ordering[i];
            // skip the rest of loopbody if this unit is undefined and nothing to carry
            if (TO[u] == undefined && carry == 0) {
              continue;
            }
            // carry
            TO[u] = parseFloat(TO[u] || "0") + carry;
            // dont go in after the last one
            if (i == ordering.length - 1) {
              break;
            }
            var deci = parseInt(parseFloat(TO[u] || "0") / factor[i]);
            if (deci > 0) {
              // set next carry
              carry = deci;
              // update current u
              TO[u] = parseFloat(TO[u] || "0") % factor[i];
            } else {
              // else reset to 0 if no carry
              carry = 0;
            }
          }
          return TO;
        }

        /**
         * Take a date or string, parse it into standard format as yyyy-MM-dd hh:mm:ss.sss
         */
        function stdT(date) {
          if (typeof date == "string") {
            date = new Date(date);
          }
          var _y = date.getFullYear(),
            _M = date.getMonth() + 1,
            _d = date.getDate(),
            _date = [_y, _M, _d].join("-");
          (_time = /(\d\S+)/.exec(date.toTimeString())[1]),
            (format = _date + " " + _time);
          return format;
        }

        /**
         * Convert std time string to T string.
         * @example
         * stdTtoT('2011-10-05T14:48:00.000')
         * // => 't:2011y10M05d14h48m00.000s,dt:'
         */
        function stdTtoT(str) {
          var datetime = str.split(" ");
          var date = datetime[0].split("-"),
            time = datetime[1].split(":");
          return (
            "t:" +
            date[0] +
            "y" +
            date[1] +
            "M" +
            date[2] +
            "d" +
            time[0] +
            "h" +
            time[1] +
            "m" +
            time[2] +
            "s,dt:"
          );
        }
        // console.log(stdTtoT('2011-10-05T14:48:00.000Z'))

        /**
         * Recombine array of symbols back into str
         */
        function tokenToStr(syms) {
          var tokens = [];
          for (var i = 0; i < syms.length; i++) {
            tokens.push(syms[i].token);
          }
          return tokens.join(" ");
        }

        /**
         * Extract unparsedTokens from str and parsed syms then join them
         */
        function unparsedStr(str, syms) {
          var inputTokens = str.split(/\s+/);
          var tokens = [];
          for (var i = 0; i < syms.length; i++) {
            if (syms[i] == null) {
              tokens.push(inputTokens[i]);
            }
          }
          return tokens.join(" ");
        }
      },
      { "./maps.json": 36, "./subdash": 39 },
    ],
    43: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            /**
             * This is the web browser implementation of `debug()`.
             *
             * Expose `debug()` as the module.
             */

            exports = module.exports = require("./debug");
            exports.log = log;
            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.storage =
              "undefined" != typeof chrome &&
              "undefined" != typeof chrome.storage
                ? chrome.storage.local
                : localstorage();

            /**
             * Colors.
             */

            exports.colors = [
              "#0000CC",
              "#0000FF",
              "#0033CC",
              "#0033FF",
              "#0066CC",
              "#0066FF",
              "#0099CC",
              "#0099FF",
              "#00CC00",
              "#00CC33",
              "#00CC66",
              "#00CC99",
              "#00CCCC",
              "#00CCFF",
              "#3300CC",
              "#3300FF",
              "#3333CC",
              "#3333FF",
              "#3366CC",
              "#3366FF",
              "#3399CC",
              "#3399FF",
              "#33CC00",
              "#33CC33",
              "#33CC66",
              "#33CC99",
              "#33CCCC",
              "#33CCFF",
              "#6600CC",
              "#6600FF",
              "#6633CC",
              "#6633FF",
              "#66CC00",
              "#66CC33",
              "#9900CC",
              "#9900FF",
              "#9933CC",
              "#9933FF",
              "#99CC00",
              "#99CC33",
              "#CC0000",
              "#CC0033",
              "#CC0066",
              "#CC0099",
              "#CC00CC",
              "#CC00FF",
              "#CC3300",
              "#CC3333",
              "#CC3366",
              "#CC3399",
              "#CC33CC",
              "#CC33FF",
              "#CC6600",
              "#CC6633",
              "#CC9900",
              "#CC9933",
              "#CCCC00",
              "#CCCC33",
              "#FF0000",
              "#FF0033",
              "#FF0066",
              "#FF0099",
              "#FF00CC",
              "#FF00FF",
              "#FF3300",
              "#FF3333",
              "#FF3366",
              "#FF3399",
              "#FF33CC",
              "#FF33FF",
              "#FF6600",
              "#FF6633",
              "#FF9900",
              "#FF9933",
              "#FFCC00",
              "#FFCC33",
            ];

            /**
             * Currently only WebKit-based Web Inspectors, Firefox >= v31,
             * and the Firebug extension (any Firefox version) are known
             * to support "%c" CSS customizations.
             *
             * TODO: add a `localStorage` variable to explicitly enable/disable colors
             */

            function useColors() {
              // NB: In an Electron preload script, document will be defined but not fully
              // initialized. Since we know we're in Chrome, we'll just detect this case
              // explicitly
              if (
                typeof window !== "undefined" &&
                window.process &&
                window.process.type === "renderer"
              ) {
                return true;
              }

              // Internet Explorer and Edge do not support colors.
              if (
                typeof navigator !== "undefined" &&
                navigator.userAgent &&
                navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
              ) {
                return false;
              }

              // is webkit? http://stackoverflow.com/a/16459606/376773
              // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
              return (
                (typeof document !== "undefined" &&
                  document.documentElement &&
                  document.documentElement.style &&
                  document.documentElement.style.WebkitAppearance) ||
                // is firebug? http://stackoverflow.com/a/398120/376773
                (typeof window !== "undefined" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                // is firefox >= v31?
                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                (typeof navigator !== "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                // double check webkit in userAgent just in case we are in a worker
                (typeof navigator !== "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
              );
            }

            /**
             * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
             */

            exports.formatters.j = function (v) {
              try {
                return JSON.stringify(v);
              } catch (err) {
                return "[UnexpectedJSONParseError]: " + err.message;
              }
            };

            /**
             * Colorize log arguments if enabled.
             *
             * @api public
             */

            function formatArgs(args) {
              var useColors = this.useColors;

              args[0] =
                (useColors ? "%c" : "") +
                this.namespace +
                (useColors ? " %c" : " ") +
                args[0] +
                (useColors ? "%c " : " ") +
                "+" +
                exports.humanize(this.diff);

              if (!useColors) return;

              var c = "color: " + this.color;
              args.splice(1, 0, c, "color: inherit");

              // the final "%c" is somewhat tricky, because there could be other
              // arguments passed either before or after the %c, so we need to
              // figure out the correct index to insert the CSS into
              var index = 0;
              var lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, function (match) {
                if ("%%" === match) return;
                index++;
                if ("%c" === match) {
                  // we only are interested in the *last* %c
                  // (the user may have provided their own)
                  lastC = index;
                }
              });

              args.splice(lastC, 0, c);
            }

            /**
             * Invokes `console.log()` when available.
             * No-op when `console.log` is not a "function".
             *
             * @api public
             */

            function log() {
              // this hackery is required for IE8/9, where
              // the `console.log` function doesn't have 'apply'
              return (
                "object" === typeof console &&
                console.log &&
                Function.prototype.apply.call(console.log, console, arguments)
              );
            }

            /**
             * Save `namespaces`.
             *
             * @param {String} namespaces
             * @api private
             */

            function save(namespaces) {
              try {
                if (null == namespaces) {
                  exports.storage.removeItem("debug");
                } else {
                  exports.storage.debug = namespaces;
                }
              } catch (e) {}
            }

            /**
             * Load `namespaces`.
             *
             * @return {String} returns the previously persisted debug modes
             * @api private
             */

            function load() {
              var r;
              try {
                r = exports.storage.debug;
              } catch (e) {}

              // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
              if (!r && typeof process !== "undefined" && "env" in process) {
                r = process.env.DEBUG;
              }

              return r;
            }

            /**
             * Enable namespaces listed in `localStorage.debug` initially.
             */

            exports.enable(load());

            /**
             * Localstorage attempts to return the localstorage.
             *
             * This is necessary because safari throws
             * when a user disables cookies/localstorage
             * and you attempt to access it.
             *
             * @return {LocalStorage}
             * @api private
             */

            function localstorage() {
              try {
                return window.localStorage;
              } catch (e) {}
            }
          }.call(this));
        }.call(this, require("_process")));
      },
      { "./debug": 44, _process: 179 },
    ],
    44: [
      function (require, module, exports) {
        /**
         * This is the common logic for both the Node.js and web browser
         * implementations of `debug()`.
         *
         * Expose `debug()` as the module.
         */

        exports =
          module.exports =
          createDebug.debug =
          createDebug["default"] =
            createDebug;
        exports.coerce = coerce;
        exports.disable = disable;
        exports.enable = enable;
        exports.enabled = enabled;
        exports.humanize = require("ms");

        /**
         * Active `debug` instances.
         */
        exports.instances = [];

        /**
         * The currently active debug mode names, and names to skip.
         */

        exports.names = [];
        exports.skips = [];

        /**
         * Map of special "%n" handling functions, for the debug "format" argument.
         *
         * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
         */

        exports.formatters = {};

        /**
         * Select a color.
         * @param {String} namespace
         * @return {Number}
         * @api private
         */

        function selectColor(namespace) {
          var hash = 0,
            i;

          for (i in namespace) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
          }

          return exports.colors[Math.abs(hash) % exports.colors.length];
        }

        /**
         * Create a debugger with the given `namespace`.
         *
         * @param {String} namespace
         * @return {Function}
         * @api public
         */

        function createDebug(namespace) {
          var prevTime;

          function debug() {
            // disabled?
            if (!debug.enabled) return;

            var self = debug;

            // set `diff` timestamp
            var curr = +new Date();
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;

            // turn the `arguments` into a proper Array
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
              args[i] = arguments[i];
            }

            args[0] = exports.coerce(args[0]);

            if ("string" !== typeof args[0]) {
              // anything else let's inspect with %O
              args.unshift("%O");
            }

            // apply any `formatters` transformations
            var index = 0;
            args[0] = args[0].replace(
              /%([a-zA-Z%])/g,
              function (match, format) {
                // if we encounter an escaped % then don't increase the array index
                if (match === "%%") return match;
                index++;
                var formatter = exports.formatters[format];
                if ("function" === typeof formatter) {
                  var val = args[index];
                  match = formatter.call(self, val);

                  // now we need to remove `args[index]` since it's inlined in the `format`
                  args.splice(index, 1);
                  index--;
                }
                return match;
              }
            );

            // apply env-specific formatting (colors, etc.)
            exports.formatArgs.call(self, args);

            var logFn = debug.log || exports.log || console.log.bind(console);
            logFn.apply(self, args);
          }

          debug.namespace = namespace;
          debug.enabled = exports.enabled(namespace);
          debug.useColors = exports.useColors();
          debug.color = selectColor(namespace);
          debug.destroy = destroy;

          // env-specific initialization logic for debug instances
          if ("function" === typeof exports.init) {
            exports.init(debug);
          }

          exports.instances.push(debug);

          return debug;
        }

        function destroy() {
          var index = exports.instances.indexOf(this);
          if (index !== -1) {
            exports.instances.splice(index, 1);
            return true;
          } else {
            return false;
          }
        }

        /**
         * Enables a debug mode by namespaces. This can include modes
         * separated by a colon and wildcards.
         *
         * @param {String} namespaces
         * @api public
         */

        function enable(namespaces) {
          exports.save(namespaces);

          exports.names = [];
          exports.skips = [];

          var i;
          var split = (typeof namespaces === "string" ? namespaces : "").split(
            /[\s,]+/
          );
          var len = split.length;

          for (i = 0; i < len; i++) {
            if (!split[i]) continue; // ignore empty strings
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              exports.names.push(new RegExp("^" + namespaces + "$"));
            }
          }

          for (i = 0; i < exports.instances.length; i++) {
            var instance = exports.instances[i];
            instance.enabled = exports.enabled(instance.namespace);
          }
        }

        /**
         * Disable debug output.
         *
         * @api public
         */

        function disable() {
          exports.enable("");
        }

        /**
         * Returns true if the given mode name is enabled, false otherwise.
         *
         * @param {String} name
         * @return {Boolean}
         * @api public
         */

        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          var i, len;
          for (i = 0, len = exports.skips.length; i < len; i++) {
            if (exports.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = exports.names.length; i < len; i++) {
            if (exports.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }

        /**
         * Coerce `val`.
         *
         * @param {Mixed} val
         * @return {Mixed}
         * @api private
         */

        function coerce(val) {
          if (val instanceof Error) return val.stack || val.message;
          return val;
        }
      },
      { ms: 158 },
    ],
    45: [
      function (require, module, exports) {
        "use strict";

        var typeOf = require("kind-of");

        /**
         * Basic sort algorithm that has similar behavior to `Array.prototype.sort`
         * for null and undefined, but also allows sorting by an object property.
         *
         * @param {Mixed} `a` First value to compare.
         * @param {Mixed} `b` Second value to compare.
         * @param {String} `prop` Optional property to use when comparing objects. If specified must be a string.
         * @return {Number} Returns 1 when `a` should come after `b`, -1 when `a` should come before `b`, and 0 when `a` and `b` are equal.
         * @api public
         */

        module.exports = function defaultCompare(a, b, prop) {
          if (prop != null && typeOf(prop) !== "string") {
            throw new TypeError('expected "prop" to be undefined or a string');
          }

          var typeA = typeOf(a);
          var typeB = typeOf(b);

          if (prop) {
            if (typeA === "object") {
              a = a[prop];
              typeA = typeOf(a);
            }
            if (typeB === "object") {
              b = b[prop];
              typeB = typeOf(b);
            }
          }

          if (typeA === "null") {
            return typeB === "null" ? 0 : typeB === "undefined" ? -1 : 1;
          } else if (typeA === "undefined") {
            return typeB === "null" ? 1 : typeB === "undefined" ? 0 : 1;
          } else if (typeB === "null" || typeB === "undefined") {
            return -1;
          } else {
            return a < b ? -1 : a > b ? 1 : 0;
          }
        };
      },
      { "kind-of": 46 },
    ],
    46: [
      function (require, module, exports) {
        arguments[4][5][0].apply(exports, arguments);
      },
      { dup: 5 },
    ],
    47: [
      function (require, module, exports) {
        /*!
         * define-property <https://github.com/jonschlinkert/define-property>
         *
         * Copyright (c) 2015, 2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var isDescriptor = require("is-descriptor");

        module.exports = function defineProperty(obj, prop, val) {
          if (typeof obj !== "object" && typeof obj !== "function") {
            throw new TypeError("expected an object or function.");
          }

          if (typeof prop !== "string") {
            throw new TypeError("expected `prop` to be a string.");
          }

          if (isDescriptor(val) && ("set" in val || "get" in val)) {
            return Object.defineProperty(obj, prop, val);
          }

          return Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: val,
          });
        };
      },
      { "is-descriptor": 117 },
    ],
    48: [
      function (require, module, exports) {
        (function (__filename) {
          (function () {
            "use strict";

            /**
             * Local dependencies
             */

            var compilers = require("./lib/compilers");
            var parsers = require("./lib/parsers");

            /**
             * Module dependencies
             */

            var debug = require("debug")("expand-brackets");
            var extend = require("extend-shallow");
            var Snapdragon = require("snapdragon");
            var toRegex = require("to-regex");

            /**
             * Parses the given POSIX character class `pattern` and returns a
             * string that can be used for creating regular expressions for matching.
             *
             * @param {String} `pattern`
             * @param {Object} `options`
             * @return {Object}
             * @api public
             */

            function brackets(pattern, options) {
              debug("initializing from <%s>", __filename);
              var res = brackets.create(pattern, options);
              return res.output;
            }

            /**
             * Takes an array of strings and a POSIX character class pattern, and returns a new
             * array with only the strings that matched the pattern.
             *
             * ```js
             * var brackets = require('expand-brackets');
             * console.log(brackets.match(['1', 'a', 'ab'], '[[:alpha:]]'));
             * //=> ['a']
             *
             * console.log(brackets.match(['1', 'a', 'ab'], '[[:alpha:]]+'));
             * //=> ['a', 'ab']
             * ```
             * @param {Array} `arr` Array of strings to match
             * @param {String} `pattern` POSIX character class pattern(s)
             * @param {Object} `options`
             * @return {Array}
             * @api public
             */

            brackets.match = function (arr, pattern, options) {
              arr = [].concat(arr);
              var opts = extend({}, options);
              var isMatch = brackets.matcher(pattern, opts);
              var len = arr.length;
              var idx = -1;
              var res = [];

              while (++idx < len) {
                var ele = arr[idx];
                if (isMatch(ele)) {
                  res.push(ele);
                }
              }

              if (res.length === 0) {
                if (opts.failglob === true) {
                  throw new Error('no matches found for "' + pattern + '"');
                }

                if (opts.nonull === true || opts.nullglob === true) {
                  return [pattern.split("\\").join("")];
                }
              }
              return res;
            };

            /**
             * Returns true if the specified `string` matches the given
             * brackets `pattern`.
             *
             * ```js
             * var brackets = require('expand-brackets');
             *
             * console.log(brackets.isMatch('a.a', '[[:alpha:]].[[:alpha:]]'));
             * //=> true
             * console.log(brackets.isMatch('1.2', '[[:alpha:]].[[:alpha:]]'));
             * //=> false
             * ```
             * @param {String} `string` String to match
             * @param {String} `pattern` Poxis pattern
             * @param {String} `options`
             * @return {Boolean}
             * @api public
             */

            brackets.isMatch = function (str, pattern, options) {
              return brackets.matcher(pattern, options)(str);
            };

            /**
             * Takes a POSIX character class pattern and returns a matcher function. The returned
             * function takes the string to match as its only argument.
             *
             * ```js
             * var brackets = require('expand-brackets');
             * var isMatch = brackets.matcher('[[:lower:]].[[:upper:]]');
             *
             * console.log(isMatch('a.a'));
             * //=> false
             * console.log(isMatch('a.A'));
             * //=> true
             * ```
             * @param {String} `pattern` Poxis pattern
             * @param {String} `options`
             * @return {Boolean}
             * @api public
             */

            brackets.matcher = function (pattern, options) {
              var re = brackets.makeRe(pattern, options);
              return function (str) {
                return re.test(str);
              };
            };

            /**
             * Create a regular expression from the given `pattern`.
             *
             * ```js
             * var brackets = require('expand-brackets');
             * var re = brackets.makeRe('[[:alpha:]]');
             * console.log(re);
             * //=> /^(?:[a-zA-Z])$/
             * ```
             * @param {String} `pattern` The pattern to convert to regex.
             * @param {Object} `options`
             * @return {RegExp}
             * @api public
             */

            brackets.makeRe = function (pattern, options) {
              var res = brackets.create(pattern, options);
              var opts = extend({ strictErrors: false }, options);
              return toRegex(res.output, opts);
            };

            /**
             * Parses the given POSIX character class `pattern` and returns an object
             * with the compiled `output` and optional source `map`.
             *
             * ```js
             * var brackets = require('expand-brackets');
             * console.log(brackets('[[:alpha:]]'));
             * // { options: { source: 'string' },
             * //   input: '[[:alpha:]]',
             * //   state: {},
             * //   compilers:
             * //    { eos: [Function],
             * //      noop: [Function],
             * //      bos: [Function],
             * //      not: [Function],
             * //      escape: [Function],
             * //      text: [Function],
             * //      posix: [Function],
             * //      bracket: [Function],
             * //      'bracket.open': [Function],
             * //      'bracket.inner': [Function],
             * //      'bracket.literal': [Function],
             * //      'bracket.close': [Function] },
             * //   output: '[a-zA-Z]',
             * //   ast:
             * //    { type: 'root',
             * //      errors: [],
             * //      nodes: [ [Object], [Object], [Object] ] },
             * //   parsingErrors: [] }
             * ```
             * @param {String} `pattern`
             * @param {Object} `options`
             * @return {Object}
             * @api public
             */

            brackets.create = function (pattern, options) {
              var snapdragon =
                (options && options.snapdragon) || new Snapdragon(options);
              compilers(snapdragon);
              parsers(snapdragon);

              var ast = snapdragon.parse(pattern, options);
              ast.input = pattern;
              var res = snapdragon.compile(ast, options);
              res.input = pattern;
              return res;
            };

            /**
             * Expose `brackets` constructor, parsers and compilers
             */

            brackets.compilers = compilers;
            brackets.parsers = parsers;

            /**
             * Expose `brackets`
             * @type {Function}
             */

            module.exports = brackets;
          }.call(this));
        }.call(this, "/node_modules/expand-brackets/index.js"));
      },
      {
        "./lib/compilers": 49,
        "./lib/parsers": 50,
        debug: 52,
        "extend-shallow": 61,
        snapdragon: 204,
        "to-regex": 248,
      },
    ],
    49: [
      function (require, module, exports) {
        "use strict";

        var posix = require("posix-character-classes");

        module.exports = function (brackets) {
          brackets.compiler

            /**
             * Escaped characters
             */

            .set("escape", function (node) {
              return this.emit("\\" + node.val.replace(/^\\/, ""), node);
            })

            /**
             * Text
             */

            .set("text", function (node) {
              return this.emit(node.val.replace(/([{}])/g, "\\$1"), node);
            })

            /**
             * POSIX character classes
             */

            .set("posix", function (node) {
              if (node.val === "[::]") {
                return this.emit("\\[::\\]", node);
              }

              var val = posix[node.inner];
              if (typeof val === "undefined") {
                val = "[" + node.inner + "]";
              }
              return this.emit(val, node);
            })

            /**
             * Non-posix brackets
             */

            .set("bracket", function (node) {
              return this.mapVisit(node.nodes);
            })
            .set("bracket.open", function (node) {
              return this.emit(node.val, node);
            })
            .set("bracket.inner", function (node) {
              var inner = node.val;

              if (inner === "[" || inner === "]") {
                return this.emit("\\" + node.val, node);
              }
              if (inner === "^]") {
                return this.emit("^\\]", node);
              }
              if (inner === "^") {
                return this.emit("^", node);
              }

              if (/-/.test(inner) && !/(\d-\d|\w-\w)/.test(inner)) {
                inner = inner.split("-").join("\\-");
              }

              var isNegated = inner.charAt(0) === "^";
              // add slashes to negated brackets, per spec
              if (isNegated && inner.indexOf("/") === -1) {
                inner += "/";
              }
              if (isNegated && inner.indexOf(".") === -1) {
                inner += ".";
              }

              // don't unescape `0` (octal literal)
              inner = inner.replace(/\\([1-9])/g, "$1");
              return this.emit(inner, node);
            })
            .set("bracket.close", function (node) {
              var val = node.val.replace(/^\\/, "");
              if (node.parent.escaped === true) {
                return this.emit("\\" + val, node);
              }
              return this.emit(val, node);
            });
        };
      },
      { "posix-character-classes": 178 },
    ],
    50: [
      function (require, module, exports) {
        "use strict";

        var utils = require("./utils");
        var define = require("define-property");

        /**
         * Text regex
         */

        var TEXT_REGEX = "(\\[(?=.*\\])|\\])+";
        var not = utils.createRegex(TEXT_REGEX);

        /**
         * Brackets parsers
         */

        function parsers(brackets) {
          brackets.state = brackets.state || {};
          brackets.parser.sets.bracket = brackets.parser.sets.bracket || [];
          brackets.parser

            .capture("escape", function () {
              if (this.isInside("bracket")) return;
              var pos = this.position();
              var m = this.match(/^\\(.)/);
              if (!m) return;

              return pos({
                type: "escape",
                val: m[0],
              });
            })

            /**
             * Text parser
             */

            .capture("text", function () {
              if (this.isInside("bracket")) return;
              var pos = this.position();
              var m = this.match(not);
              if (!m || !m[0]) return;

              return pos({
                type: "text",
                val: m[0],
              });
            })

            /**
             * POSIX character classes: "[[:alpha:][:digits:]]"
             */

            .capture("posix", function () {
              var pos = this.position();
              var m = this.match(/^\[:(.*?):\](?=.*\])/);
              if (!m) return;

              var inside = this.isInside("bracket");
              if (inside) {
                brackets.posix++;
              }

              return pos({
                type: "posix",
                insideBracket: inside,
                inner: m[1],
                val: m[0],
              });
            })

            /**
             * Bracket (noop)
             */

            .capture("bracket", function () {})

            /**
             * Open: '['
             */

            .capture("bracket.open", function () {
              var parsed = this.parsed;
              var pos = this.position();
              var m = this.match(/^\[(?=.*\])/);
              if (!m) return;

              var prev = this.prev();
              var last = utils.last(prev.nodes);

              if (parsed.slice(-1) === "\\" && !this.isInside("bracket")) {
                last.val = last.val.slice(0, last.val.length - 1);
                return pos({
                  type: "escape",
                  val: m[0],
                });
              }

              var open = pos({
                type: "bracket.open",
                val: m[0],
              });

              if (last.type === "bracket.open" || this.isInside("bracket")) {
                open.val = "\\" + open.val;
                open.type = "bracket.inner";
                open.escaped = true;
                return open;
              }

              var node = pos({
                type: "bracket",
                nodes: [open],
              });

              define(node, "parent", prev);
              define(open, "parent", node);
              this.push("bracket", node);
              prev.nodes.push(node);
            })

            /**
             * Bracket text
             */

            .capture("bracket.inner", function () {
              if (!this.isInside("bracket")) return;
              var pos = this.position();
              var m = this.match(not);
              if (!m || !m[0]) return;

              var next = this.input.charAt(0);
              var val = m[0];

              var node = pos({
                type: "bracket.inner",
                val: val,
              });

              if (val === "\\\\") {
                return node;
              }

              var first = val.charAt(0);
              var last = val.slice(-1);

              if (first === "!") {
                val = "^" + val.slice(1);
              }

              if (last === "\\" || (val === "^" && next === "]")) {
                val += this.input[0];
                this.consume(1);
              }

              node.val = val;
              return node;
            })

            /**
             * Close: ']'
             */

            .capture("bracket.close", function () {
              var parsed = this.parsed;
              var pos = this.position();
              var m = this.match(/^\]/);
              if (!m) return;

              var prev = this.prev();
              var last = utils.last(prev.nodes);

              if (parsed.slice(-1) === "\\" && !this.isInside("bracket")) {
                last.val = last.val.slice(0, last.val.length - 1);

                return pos({
                  type: "escape",
                  val: m[0],
                });
              }

              var node = pos({
                type: "bracket.close",
                rest: this.input,
                val: m[0],
              });

              if (last.type === "bracket.open") {
                node.type = "bracket.inner";
                node.escaped = true;
                return node;
              }

              var bracket = this.pop("bracket");
              if (!this.isType(bracket, "bracket")) {
                if (this.options.strict) {
                  throw new Error('missing opening "["');
                }
                node.type = "bracket.inner";
                node.escaped = true;
                return node;
              }

              bracket.nodes.push(node);
              define(node, "parent", bracket);
            });
        }

        /**
         * Brackets parsers
         */

        module.exports = parsers;

        /**
         * Expose text regex
         */

        module.exports.TEXT_REGEX = TEXT_REGEX;
      },
      { "./utils": 51, "define-property": 54 },
    ],
    51: [
      function (require, module, exports) {
        "use strict";

        var toRegex = require("to-regex");
        var regexNot = require("regex-not");
        var cached;

        /**
         * Get the last element from `array`
         * @param {Array} `array`
         * @return {*}
         */

        exports.last = function (arr) {
          return arr[arr.length - 1];
        };

        /**
         * Create and cache regex to use for text nodes
         */

        exports.createRegex = function (pattern, include) {
          if (cached) return cached;
          var opts = { contains: true, strictClose: false };
          var not = regexNot.create(pattern, opts);
          var re;

          if (typeof include === "string") {
            re = toRegex("^(?:" + include + "|" + not + ")", opts);
          } else {
            re = toRegex(not, opts);
          }

          return (cached = re);
        };
      },
      { "regex-not": 184, "to-regex": 248 },
    ],
    52: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            /**
             * This is the web browser implementation of `debug()`.
             *
             * Expose `debug()` as the module.
             */

            exports = module.exports = require("./debug");
            exports.log = log;
            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.storage =
              "undefined" != typeof chrome &&
              "undefined" != typeof chrome.storage
                ? chrome.storage.local
                : localstorage();

            /**
             * Colors.
             */

            exports.colors = [
              "lightseagreen",
              "forestgreen",
              "goldenrod",
              "dodgerblue",
              "darkorchid",
              "crimson",
            ];

            /**
             * Currently only WebKit-based Web Inspectors, Firefox >= v31,
             * and the Firebug extension (any Firefox version) are known
             * to support "%c" CSS customizations.
             *
             * TODO: add a `localStorage` variable to explicitly enable/disable colors
             */

            function useColors() {
              // NB: In an Electron preload script, document will be defined but not fully
              // initialized. Since we know we're in Chrome, we'll just detect this case
              // explicitly
              if (
                typeof window !== "undefined" &&
                window.process &&
                window.process.type === "renderer"
              ) {
                return true;
              }

              // is webkit? http://stackoverflow.com/a/16459606/376773
              // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
              return (
                (typeof document !== "undefined" &&
                  document.documentElement &&
                  document.documentElement.style &&
                  document.documentElement.style.WebkitAppearance) ||
                // is firebug? http://stackoverflow.com/a/398120/376773
                (typeof window !== "undefined" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                // is firefox >= v31?
                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                (typeof navigator !== "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                // double check webkit in userAgent just in case we are in a worker
                (typeof navigator !== "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
              );
            }

            /**
             * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
             */

            exports.formatters.j = function (v) {
              try {
                return JSON.stringify(v);
              } catch (err) {
                return "[UnexpectedJSONParseError]: " + err.message;
              }
            };

            /**
             * Colorize log arguments if enabled.
             *
             * @api public
             */

            function formatArgs(args) {
              var useColors = this.useColors;

              args[0] =
                (useColors ? "%c" : "") +
                this.namespace +
                (useColors ? " %c" : " ") +
                args[0] +
                (useColors ? "%c " : " ") +
                "+" +
                exports.humanize(this.diff);

              if (!useColors) return;

              var c = "color: " + this.color;
              args.splice(1, 0, c, "color: inherit");

              // the final "%c" is somewhat tricky, because there could be other
              // arguments passed either before or after the %c, so we need to
              // figure out the correct index to insert the CSS into
              var index = 0;
              var lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, function (match) {
                if ("%%" === match) return;
                index++;
                if ("%c" === match) {
                  // we only are interested in the *last* %c
                  // (the user may have provided their own)
                  lastC = index;
                }
              });

              args.splice(lastC, 0, c);
            }

            /**
             * Invokes `console.log()` when available.
             * No-op when `console.log` is not a "function".
             *
             * @api public
             */

            function log() {
              // this hackery is required for IE8/9, where
              // the `console.log` function doesn't have 'apply'
              return (
                "object" === typeof console &&
                console.log &&
                Function.prototype.apply.call(console.log, console, arguments)
              );
            }

            /**
             * Save `namespaces`.
             *
             * @param {String} namespaces
             * @api private
             */

            function save(namespaces) {
              try {
                if (null == namespaces) {
                  exports.storage.removeItem("debug");
                } else {
                  exports.storage.debug = namespaces;
                }
              } catch (e) {}
            }

            /**
             * Load `namespaces`.
             *
             * @return {String} returns the previously persisted debug modes
             * @api private
             */

            function load() {
              var r;
              try {
                r = exports.storage.debug;
              } catch (e) {}

              // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
              if (!r && typeof process !== "undefined" && "env" in process) {
                r = process.env.DEBUG;
              }

              return r;
            }

            /**
             * Enable namespaces listed in `localStorage.debug` initially.
             */

            exports.enable(load());

            /**
             * Localstorage attempts to return the localstorage.
             *
             * This is necessary because safari throws
             * when a user disables cookies/localstorage
             * and you attempt to access it.
             *
             * @return {LocalStorage}
             * @api private
             */

            function localstorage() {
              try {
                return window.localStorage;
              } catch (e) {}
            }
          }.call(this));
        }.call(this, require("_process")));
      },
      { "./debug": 53, _process: 179 },
    ],
    53: [
      function (require, module, exports) {
        /**
         * This is the common logic for both the Node.js and web browser
         * implementations of `debug()`.
         *
         * Expose `debug()` as the module.
         */

        exports =
          module.exports =
          createDebug.debug =
          createDebug["default"] =
            createDebug;
        exports.coerce = coerce;
        exports.disable = disable;
        exports.enable = enable;
        exports.enabled = enabled;
        exports.humanize = require("ms");

        /**
         * The currently active debug mode names, and names to skip.
         */

        exports.names = [];
        exports.skips = [];

        /**
         * Map of special "%n" handling functions, for the debug "format" argument.
         *
         * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
         */

        exports.formatters = {};

        /**
         * Previous log timestamp.
         */

        var prevTime;

        /**
         * Select a color.
         * @param {String} namespace
         * @return {Number}
         * @api private
         */

        function selectColor(namespace) {
          var hash = 0,
            i;

          for (i in namespace) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
          }

          return exports.colors[Math.abs(hash) % exports.colors.length];
        }

        /**
         * Create a debugger with the given `namespace`.
         *
         * @param {String} namespace
         * @return {Function}
         * @api public
         */

        function createDebug(namespace) {
          function debug() {
            // disabled?
            if (!debug.enabled) return;

            var self = debug;

            // set `diff` timestamp
            var curr = +new Date();
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;

            // turn the `arguments` into a proper Array
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
              args[i] = arguments[i];
            }

            args[0] = exports.coerce(args[0]);

            if ("string" !== typeof args[0]) {
              // anything else let's inspect with %O
              args.unshift("%O");
            }

            // apply any `formatters` transformations
            var index = 0;
            args[0] = args[0].replace(
              /%([a-zA-Z%])/g,
              function (match, format) {
                // if we encounter an escaped % then don't increase the array index
                if (match === "%%") return match;
                index++;
                var formatter = exports.formatters[format];
                if ("function" === typeof formatter) {
                  var val = args[index];
                  match = formatter.call(self, val);

                  // now we need to remove `args[index]` since it's inlined in the `format`
                  args.splice(index, 1);
                  index--;
                }
                return match;
              }
            );

            // apply env-specific formatting (colors, etc.)
            exports.formatArgs.call(self, args);

            var logFn = debug.log || exports.log || console.log.bind(console);
            logFn.apply(self, args);
          }

          debug.namespace = namespace;
          debug.enabled = exports.enabled(namespace);
          debug.useColors = exports.useColors();
          debug.color = selectColor(namespace);

          // env-specific initialization logic for debug instances
          if ("function" === typeof exports.init) {
            exports.init(debug);
          }

          return debug;
        }

        /**
         * Enables a debug mode by namespaces. This can include modes
         * separated by a colon and wildcards.
         *
         * @param {String} namespaces
         * @api public
         */

        function enable(namespaces) {
          exports.save(namespaces);

          exports.names = [];
          exports.skips = [];

          var split = (typeof namespaces === "string" ? namespaces : "").split(
            /[\s,]+/
          );
          var len = split.length;

          for (var i = 0; i < len; i++) {
            if (!split[i]) continue; // ignore empty strings
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              exports.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }

        /**
         * Disable debug output.
         *
         * @api public
         */

        function disable() {
          exports.enable("");
        }

        /**
         * Returns true if the given mode name is enabled, false otherwise.
         *
         * @param {String} name
         * @return {Boolean}
         * @api public
         */

        function enabled(name) {
          var i, len;
          for (i = 0, len = exports.skips.length; i < len; i++) {
            if (exports.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = exports.names.length; i < len; i++) {
            if (exports.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }

        /**
         * Coerce `val`.
         *
         * @param {Mixed} val
         * @return {Mixed}
         * @api private
         */

        function coerce(val) {
          if (val instanceof Error) return val.stack || val.message;
          return val;
        }
      },
      { ms: 158 },
    ],
    54: [
      function (require, module, exports) {
        arguments[4][15][0].apply(exports, arguments);
      },
      { dup: 15, "is-descriptor": 59 },
    ],
    55: [
      function (require, module, exports) {
        arguments[4][16][0].apply(exports, arguments);
      },
      { dup: 16, "kind-of": 56 },
    ],
    56: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    57: [
      function (require, module, exports) {
        arguments[4][18][0].apply(exports, arguments);
      },
      { dup: 18, "kind-of": 58 },
    ],
    58: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    59: [
      function (require, module, exports) {
        arguments[4][20][0].apply(exports, arguments);
      },
      {
        dup: 20,
        "is-accessor-descriptor": 55,
        "is-data-descriptor": 57,
        "kind-of": 60,
      },
    ],
    60: [
      function (require, module, exports) {
        arguments[4][5][0].apply(exports, arguments);
      },
      { dup: 5 },
    ],
    61: [
      function (require, module, exports) {
        "use strict";

        var isObject = require("is-extendable");

        module.exports = function extend(o /*, objects*/) {
          if (!isObject(o)) {
            o = {};
          }

          var len = arguments.length;
          for (var i = 1; i < len; i++) {
            var obj = arguments[i];

            if (isObject(obj)) {
              assign(o, obj);
            }
          }
          return o;
        };

        function assign(a, b) {
          for (var key in b) {
            if (hasOwn(b, key)) {
              a[key] = b[key];
            }
          }
        }

        /**
         * Returns true if the given `key` is an own property of `obj`.
         */

        function hasOwn(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        }
      },
      { "is-extendable": 119 },
    ],
    62: [
      function (require, module, exports) {
        "use strict";

        /**
         * Module dependencies
         */

        var extend = require("extend-shallow");
        var unique = require("array-unique");
        var toRegex = require("to-regex");

        /**
         * Local dependencies
         */

        var compilers = require("./lib/compilers");
        var parsers = require("./lib/parsers");
        var Extglob = require("./lib/extglob");
        var utils = require("./lib/utils");
        var MAX_LENGTH = 1024 * 64;

        /**
         * Convert the given `extglob` pattern into a regex-compatible string. Returns
         * an object with the compiled result and the parsed AST.
         *
         * ```js
         * var extglob = require('extglob');
         * console.log(extglob('*.!(*a)'));
         * //=> '(?!\\.)[^/]*?\\.(?!(?!\\.)[^/]*?a\\b).*?'
         * ```
         * @param {String} `pattern`
         * @param {Object} `options`
         * @return {String}
         * @api public
         */

        function extglob(pattern, options) {
          return extglob.create(pattern, options).output;
        }

        /**
         * Takes an array of strings and an extglob pattern and returns a new
         * array that contains only the strings that match the pattern.
         *
         * ```js
         * var extglob = require('extglob');
         * console.log(extglob.match(['a.a', 'a.b', 'a.c'], '*.!(*a)'));
         * //=> ['a.b', 'a.c']
         * ```
         * @param {Array} `list` Array of strings to match
         * @param {String} `pattern` Extglob pattern
         * @param {Object} `options`
         * @return {Array} Returns an array of matches
         * @api public
         */

        extglob.match = function (list, pattern, options) {
          if (typeof pattern !== "string") {
            throw new TypeError("expected pattern to be a string");
          }

          list = utils.arrayify(list);
          var isMatch = extglob.matcher(pattern, options);
          var len = list.length;
          var idx = -1;
          var matches = [];

          while (++idx < len) {
            var ele = list[idx];

            if (isMatch(ele)) {
              matches.push(ele);
            }
          }

          // if no options were passed, uniquify results and return
          if (typeof options === "undefined") {
            return unique(matches);
          }

          if (matches.length === 0) {
            if (options.failglob === true) {
              throw new Error('no matches found for "' + pattern + '"');
            }
            if (options.nonull === true || options.nullglob === true) {
              return [pattern.split("\\").join("")];
            }
          }

          return options.nodupes !== false ? unique(matches) : matches;
        };

        /**
         * Returns true if the specified `string` matches the given
         * extglob `pattern`.
         *
         * ```js
         * var extglob = require('extglob');
         *
         * console.log(extglob.isMatch('a.a', '*.!(*a)'));
         * //=> false
         * console.log(extglob.isMatch('a.b', '*.!(*a)'));
         * //=> true
         * ```
         * @param {String} `string` String to match
         * @param {String} `pattern` Extglob pattern
         * @param {String} `options`
         * @return {Boolean}
         * @api public
         */

        extglob.isMatch = function (str, pattern, options) {
          if (typeof pattern !== "string") {
            throw new TypeError("expected pattern to be a string");
          }

          if (typeof str !== "string") {
            throw new TypeError("expected a string");
          }

          if (pattern === str) {
            return true;
          }

          if (pattern === "" || pattern === " " || pattern === ".") {
            return pattern === str;
          }

          var isMatch = utils.memoize(
            "isMatch",
            pattern,
            options,
            extglob.matcher
          );
          return isMatch(str);
        };

        /**
         * Returns true if the given `string` contains the given pattern. Similar to `.isMatch` but
         * the pattern can match any part of the string.
         *
         * ```js
         * var extglob = require('extglob');
         * console.log(extglob.contains('aa/bb/cc', '*b'));
         * //=> true
         * console.log(extglob.contains('aa/bb/cc', '*d'));
         * //=> false
         * ```
         * @param {String} `str` The string to match.
         * @param {String} `pattern` Glob pattern to use for matching.
         * @param {Object} `options`
         * @return {Boolean} Returns true if the patter matches any part of `str`.
         * @api public
         */

        extglob.contains = function (str, pattern, options) {
          if (typeof str !== "string") {
            throw new TypeError("expected a string");
          }

          if (pattern === "" || pattern === " " || pattern === ".") {
            return pattern === str;
          }

          var opts = extend({}, options, { contains: true });
          opts.strictClose = false;
          opts.strictOpen = false;
          return extglob.isMatch(str, pattern, opts);
        };

        /**
         * Takes an extglob pattern and returns a matcher function. The returned
         * function takes the string to match as its only argument.
         *
         * ```js
         * var extglob = require('extglob');
         * var isMatch = extglob.matcher('*.!(*a)');
         *
         * console.log(isMatch('a.a'));
         * //=> false
         * console.log(isMatch('a.b'));
         * //=> true
         * ```
         * @param {String} `pattern` Extglob pattern
         * @param {String} `options`
         * @return {Boolean}
         * @api public
         */

        extglob.matcher = function (pattern, options) {
          if (typeof pattern !== "string") {
            throw new TypeError("expected pattern to be a string");
          }

          function matcher() {
            var re = extglob.makeRe(pattern, options);
            return function (str) {
              return re.test(str);
            };
          }

          return utils.memoize("matcher", pattern, options, matcher);
        };

        /**
         * Convert the given `extglob` pattern into a regex-compatible string. Returns
         * an object with the compiled result and the parsed AST.
         *
         * ```js
         * var extglob = require('extglob');
         * console.log(extglob.create('*.!(*a)').output);
         * //=> '(?!\\.)[^/]*?\\.(?!(?!\\.)[^/]*?a\\b).*?'
         * ```
         * @param {String} `str`
         * @param {Object} `options`
         * @return {String}
         * @api public
         */

        extglob.create = function (pattern, options) {
          if (typeof pattern !== "string") {
            throw new TypeError("expected pattern to be a string");
          }

          function create() {
            var ext = new Extglob(options);
            var ast = ext.parse(pattern, options);
            return ext.compile(ast, options);
          }

          return utils.memoize("create", pattern, options, create);
        };

        /**
         * Returns an array of matches captured by `pattern` in `string`, or `null`
         * if the pattern did not match.
         *
         * ```js
         * var extglob = require('extglob');
         * extglob.capture(pattern, string[, options]);
         *
         * console.log(extglob.capture('test/*.js', 'test/foo.js'));
         * //=> ['foo']
         * console.log(extglob.capture('test/*.js', 'foo/bar.css'));
         * //=> null
         * ```
         * @param {String} `pattern` Glob pattern to use for matching.
         * @param {String} `string` String to match
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
         * @api public
         */

        extglob.capture = function (pattern, str, options) {
          var re = extglob.makeRe(pattern, extend({ capture: true }, options));

          function match() {
            return function (string) {
              var match = re.exec(string);
              if (!match) {
                return null;
              }

              return match.slice(1);
            };
          }

          var capture = utils.memoize("capture", pattern, options, match);
          return capture(str);
        };

        /**
         * Create a regular expression from the given `pattern` and `options`.
         *
         * ```js
         * var extglob = require('extglob');
         * var re = extglob.makeRe('*.!(*a)');
         * console.log(re);
         * //=> /^[^\/]*?\.(?![^\/]*?a)[^\/]*?$/
         * ```
         * @param {String} `pattern` The pattern to convert to regex.
         * @param {Object} `options`
         * @return {RegExp}
         * @api public
         */

        extglob.makeRe = function (pattern, options) {
          if (pattern instanceof RegExp) {
            return pattern;
          }

          if (typeof pattern !== "string") {
            throw new TypeError("expected pattern to be a string");
          }

          if (pattern.length > MAX_LENGTH) {
            throw new Error(
              "expected pattern to be less than " + MAX_LENGTH + " characters"
            );
          }

          function makeRe() {
            var opts = extend({ strictErrors: false }, options);
            if (opts.strictErrors === true) opts.strict = true;
            var res = extglob.create(pattern, opts);
            return toRegex(res.output, opts);
          }

          var regex = utils.memoize("makeRe", pattern, options, makeRe);
          if (regex.source.length > MAX_LENGTH) {
            throw new SyntaxError("potentially malicious regex detected");
          }

          return regex;
        };

        /**
         * Cache
         */

        extglob.cache = utils.cache;
        extglob.clearCache = function () {
          extglob.cache.__data__ = {};
        };

        /**
         * Expose `Extglob` constructor, parsers and compilers
         */

        extglob.Extglob = Extglob;
        extglob.compilers = compilers;
        extglob.parsers = parsers;

        /**
         * Expose `extglob`
         * @type {Function}
         */

        module.exports = extglob;
      },
      {
        "./lib/compilers": 63,
        "./lib/extglob": 64,
        "./lib/parsers": 65,
        "./lib/utils": 66,
        "array-unique": 6,
        "extend-shallow": 61,
        "to-regex": 248,
      },
    ],
    63: [
      function (require, module, exports) {
        "use strict";

        var brackets = require("expand-brackets");

        /**
         * Extglob compilers
         */

        module.exports = function (extglob) {
          function star() {
            if (typeof extglob.options.star === "function") {
              return extglob.options.star.apply(this, arguments);
            }
            if (typeof extglob.options.star === "string") {
              return extglob.options.star;
            }
            return ".*?";
          }

          /**
           * Use `expand-brackets` compilers
           */

          extglob.use(brackets.compilers);
          extglob.compiler

            /**
             * Escaped: "\\*"
             */

            .set("escape", function (node) {
              return this.emit(node.val, node);
            })

            /**
             * Dot: "."
             */

            .set("dot", function (node) {
              return this.emit("\\" + node.val, node);
            })

            /**
             * Question mark: "?"
             */

            .set("qmark", function (node) {
              var val = "[^\\\\/.]";
              var prev = this.prev();

              if (node.parsed.slice(-1) === "(") {
                var ch = node.rest.charAt(0);
                if (ch !== "!" && ch !== "=" && ch !== ":") {
                  return this.emit(val, node);
                }
                return this.emit(node.val, node);
              }

              if (prev.type === "text" && prev.val) {
                return this.emit(val, node);
              }

              if (node.val.length > 1) {
                val += "{" + node.val.length + "}";
              }
              return this.emit(val, node);
            })

            /**
             * Plus: "+"
             */

            .set("plus", function (node) {
              var prev = node.parsed.slice(-1);
              if (prev === "]" || prev === ")") {
                return this.emit(node.val, node);
              }
              var ch = this.output.slice(-1);
              if (
                !this.output ||
                (/[?*+]/.test(ch) && node.parent.type !== "bracket")
              ) {
                return this.emit("\\+", node);
              }
              if (/\w/.test(ch) && !node.inside) {
                return this.emit("+\\+?", node);
              }
              return this.emit("+", node);
            })

            /**
             * Star: "*"
             */

            .set("star", function (node) {
              var prev = this.prev();
              var prefix =
                prev.type !== "text" && prev.type !== "escape" ? "(?!\\.)" : "";

              return this.emit(prefix + star.call(this, node), node);
            })

            /**
             * Parens
             */

            .set("paren", function (node) {
              return this.mapVisit(node.nodes);
            })
            .set("paren.open", function (node) {
              var capture = this.options.capture ? "(" : "";

              switch (node.parent.prefix) {
                case "!":
                case "^":
                  return this.emit(capture + "(?:(?!(?:", node);
                case "*":
                case "+":
                case "?":
                case "@":
                  return this.emit(capture + "(?:", node);
                default: {
                  var val = node.val;
                  if (this.options.bash === true) {
                    val = "\\" + val;
                  } else if (
                    !this.options.capture &&
                    val === "(" &&
                    node.parent.rest[0] !== "?"
                  ) {
                    val += "?:";
                  }

                  return this.emit(val, node);
                }
              }
            })
            .set("paren.close", function (node) {
              var capture = this.options.capture ? ")" : "";

              switch (node.prefix) {
                case "!":
                case "^":
                  var prefix = /^(\)|$)/.test(node.rest) ? "$" : "";
                  var str = star.call(this, node);

                  // if the extglob has a slash explicitly defined, we know the user wants
                  // to match slashes, so we need to ensure the "star" regex allows for it
                  if (
                    node.parent.hasSlash &&
                    !this.options.star &&
                    this.options.slash !== false
                  ) {
                    str = ".*?";
                  }

                  return this.emit(prefix + ("))" + str + ")") + capture, node);
                case "*":
                case "+":
                case "?":
                  return this.emit(")" + node.prefix + capture, node);
                case "@":
                  return this.emit(")" + capture, node);
                default: {
                  var val = (this.options.bash === true ? "\\" : "") + ")";
                  return this.emit(val, node);
                }
              }
            })

            /**
             * Text
             */

            .set("text", function (node) {
              var val = node.val.replace(/[\[\]]/g, "\\$&");
              return this.emit(val, node);
            });
        };
      },
      { "expand-brackets": 48 },
    ],
    64: [
      function (require, module, exports) {
        "use strict";

        /**
         * Module dependencies
         */

        var Snapdragon = require("snapdragon");
        var define = require("define-property");
        var extend = require("extend-shallow");

        /**
         * Local dependencies
         */

        var compilers = require("./compilers");
        var parsers = require("./parsers");

        /**
         * Customize Snapdragon parser and renderer
         */

        function Extglob(options) {
          this.options = extend({ source: "extglob" }, options);
          this.snapdragon =
            this.options.snapdragon || new Snapdragon(this.options);
          this.snapdragon.patterns = this.snapdragon.patterns || {};
          this.compiler = this.snapdragon.compiler;
          this.parser = this.snapdragon.parser;

          compilers(this.snapdragon);
          parsers(this.snapdragon);

          /**
           * Override Snapdragon `.parse` method
           */

          define(this.snapdragon, "parse", function (str, options) {
            var parsed = Snapdragon.prototype.parse.apply(this, arguments);
            parsed.input = str;

            // escape unmatched brace/bracket/parens
            var last = this.parser.stack.pop();
            if (last && this.options.strict !== true) {
              var node = last.nodes[0];
              node.val = "\\" + node.val;
              var sibling = node.parent.nodes[1];
              if (sibling.type === "star") {
                sibling.loose = true;
              }
            }

            // add non-enumerable parser reference
            define(parsed, "parser", this.parser);
            return parsed;
          });

          /**
           * Decorate `.parse` method
           */

          define(this, "parse", function (ast, options) {
            return this.snapdragon.parse.apply(this.snapdragon, arguments);
          });

          /**
           * Decorate `.compile` method
           */

          define(this, "compile", function (ast, options) {
            return this.snapdragon.compile.apply(this.snapdragon, arguments);
          });
        }

        /**
         * Expose `Extglob`
         */

        module.exports = Extglob;
      },
      {
        "./compilers": 63,
        "./parsers": 65,
        "define-property": 47,
        "extend-shallow": 61,
        snapdragon: 204,
      },
    ],
    65: [
      function (require, module, exports) {
        "use strict";

        var brackets = require("expand-brackets");
        var define = require("define-property");
        var utils = require("./utils");

        /**
         * Characters to use in text regex (we want to "not" match
         * characters that are matched by other parsers)
         */

        var TEXT_REGEX = "([!@*?+]?\\(|\\)|[*?.+\\\\]|\\[:?(?=.*\\])|:?\\])+";
        var not = utils.createRegex(TEXT_REGEX);

        /**
         * Extglob parsers
         */

        function parsers(extglob) {
          extglob.state = extglob.state || {};

          /**
           * Use `expand-brackets` parsers
           */

          extglob.use(brackets.parsers);
          extglob.parser.sets.paren = extglob.parser.sets.paren || [];
          extglob.parser

            /**
             * Extglob open: "*("
             */

            .capture("paren.open", function () {
              var parsed = this.parsed;
              var pos = this.position();
              var m = this.match(/^([!@*?+])?\(/);
              if (!m) return;

              var prev = this.prev();
              var prefix = m[1];
              var val = m[0];

              var open = pos({
                type: "paren.open",
                parsed: parsed,
                val: val,
              });

              var node = pos({
                type: "paren",
                prefix: prefix,
                nodes: [open],
              });

              // if nested negation extglobs, just cancel them out to simplify
              if (
                prefix === "!" &&
                prev.type === "paren" &&
                prev.prefix === "!"
              ) {
                prev.prefix = "@";
                node.prefix = "@";
              }

              define(node, "rest", this.input);
              define(node, "parsed", parsed);
              define(node, "parent", prev);
              define(open, "parent", node);

              this.push("paren", node);
              prev.nodes.push(node);
            })

            /**
             * Extglob close: ")"
             */

            .capture("paren.close", function () {
              var parsed = this.parsed;
              var pos = this.position();
              var m = this.match(/^\)/);
              if (!m) return;

              var parent = this.pop("paren");
              var node = pos({
                type: "paren.close",
                rest: this.input,
                parsed: parsed,
                val: m[0],
              });

              if (!this.isType(parent, "paren")) {
                if (this.options.strict) {
                  throw new Error('missing opening paren: "("');
                }
                node.escaped = true;
                return node;
              }

              node.prefix = parent.prefix;
              parent.nodes.push(node);
              define(node, "parent", parent);
            })

            /**
             * Escape: "\\."
             */

            .capture("escape", function () {
              var pos = this.position();
              var m = this.match(/^\\(.)/);
              if (!m) return;

              return pos({
                type: "escape",
                val: m[0],
                ch: m[1],
              });
            })

            /**
             * Question marks: "?"
             */

            .capture("qmark", function () {
              var parsed = this.parsed;
              var pos = this.position();
              var m = this.match(/^\?+(?!\()/);
              if (!m) return;
              extglob.state.metachar = true;
              return pos({
                type: "qmark",
                rest: this.input,
                parsed: parsed,
                val: m[0],
              });
            })

            /**
             * Character parsers
             */

            .capture("star", /^\*(?!\()/)
            .capture("plus", /^\+(?!\()/)
            .capture("dot", /^\./)
            .capture("text", not);
        }

        /**
         * Expose text regex string
         */

        module.exports.TEXT_REGEX = TEXT_REGEX;

        /**
         * Extglob parsers
         */

        module.exports = parsers;
      },
      { "./utils": 66, "define-property": 47, "expand-brackets": 48 },
    ],
    66: [
      function (require, module, exports) {
        "use strict";

        var regex = require("regex-not");
        var Cache = require("fragment-cache");

        /**
         * Utils
         */

        var utils = module.exports;
        var cache = (utils.cache = new Cache());

        /**
         * Cast `val` to an array
         * @return {Array}
         */

        utils.arrayify = function (val) {
          if (!Array.isArray(val)) {
            return [val];
          }
          return val;
        };

        /**
         * Memoize a generated regex or function
         */

        utils.memoize = function (type, pattern, options, fn) {
          var key = utils.createKey(type + pattern, options);

          if (cache.has(type, key)) {
            return cache.get(type, key);
          }

          var val = fn(pattern, options);
          if (options && options.cache === false) {
            return val;
          }

          cache.set(type, key, val);
          return val;
        };

        /**
         * Create the key to use for memoization. The key is generated
         * by iterating over the options and concatenating key-value pairs
         * to the pattern string.
         */

        utils.createKey = function (pattern, options) {
          var key = pattern;
          if (typeof options === "undefined") {
            return key;
          }
          for (var prop in options) {
            key += ";" + prop + "=" + String(options[prop]);
          }
          return key;
        };

        /**
         * Create the regex to use for matching text
         */

        utils.createRegex = function (str) {
          var opts = { contains: true, strictClose: false };
          return regex(str, opts);
        };
      },
      { "fragment-cache": 72, "regex-not": 184 },
    ],
    67: [
      function (require, module, exports) {
        /*!
         * falsey <https://github.com/jonschlinkert/falsey>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var typeOf = require("kind-of");

        function falsey(val, keywords) {
          if (!val) return true;

          if (Array.isArray(val) || typeOf(val) === "arguments") {
            return !val.length;
          }

          if (typeOf(val) === "object") {
            return !Object.keys(val).length;
          }

          var arr = !keywords ? falsey.keywords : arrayify(keywords);

          return arr.indexOf(val.toLowerCase ? val.toLowerCase() : val) !== -1;
        }

        /**
         * Expose `keywords`
         */

        falsey.keywords = ["none", "nil", "nope", "no", "nada", "0", "false"];

        function arrayify(val) {
          return Array.isArray(val) ? val : [val];
        }

        module.exports = falsey;
      },
      { "kind-of": 68 },
    ],
    68: [
      function (require, module, exports) {
        arguments[4][5][0].apply(exports, arguments);
      },
      { dup: 5 },
    ],
    69: [
      function (require, module, exports) {
        "use strict";

        var isCallable = require("is-callable");

        var toStr = Object.prototype.toString;
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        var forEachArray = function forEachArray(array, iterator, receiver) {
          for (var i = 0, len = array.length; i < len; i++) {
            if (hasOwnProperty.call(array, i)) {
              if (receiver == null) {
                iterator(array[i], i, array);
              } else {
                iterator.call(receiver, array[i], i, array);
              }
            }
          }
        };

        var forEachString = function forEachString(string, iterator, receiver) {
          for (var i = 0, len = string.length; i < len; i++) {
            // no such thing as a sparse string.
            if (receiver == null) {
              iterator(string.charAt(i), i, string);
            } else {
              iterator.call(receiver, string.charAt(i), i, string);
            }
          }
        };

        var forEachObject = function forEachObject(object, iterator, receiver) {
          for (var k in object) {
            if (hasOwnProperty.call(object, k)) {
              if (receiver == null) {
                iterator(object[k], k, object);
              } else {
                iterator.call(receiver, object[k], k, object);
              }
            }
          }
        };

        var forEach = function forEach(list, iterator, thisArg) {
          if (!isCallable(iterator)) {
            throw new TypeError("iterator must be a function");
          }

          var receiver;
          if (arguments.length >= 3) {
            receiver = thisArg;
          }

          if (toStr.call(list) === "[object Array]") {
            forEachArray(list, iterator, receiver);
          } else if (typeof list === "string") {
            forEachString(list, iterator, receiver);
          } else {
            forEachObject(list, iterator, receiver);
          }
        };

        module.exports = forEach;
      },
      { "is-callable": 115 },
    ],
    70: [
      function (require, module, exports) {
        /*!
         * for-in <https://github.com/jonschlinkert/for-in>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        module.exports = function forIn(obj, fn, thisArg) {
          for (var key in obj) {
            if (fn.call(thisArg, obj[key], key, obj) === false) {
              break;
            }
          }
        };
      },
      {},
    ],
    71: [
      function (require, module, exports) {
        /*!
         * for-own <https://github.com/jonschlinkert/for-own>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var forIn = require("for-in");
        var hasOwn = Object.prototype.hasOwnProperty;

        module.exports = function forOwn(obj, fn, thisArg) {
          forIn(obj, function (val, key) {
            if (hasOwn.call(obj, key)) {
              return fn.call(thisArg, obj[key], key, obj);
            }
          });
        };
      },
      { "for-in": 70 },
    ],
    72: [
      function (require, module, exports) {
        /*!
         * fragment-cache <https://github.com/jonschlinkert/fragment-cache>
         *
         * Copyright (c) 2016-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var MapCache = require("map-cache");

        /**
         * Create a new `FragmentCache` with an optional object to use for `caches`.
         *
         * ```js
         * var fragment = new FragmentCache();
         * ```
         * @name FragmentCache
         * @param {String} `cacheName`
         * @return {Object} Returns the [map-cache][] instance.
         * @api public
         */

        function FragmentCache(caches) {
          this.caches = caches || {};
        }

        /**
         * Prototype
         */

        FragmentCache.prototype = {
          /**
           * Get cache `name` from the `fragment.caches` object. Creates a new
           * `MapCache` if it doesn't already exist.
           *
           * ```js
           * var cache = fragment.cache('files');
           * console.log(fragment.caches.hasOwnProperty('files'));
           * //=> true
           * ```
           * @name .cache
           * @param {String} `cacheName`
           * @return {Object} Returns the [map-cache][] instance.
           * @api public
           */

          cache: function (cacheName) {
            return (
              this.caches[cacheName] ||
              (this.caches[cacheName] = new MapCache())
            );
          },

          /**
           * Set a value for property `key` on cache `name`
           *
           * ```js
           * fragment.set('files', 'somefile.js', new File({path: 'somefile.js'}));
           * ```
           * @name .set
           * @param {String} `name`
           * @param {String} `key` Property name to set
           * @param {any} `val` The value of `key`
           * @return {Object} The cache instance for chaining
           * @api public
           */

          set: function (cacheName, key, val) {
            var cache = this.cache(cacheName);
            cache.set(key, val);
            return cache;
          },

          /**
           * Returns true if a non-undefined value is set for `key` on fragment cache `name`.
           *
           * ```js
           * var cache = fragment.cache('files');
           * cache.set('somefile.js');
           *
           * console.log(cache.has('somefile.js'));
           * //=> true
           *
           * console.log(cache.has('some-other-file.js'));
           * //=> false
           * ```
           * @name .has
           * @param {String} `name` Cache name
           * @param {String} `key` Optionally specify a property to check for on cache `name`
           * @return {Boolean}
           * @api public
           */

          has: function (cacheName, key) {
            return typeof this.get(cacheName, key) !== "undefined";
          },

          /**
           * Get `name`, or if specified, the value of `key`. Invokes the [cache]() method,
           * so that cache `name` will be created it doesn't already exist. If `key` is not passed,
           * the entire cache (`name`) is returned.
           *
           * ```js
           * var Vinyl = require('vinyl');
           * var cache = fragment.cache('files');
           * cache.set('somefile.js', new Vinyl({path: 'somefile.js'}));
           * console.log(cache.get('somefile.js'));
           * //=> <File "somefile.js">
           * ```
           * @name .get
           * @param {String} `name`
           * @return {Object} Returns cache `name`, or the value of `key` if specified
           * @api public
           */

          get: function (name, key) {
            var cache = this.cache(name);
            if (typeof key === "string") {
              return cache.get(key);
            }
            return cache;
          },
        };

        /**
         * Expose `FragmentCache`
         */

        exports = module.exports = FragmentCache;
      },
      { "map-cache": 134 },
    ],
    73: [
      function (require, module, exports) {
        "use strict";

        /* eslint no-invalid-this: 1 */

        var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
        var slice = Array.prototype.slice;
        var toStr = Object.prototype.toString;
        var funcType = "[object Function]";

        module.exports = function bind(that) {
          var target = this;
          if (typeof target !== "function" || toStr.call(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
          }
          var args = slice.call(arguments, 1);

          var bound;
          var binder = function () {
            if (this instanceof bound) {
              var result = target.apply(
                this,
                args.concat(slice.call(arguments))
              );
              if (Object(result) === result) {
                return result;
              }
              return this;
            } else {
              return target.apply(that, args.concat(slice.call(arguments)));
            }
          };

          var boundLength = Math.max(0, target.length - args.length);
          var boundArgs = [];
          for (var i = 0; i < boundLength; i++) {
            boundArgs.push("$" + i);
          }

          bound = Function(
            "binder",
            "return function (" +
              boundArgs.join(",") +
              "){ return binder.apply(this,arguments); }"
          )(binder);

          if (target.prototype) {
            var Empty = function Empty() {};
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
          }

          return bound;
        };
      },
      {},
    ],
    74: [
      function (require, module, exports) {
        "use strict";

        var implementation = require("./implementation");

        module.exports = Function.prototype.bind || implementation;
      },
      { "./implementation": 73 },
    ],
    75: [
      function (require, module, exports) {
        "use strict";

        var undefined;

        var $SyntaxError = SyntaxError;
        var $Function = Function;
        var $TypeError = TypeError;

        // eslint-disable-next-line consistent-return
        var getEvalledConstructor = function (expressionSyntax) {
          try {
            return $Function(
              '"use strict"; return (' + expressionSyntax + ").constructor;"
            )();
          } catch (e) {}
        };

        var $gOPD = Object.getOwnPropertyDescriptor;
        if ($gOPD) {
          try {
            $gOPD({}, "");
          } catch (e) {
            $gOPD = null; // this is IE 8, which has a broken gOPD
          }
        }

        var throwTypeError = function () {
          throw new $TypeError();
        };
        var ThrowTypeError = $gOPD
          ? (function () {
              try {
                // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                arguments.callee; // IE 8 does not throw here
                return throwTypeError;
              } catch (calleeThrows) {
                try {
                  // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                  return $gOPD(arguments, "callee").get;
                } catch (gOPDthrows) {
                  return throwTypeError;
                }
              }
            })()
          : throwTypeError;

        var hasSymbols = require("has-symbols")();

        var getProto =
          Object.getPrototypeOf ||
          function (x) {
            return x.__proto__;
          }; // eslint-disable-line no-proto

        var needsEval = {};

        var TypedArray =
          typeof Uint8Array === "undefined" ? undefined : getProto(Uint8Array);

        var INTRINSICS = {
          "%AggregateError%":
            typeof AggregateError === "undefined" ? undefined : AggregateError,
          "%Array%": Array,
          "%ArrayBuffer%":
            typeof ArrayBuffer === "undefined" ? undefined : ArrayBuffer,
          "%ArrayIteratorPrototype%": hasSymbols
            ? getProto([][Symbol.iterator]())
            : undefined,
          "%AsyncFromSyncIteratorPrototype%": undefined,
          "%AsyncFunction%": needsEval,
          "%AsyncGenerator%": needsEval,
          "%AsyncGeneratorFunction%": needsEval,
          "%AsyncIteratorPrototype%": needsEval,
          "%Atomics%": typeof Atomics === "undefined" ? undefined : Atomics,
          "%BigInt%": typeof BigInt === "undefined" ? undefined : BigInt,
          "%Boolean%": Boolean,
          "%DataView%": typeof DataView === "undefined" ? undefined : DataView,
          "%Date%": Date,
          "%decodeURI%": decodeURI,
          "%decodeURIComponent%": decodeURIComponent,
          "%encodeURI%": encodeURI,
          "%encodeURIComponent%": encodeURIComponent,
          "%Error%": Error,
          "%eval%": eval, // eslint-disable-line no-eval
          "%EvalError%": EvalError,
          "%Float32Array%":
            typeof Float32Array === "undefined" ? undefined : Float32Array,
          "%Float64Array%":
            typeof Float64Array === "undefined" ? undefined : Float64Array,
          "%FinalizationRegistry%":
            typeof FinalizationRegistry === "undefined"
              ? undefined
              : FinalizationRegistry,
          "%Function%": $Function,
          "%GeneratorFunction%": needsEval,
          "%Int8Array%":
            typeof Int8Array === "undefined" ? undefined : Int8Array,
          "%Int16Array%":
            typeof Int16Array === "undefined" ? undefined : Int16Array,
          "%Int32Array%":
            typeof Int32Array === "undefined" ? undefined : Int32Array,
          "%isFinite%": isFinite,
          "%isNaN%": isNaN,
          "%IteratorPrototype%": hasSymbols
            ? getProto(getProto([][Symbol.iterator]()))
            : undefined,
          "%JSON%": typeof JSON === "object" ? JSON : undefined,
          "%Map%": typeof Map === "undefined" ? undefined : Map,
          "%MapIteratorPrototype%":
            typeof Map === "undefined" || !hasSymbols
              ? undefined
              : getProto(new Map()[Symbol.iterator]()),
          "%Math%": Math,
          "%Number%": Number,
          "%Object%": Object,
          "%parseFloat%": parseFloat,
          "%parseInt%": parseInt,
          "%Promise%": typeof Promise === "undefined" ? undefined : Promise,
          "%Proxy%": typeof Proxy === "undefined" ? undefined : Proxy,
          "%RangeError%": RangeError,
          "%ReferenceError%": ReferenceError,
          "%Reflect%": typeof Reflect === "undefined" ? undefined : Reflect,
          "%RegExp%": RegExp,
          "%Set%": typeof Set === "undefined" ? undefined : Set,
          "%SetIteratorPrototype%":
            typeof Set === "undefined" || !hasSymbols
              ? undefined
              : getProto(new Set()[Symbol.iterator]()),
          "%SharedArrayBuffer%":
            typeof SharedArrayBuffer === "undefined"
              ? undefined
              : SharedArrayBuffer,
          "%String%": String,
          "%StringIteratorPrototype%": hasSymbols
            ? getProto(""[Symbol.iterator]())
            : undefined,
          "%Symbol%": hasSymbols ? Symbol : undefined,
          "%SyntaxError%": $SyntaxError,
          "%ThrowTypeError%": ThrowTypeError,
          "%TypedArray%": TypedArray,
          "%TypeError%": $TypeError,
          "%Uint8Array%":
            typeof Uint8Array === "undefined" ? undefined : Uint8Array,
          "%Uint8ClampedArray%":
            typeof Uint8ClampedArray === "undefined"
              ? undefined
              : Uint8ClampedArray,
          "%Uint16Array%":
            typeof Uint16Array === "undefined" ? undefined : Uint16Array,
          "%Uint32Array%":
            typeof Uint32Array === "undefined" ? undefined : Uint32Array,
          "%URIError%": URIError,
          "%WeakMap%": typeof WeakMap === "undefined" ? undefined : WeakMap,
          "%WeakRef%": typeof WeakRef === "undefined" ? undefined : WeakRef,
          "%WeakSet%": typeof WeakSet === "undefined" ? undefined : WeakSet,
        };

        var doEval = function doEval(name) {
          var value;
          if (name === "%AsyncFunction%") {
            value = getEvalledConstructor("async function () {}");
          } else if (name === "%GeneratorFunction%") {
            value = getEvalledConstructor("function* () {}");
          } else if (name === "%AsyncGeneratorFunction%") {
            value = getEvalledConstructor("async function* () {}");
          } else if (name === "%AsyncGenerator%") {
            var fn = doEval("%AsyncGeneratorFunction%");
            if (fn) {
              value = fn.prototype;
            }
          } else if (name === "%AsyncIteratorPrototype%") {
            var gen = doEval("%AsyncGenerator%");
            if (gen) {
              value = getProto(gen.prototype);
            }
          }

          INTRINSICS[name] = value;

          return value;
        };

        var LEGACY_ALIASES = {
          "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
          "%ArrayPrototype%": ["Array", "prototype"],
          "%ArrayProto_entries%": ["Array", "prototype", "entries"],
          "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
          "%ArrayProto_keys%": ["Array", "prototype", "keys"],
          "%ArrayProto_values%": ["Array", "prototype", "values"],
          "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
          "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
          "%AsyncGeneratorPrototype%": [
            "AsyncGeneratorFunction",
            "prototype",
            "prototype",
          ],
          "%BooleanPrototype%": ["Boolean", "prototype"],
          "%DataViewPrototype%": ["DataView", "prototype"],
          "%DatePrototype%": ["Date", "prototype"],
          "%ErrorPrototype%": ["Error", "prototype"],
          "%EvalErrorPrototype%": ["EvalError", "prototype"],
          "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
          "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
          "%FunctionPrototype%": ["Function", "prototype"],
          "%Generator%": ["GeneratorFunction", "prototype"],
          "%GeneratorPrototype%": [
            "GeneratorFunction",
            "prototype",
            "prototype",
          ],
          "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
          "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
          "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
          "%JSONParse%": ["JSON", "parse"],
          "%JSONStringify%": ["JSON", "stringify"],
          "%MapPrototype%": ["Map", "prototype"],
          "%NumberPrototype%": ["Number", "prototype"],
          "%ObjectPrototype%": ["Object", "prototype"],
          "%ObjProto_toString%": ["Object", "prototype", "toString"],
          "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
          "%PromisePrototype%": ["Promise", "prototype"],
          "%PromiseProto_then%": ["Promise", "prototype", "then"],
          "%Promise_all%": ["Promise", "all"],
          "%Promise_reject%": ["Promise", "reject"],
          "%Promise_resolve%": ["Promise", "resolve"],
          "%RangeErrorPrototype%": ["RangeError", "prototype"],
          "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
          "%RegExpPrototype%": ["RegExp", "prototype"],
          "%SetPrototype%": ["Set", "prototype"],
          "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
          "%StringPrototype%": ["String", "prototype"],
          "%SymbolPrototype%": ["Symbol", "prototype"],
          "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
          "%TypedArrayPrototype%": ["TypedArray", "prototype"],
          "%TypeErrorPrototype%": ["TypeError", "prototype"],
          "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
          "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
          "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
          "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
          "%URIErrorPrototype%": ["URIError", "prototype"],
          "%WeakMapPrototype%": ["WeakMap", "prototype"],
          "%WeakSetPrototype%": ["WeakSet", "prototype"],
        };

        var bind = require("function-bind");
        var hasOwn = require("has");
        var $concat = bind.call(Function.call, Array.prototype.concat);
        var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
        var $replace = bind.call(Function.call, String.prototype.replace);
        var $strSlice = bind.call(Function.call, String.prototype.slice);
        var $exec = bind.call(Function.call, RegExp.prototype.exec);

        /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
        var rePropName =
          /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
        var reEscapeChar =
          /\\(\\)?/g; /** Used to match backslashes in property paths. */
        var stringToPath = function stringToPath(string) {
          var first = $strSlice(string, 0, 1);
          var last = $strSlice(string, -1);
          if (first === "%" && last !== "%") {
            throw new $SyntaxError(
              "invalid intrinsic syntax, expected closing `%`"
            );
          } else if (last === "%" && first !== "%") {
            throw new $SyntaxError(
              "invalid intrinsic syntax, expected opening `%`"
            );
          }
          var result = [];
          $replace(
            string,
            rePropName,
            function (match, number, quote, subString) {
              result[result.length] = quote
                ? $replace(subString, reEscapeChar, "$1")
                : number || match;
            }
          );
          return result;
        };
        /* end adaptation */

        var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
          var intrinsicName = name;
          var alias;
          if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
            alias = LEGACY_ALIASES[intrinsicName];
            intrinsicName = "%" + alias[0] + "%";
          }

          if (hasOwn(INTRINSICS, intrinsicName)) {
            var value = INTRINSICS[intrinsicName];
            if (value === needsEval) {
              value = doEval(intrinsicName);
            }
            if (typeof value === "undefined" && !allowMissing) {
              throw new $TypeError(
                "intrinsic " +
                  name +
                  " exists, but is not available. Please file an issue!"
              );
            }

            return {
              alias: alias,
              name: intrinsicName,
              value: value,
            };
          }

          throw new $SyntaxError("intrinsic " + name + " does not exist!");
        };

        module.exports = function GetIntrinsic(name, allowMissing) {
          if (typeof name !== "string" || name.length === 0) {
            throw new $TypeError("intrinsic name must be a non-empty string");
          }
          if (arguments.length > 1 && typeof allowMissing !== "boolean") {
            throw new $TypeError('"allowMissing" argument must be a boolean');
          }

          if ($exec(/^%?[^%]*%?$/, name) === null) {
            throw new $SyntaxError(
              "`%` may not be present anywhere but at the beginning and end of the intrinsic name"
            );
          }
          var parts = stringToPath(name);
          var intrinsicBaseName = parts.length > 0 ? parts[0] : "";

          var intrinsic = getBaseIntrinsic(
            "%" + intrinsicBaseName + "%",
            allowMissing
          );
          var intrinsicRealName = intrinsic.name;
          var value = intrinsic.value;
          var skipFurtherCaching = false;

          var alias = intrinsic.alias;
          if (alias) {
            intrinsicBaseName = alias[0];
            $spliceApply(parts, $concat([0, 1], alias));
          }

          for (var i = 1, isOwn = true; i < parts.length; i += 1) {
            var part = parts[i];
            var first = $strSlice(part, 0, 1);
            var last = $strSlice(part, -1);
            if (
              (first === '"' ||
                first === "'" ||
                first === "`" ||
                last === '"' ||
                last === "'" ||
                last === "`") &&
              first !== last
            ) {
              throw new $SyntaxError(
                "property names with quotes must have matching quotes"
              );
            }
            if (part === "constructor" || !isOwn) {
              skipFurtherCaching = true;
            }

            intrinsicBaseName += "." + part;
            intrinsicRealName = "%" + intrinsicBaseName + "%";

            if (hasOwn(INTRINSICS, intrinsicRealName)) {
              value = INTRINSICS[intrinsicRealName];
            } else if (value != null) {
              if (!(part in value)) {
                if (!allowMissing) {
                  throw new $TypeError(
                    "base intrinsic for " +
                      name +
                      " exists, but the property is not available."
                  );
                }
                return void undefined;
              }
              if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;

                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                  value = desc.get;
                } else {
                  value = value[part];
                }
              } else {
                isOwn = hasOwn(value, part);
                value = value[part];
              }

              if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
              }
            }
          }
          return value;
        };
      },
      { "function-bind": 74, has: 108, "has-symbols": 100 },
    ],
    76: [
      function (require, module, exports) {
        /*!
         * get-object <https://github.com/jonschlinkert/get-object>
         *
         * Copyright (c) 2014 Jon Schlinkert, contributors.
         * Licensed under the MIT License
         */

        "use strict";

        var isNumber = require("is-number");

        module.exports = function getObject(obj, prop) {
          if (!prop) return obj;
          if (!obj) return {};
          var segs = String(prop)
            .split(/[[.\]]/)
            .filter(Boolean);
          var last = segs[segs.length - 1],
            res = {};
          while ((prop = segs.shift())) {
            obj = obj[prop];
            if (!obj) return {};
          }
          if (isNumber(last)) return [obj];
          res[last] = obj;
          return res;
        };
      },
      { "is-number": 77 },
    ],
    77: [
      function (require, module, exports) {
        /*!
         * is-number <https://github.com/jonschlinkert/is-number>
         *
         * Copyright (c) 2014-2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        var typeOf = require("kind-of");

        module.exports = function isNumber(num) {
          var type = typeOf(num);
          if (type !== "number" && type !== "string") {
            return false;
          }
          var n = +num;
          return n - n + 1 >= 0 && num !== "";
        };
      },
      { "kind-of": 78 },
    ],
    78: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    79: [
      function (require, module, exports) {
        /*!
         * get-value <https://github.com/jonschlinkert/get-value>
         *
         * Copyright (c) 2014-2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        module.exports = function (obj, prop, a, b, c) {
          if (!isObject(obj) || !prop) {
            return obj;
          }

          prop = toString(prop);

          // allowing for multiple properties to be passed as
          // a string or array, but much faster (3-4x) than doing
          // `[].slice.call(arguments)`
          if (a) prop += "." + toString(a);
          if (b) prop += "." + toString(b);
          if (c) prop += "." + toString(c);

          if (prop in obj) {
            return obj[prop];
          }

          var segs = prop.split(".");
          var len = segs.length;
          var i = -1;

          while (obj && ++i < len) {
            var key = segs[i];
            while (key[key.length - 1] === "\\") {
              key = key.slice(0, -1) + "." + segs[++i];
            }
            obj = obj[key];
          }
          return obj;
        };

        function isObject(val) {
          return (
            val !== null &&
            (typeof val === "object" || typeof val === "function")
          );
        }

        function toString(val) {
          if (!val) return "";
          if (Array.isArray(val)) {
            return val.join(".");
          }
          return val;
        }
      },
      {},
    ],
    80: [
      function (require, module, exports) {
        "use strict";

        var GetIntrinsic = require("get-intrinsic");

        var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);

        if ($gOPD) {
          try {
            $gOPD([], "length");
          } catch (e) {
            // IE 8 has a broken gOPD
            $gOPD = null;
          }
        }

        module.exports = $gOPD;
      },
      { "get-intrinsic": 75 },
    ],
    81: [
      function (require, module, exports) {
        "use strict";

        var util = require("handlebars-utils");
        var utils = require("./utils");
        var helpers = module.exports;

        /**
         * Returns all of the items in an array after the specified index.
         * Opposite of [before](#before).
         *
         * ```handlebars
         * <!-- array: ['a', 'b', 'c'] -->
         * {{after array 1}}
         * <!-- results in: '["c"]' -->
         * ```
         * @param {Array} `array` Collection
         * @param {Number} `n` Starting index (number of items to exclude)
         * @return {Array} Array exluding `n` items.
         * @api public
         */

        helpers.after = function (array, n) {
          if (util.isUndefined(array)) return "";
          return array.slice(n);
        };

        /**
         * Cast the given `value` to an array.
         *
         * ```handlebars
         * {{arrayify "foo"}}
         * <!-- results in: [ "foo" ] -->
         * ```
         * @param {any} `value`
         * @return {Array}
         * @api public
         */

        helpers.arrayify = function (value) {
          return value ? (Array.isArray(value) ? value : [value]) : [];
        };

        /**
         * Return all of the items in the collection before the specified
         * count. Opposite of [after](#after).
         *
         * ```handlebars
         * <!-- array: ['a', 'b', 'c'] -->
         * {{before array 2}}
         * <!-- results in: '["a", "b"]' -->
         * ```
         * @param {Array} `array`
         * @param {Number} `n`
         * @return {Array} Array excluding items after the given number.
         * @api public
         */

        helpers.before = function (array, n) {
          if (util.isUndefined(array)) return "";
          return array.slice(0, -n);
        };

        /**
         * ```handlebars
         * <!-- array: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] -->
         * {{#eachIndex array}}
         *   {{item}} is {{index}}
         * {{/eachIndex}}
         * ```
         * @param {Array} `array`
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.eachIndex = function (array, options) {
          var result = "";
          for (var i = 0; i < array.length; i++) {
            result += options.fn({ item: array[i], index: i });
          }
          return result;
        };

        /**
         * Block helper that filters the given array and renders the block for values that
         * evaluate to `true`, otherwise the inverse block is returned.
         *
         * ```handlebars
         * <!-- array: ['a', 'b', 'c'] -->
         * {{#filter array "foo"}}AAA{{else}}BBB{{/filter}}
         * <!-- results in: 'BBB' -->
         * ```
         * @param {Array} `array`
         * @param {any} `value`
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.filter = function (array, value, options) {
          var content = "";
          var results = [];

          // filter on a specific property
          var prop =
            options.hash && (options.hash.property || options.hash.prop);
          if (prop) {
            results = array.filter(function (val) {
              return value === utils.get(val, prop);
            });
          } else {
            // filter on a string value
            results = array.filter(function (v) {
              return value === v;
            });
          }

          if (results && results.length > 0) {
            for (var i = 0; i < results.length; i++) {
              content += options.fn(results[i]);
            }
            return content;
          }
          return options.inverse(this);
        };

        /**
         * Returns the first item, or first `n` items of an array.
         *
         * ```handlebars
         * {{first "['a', 'b', 'c', 'd', 'e']" 2}}
         * <!-- results in: '["a", "b"]' -->
         * ```
         * @param {Array} `array`
         * @param {Number} `n` Number of items to return, starting at `0`.
         * @return {Array}
         * @api public
         */

        helpers.first = function (array, n) {
          if (util.isUndefined(array)) return "";
          if (!utils.isNumber(n)) {
            return array[0];
          }
          return array.slice(0, n);
        };

        /**
         * Iterates over each item in an array and exposes the current item
         * in the array as context to the inner block. In addition to
         * the current array item, the helper exposes the following variables
         * to the inner block:
         *
         * - `index`
         * - `total`
         * - `isFirst`
         * - `isLast`
         *
         * Also, `@index` is exposed as a private variable, and additional
         * private variables may be defined as hash arguments.
         *
         * ```handlebars
         * <!-- accounts = [
         *   {'name': 'John', 'email': 'john@example.com'},
         *   {'name': 'Malcolm', 'email': 'malcolm@example.com'},
         *   {'name': 'David', 'email': 'david@example.com'}
         * ] -->
         *
         * {{#forEach accounts}}
         *   <a href="mailto:{{ email }}" title="Send an email to {{ name }}">
         *     {{ name }}
         *   </a>{{#unless isLast}}, {{/unless}}
         * {{/forEach}}
         * ```
         * @source <http://stackoverflow.com/questions/13861007>
         * @param {Array} `array`
         * @return {String}
         * @block
         * @api public
         */

        helpers.forEach = function (array, options) {
          var data = utils.createFrame(options, options.hash);
          var len = array.length;
          var buffer = "";
          var i = -1;

          while (++i < len) {
            var item = array[i];
            data.index = i;
            item.index = i + 1;
            item.total = len;
            item.isFirst = i === 0;
            item.isLast = i === len - 1;
            buffer += options.fn(item, { data: data });
          }
          return buffer;
        };

        /**
         * Block helper that renders the block if an array has the
         * given `value`. Optionally specify an inverse block to render
         * when the array does not have the given value.
         *
         * ```handlebars
         * <!-- array: ['a', 'b', 'c'] -->
         * {{#inArray array "d"}}
         *   foo
         * {{else}}
         *   bar
         * {{/inArray}}
         * <!-- results in: 'bar' -->
         * ```
         * @param {Array} `array`
         * @param {any} `value`
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.inArray = function (array, value, options) {
          return util.value(util.indexOf(array, value) > -1, this, options);
        };

        /**
         * Returns true if `value` is an es5 array.
         *
         * ```handlebars
         * {{isArray "abc"}}
         * <!-- results in: false -->
         *
         * <!-- array: [1, 2, 3] -->
         * {{isArray array}}
         * <!-- results in: true -->
         * ```
         * @param {any} `value` The value to test.
         * @return {Boolean}
         * @api public
         */

        helpers.isArray = function (value) {
          return Array.isArray(value);
        };

        /**
         * Returns the item from `array` at index `idx`.
         *
         * ```handlebars
         * <!-- array: ['a', 'b', 'c'] -->
         * {{itemAt array 1}}
         * <!-- results in: 'b' -->
         * ```
         * @param {Array} `array`
         * @param {Number} `idx`
         * @return {any} `value`
         * @block
         * @api public
         */

        helpers.itemAt = function (array, idx) {
          array = util.result(array);
          if (Array.isArray(array)) {
            idx = utils.isNumber(idx) ? +idx : 0;
            if (idx < 0) {
              return array[array.length + idx];
            }
            if (idx < array.length) {
              return array[idx];
            }
          }
        };

        /**
         * Join all elements of array into a string, optionally using a
         * given separator.
         *
         * ```handlebars
         * <!-- array: ['a', 'b', 'c'] -->
         * {{join array}}
         * <!-- results in: 'a, b, c' -->
         *
         * {{join array '-'}}
         * <!-- results in: 'a-b-c' -->
         * ```
         * @param {Array} `array`
         * @param {String} `separator` The separator to use. Defaults to `, `.
         * @return {String}
         * @api public
         */

        helpers.join = function (array, separator) {
          if (typeof array === "string") return array;
          if (!Array.isArray(array)) return "";
          separator = util.isString(separator) ? separator : ", ";
          return array.join(separator);
        };

        /**
         * Returns true if the the length of the given `value` is equal
         * to the given `length`. Can be used as a block or inline helper.
         *
         * @param {Array|String} `value`
         * @param {Number} `length`
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.equalsLength = function (value, length, options) {
          if (util.isOptions(length)) {
            options = length;
            length = 0;
          }

          var len = 0;
          if (typeof value === "string" || Array.isArray(value)) {
            len = value.length;
          }

          return util.value(len === length, this, options);
        };

        /**
         * Returns the last item, or last `n` items of an array or string.
         * Opposite of [first](#first).
         *
         * ```handlebars
         * <!-- var value = ['a', 'b', 'c', 'd', 'e'] -->
         *
         * {{last value}}
         * <!-- results in: ['e'] -->
         *
         * {{last value 2}}
         * <!-- results in: ['d', 'e'] -->
         *
         * {{last value 3}}
         * <!-- results in: ['c', 'd', 'e'] -->
         * ```
         * @param {Array|String} `value` Array or string.
         * @param {Number} `n` Number of items to return from the end of the array.
         * @return {Array}
         * @api public
         */

        helpers.last = function (value, n) {
          if (!Array.isArray(value) && typeof value !== "string") {
            return "";
          }
          if (!utils.isNumber(n)) {
            return value[value.length - 1];
          }
          return value.slice(-Math.abs(n));
        };

        /**
         * Returns the length of the given string or array.
         *
         * ```handlebars
         * {{length '["a", "b", "c"]'}}
         * <!-- results in: 3 -->
         *
         * <!-- results in: myArray = ['a', 'b', 'c', 'd', 'e']; -->
         * {{length myArray}}
         * <!-- results in: 5 -->
         *
         * <!-- results in: myObject = {'a': 'a', 'b': 'b'}; -->
         * {{length myObject}}
         * <!-- results in: 2 -->
         * ```
         * @param {Array|Object|String} `value`
         * @return {Number} The length of the value.
         * @api public
         */

        helpers.length = function (value) {
          if (util.isObject(value) && !util.isOptions(value)) {
            value = Object.keys(value);
          }
          if (typeof value === "string" || Array.isArray(value)) {
            return value.length;
          }
          return 0;
        };

        /**
         * Alias for [equalsLength](#equalsLength)
         *
         * @api public
         */

        helpers.lengthEqual = helpers.equalsLength;

        /**
         * Returns a new array, created by calling `function` on each
         * element of the given `array`. For example,
         *
         * ```handlebars
         * <!-- array: ['a', 'b', 'c'], and "double" is a
         * fictitious function that duplicates letters -->
         * {{map array double}}
         * <!-- results in: '["aa", "bb", "cc"]' -->
         * ```
         *
         * @param {Array} `array`
         * @param {Function} `fn`
         * @return {String}
         * @api public
         */

        helpers.map = function (array, iter) {
          if (!Array.isArray(array)) return "";
          var len = array.length;
          var res = new Array(len);
          var i = -1;

          if (typeof iter !== "function") {
            return array;
          }

          while (++i < len) {
            res[i] = iter(array[i], i, array);
          }
          return res;
        };

        /**
         * Map over the given object or array or objects and create an array of values
         * from the given `prop`. Dot-notation may be used (as a string) to get
         * nested properties.
         *
         * ```handlebars
         * // {{pluck items "data.title"}}
         * <!-- results in: '["aa", "bb", "cc"]' -->
         * ```
         * @param {Array|Object} `collection`
         * @param {Function} `prop`
         * @return {String}
         * @api public
         */

        helpers.pluck = function (arr, prop) {
          if (util.isUndefined(arr)) return "";
          var res = [];
          for (var i = 0; i < arr.length; i++) {
            var val = utils.get(arr[i], prop);
            if (typeof val !== "undefined") {
              res.push(val);
            }
          }
          return res;
        };

        /**
         * Reverse the elements in an array, or the characters in a string.
         *
         * ```handlebars
         * <!-- value: 'abcd' -->
         * {{reverse value}}
         * <!-- results in: 'dcba' -->
         * <!-- value: ['a', 'b', 'c', 'd'] -->
         * {{reverse value}}
         * <!-- results in: ['d', 'c', 'b', 'a'] -->
         * ```
         * @param {Array|String} `value`
         * @return {Array|String} Returns the reversed string or array.
         * @api public
         */

        helpers.reverse = function (val) {
          if (Array.isArray(val)) {
            val.reverse();
            return val;
          }
          if (val && typeof val === "string") {
            return val.split("").reverse().join("");
          }
        };

        /**
         * Block helper that returns the block if the callback returns true
         * for some value in the given array.
         *
         * ```handlebars
         * <!-- array: [1, 'b', 3] -->
         * {{#some array isString}}
         *   Render me if the array has a string.
         * {{else}}
         *   Render me if it doesn't.
         * {{/some}}
         * <!-- results in: 'Render me if the array has a string.' -->
         * ```
         * @param {Array} `array`
         * @param {Function} `iter` Iteratee
         * @param {Options} Handlebars provided options object
         * @return {String}
         * @block
         * @api public
         */

        helpers.some = function (array, iter, options) {
          if (Array.isArray(array)) {
            for (var i = 0; i < array.length; i++) {
              if (iter(array[i], i, array)) {
                return options.fn(this);
              }
            }
          }
          return options.inverse(this);
        };

        /**
         * Sort the given `array`. If an array of objects is passed,
         * you may optionally pass a `key` to sort on as the second
         * argument. You may alternatively pass a sorting function as
         * the second argument.
         *
         * ```handlebars
         * <!-- array: ['b', 'a', 'c'] -->
         * {{sort array}}
         * <!-- results in: '["a", "b", "c"]' -->
         * ```
         *
         * @param {Array} `array` the array to sort.
         * @param {String|Function} `key` The object key to sort by, or sorting function.
         * @api public
         */

        helpers.sort = function (array, options) {
          if (!Array.isArray(array)) return "";
          if (utils.get(options, "hash.reverse")) {
            return array.sort().reverse();
          }
          return array.sort();
        };

        /**
         * Sort an `array`. If an array of objects is passed,
         * you may optionally pass a `key` to sort on as the second
         * argument. You may alternatively pass a sorting function as
         * the second argument.
         *
         * ```handlebars
         * <!-- array: [{a: 'zzz'}, {a: 'aaa'}] -->
         * {{sortBy array "a"}}
         * <!-- results in: '[{"a":"aaa"}, {"a":"zzz"}]' -->
         * ```
         *
         * @param {Array} `array` the array to sort.
         * @param {String|Function} `props` One or more properties to sort by, or sorting functions to use.
         * @api public
         */

        helpers.sortBy = function (array, prop, options) {
          if (!Array.isArray(array)) return "";
          var args = [].slice.call(arguments);
          // remove handlebars options
          args.pop();

          if (!util.isString(prop) && typeof prop !== "function") {
            return array.sort();
          }
          return utils.sortBy.apply(null, args);
        };

        /**
         * Use the items in the array _after_ the specified index
         * as context inside a block. Opposite of [withBefore](#withBefore).
         *
         * ```handlebars
         * <!-- array: ['a', 'b', 'c', 'd', 'e'] -->
         * {{#withAfter array 3}}
         *   {{this}}
         * {{/withAfter}}
         * <!-- results in: "de" -->
         * ```
         * @param {Array} `array`
         * @param {Number} `idx`
         * @param {Object} `options`
         * @return {Array}
         * @block
         * @api public
         */

        helpers.withAfter = function (array, idx, options) {
          if (!Array.isArray(array)) return "";
          array = array.slice(idx);
          var result = "";

          for (var i = 0; i < array.length; i++) {
            result += options.fn(array[i]);
          }
          return result;
        };

        /**
         * Use the items in the array _before_ the specified index
         * as context inside a block. Opposite of [withAfter](#withAfter).
         *
         * ```handlebars
         * <!-- array: ['a', 'b', 'c', 'd', 'e'] -->
         * {{#withBefore array 3}}
         *   {{this}}
         * {{/withBefore}}
         * <!-- results in: 'ab' -->
         * ```
         * @param {Array} `array`
         * @param {Number} `idx`
         * @param {Object} `options`
         * @return {Array}
         * @block
         * @api public
         */

        helpers.withBefore = function (array, idx, options) {
          if (!Array.isArray(array)) return "";
          array = array.slice(0, -idx);
          var result = "";

          for (var i = 0; i < array.length; i++) {
            result += options.fn(array[i]);
          }
          return result;
        };

        /**
         * Use the first item in a collection inside a handlebars
         * block expression. Opposite of [withLast](#withLast).
         *
         * ```handlebars
         * <!-- array: ['a', 'b', 'c'] -->
         * {{#withFirst array}}
         *   {{this}}
         * {{/withFirst}}
         * <!-- results in: 'a' -->
         * ```
         * @param {Array} `array`
         * @param {Number} `idx`
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.withFirst = function (array, idx, options) {
          if (util.isUndefined(array)) return "";
          array = util.result(array);

          if (!util.isUndefined(idx)) {
            idx = parseFloat(util.result(idx));
          }

          if (util.isUndefined(idx)) {
            options = idx;
            return options.fn(array[0]);
          }

          array = array.slice(0, idx);
          var result = "";
          for (var i = 0; i < array.length; i++) {
            result += options.fn(array[i]);
          }
          return result;
        };

        /**
         * Block helper that groups array elements by given group `size`.
         *
         * ```handlebars
         * <!-- array: ['a','b','c','d','e','f','g','h'] -->
         * {{#withGroup array 4}}
         *   {{#each this}}
         *     {{.}}
         *   {{each}}
         *   <br>
         * {{/withGroup}}
         * <!-- results in: -->
         * <!-- 'a','b','c','d'<br> -->
         * <!-- 'e','f','g','h'<br> -->
         * ```
         * @param {Array} `array` The array to iterate over
         * @param {Number} `size` The desired length of each array "group"
         * @param {Object} `options` Handlebars options
         * @return {String}
         * @block
         * @api public
         */

        helpers.withGroup = function (array, size, options) {
          var result = "";
          if (Array.isArray(array) && array.length > 0) {
            var subcontext = [];
            for (var i = 0; i < array.length; i++) {
              if (i > 0 && i % size === 0) {
                result += options.fn(subcontext);
                subcontext = [];
              }
              subcontext.push(array[i]);
            }
            result += options.fn(subcontext);
          }
          return result;
        };

        /**
         * Use the last item or `n` items in an array as context inside a block.
         * Opposite of [withFirst](#withFirst).
         *
         * ```handlebars
         * <!-- array: ['a', 'b', 'c'] -->
         * {{#withLast array}}
         *   {{this}}
         * {{/withLast}}
         * <!-- results in: 'c' -->
         * ```
         * @param {Array} `array`
         * @param {Number} `idx` The starting index.
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.withLast = function (array, idx, options) {
          if (util.isUndefined(array)) return "";
          array = util.result(array);

          if (!util.isUndefined(idx)) {
            idx = parseFloat(util.result(idx));
          }

          if (util.isUndefined(idx)) {
            options = idx;
            return options.fn(array[array.length - 1]);
          }

          array = array.slice(-idx);
          var len = array.length,
            i = -1;
          var result = "";
          while (++i < len) {
            result += options.fn(array[i]);
          }
          return result;
        };

        /**
         * Block helper that sorts a collection and exposes the sorted
         * collection as context inside the block.
         *
         * ```handlebars
         * <!-- array: ['b', 'a', 'c'] -->
         * {{#withSort array}}{{this}}{{/withSort}}
         * <!-- results in: 'abc' -->
         * ```
         * @param {Array} `array`
         * @param {String} `prop`
         * @param {Object} `options` Specify `reverse="true"` to reverse the array.
         * @return {String}
         * @block
         * @api public
         */

        helpers.withSort = function (array, prop, options) {
          if (util.isUndefined(array)) return "";
          var result = "";

          if (util.isUndefined(prop)) {
            options = prop;

            array = array.sort();
            if (utils.get(options, "hash.reverse")) {
              array = array.reverse();
            }

            for (var i = 0, len = array.length; i < len; i++) {
              result += options.fn(array[i]);
            }
            return result;
          }

          array.sort(function (a, b) {
            a = utils.get(a, prop);
            b = utils.get(b, prop);
            return a > b ? 1 : a < b ? -1 : 0;
          });

          if (utils.get(options, "hash.reverse")) {
            array = array.reverse();
          }

          var alen = array.length,
            j = -1;
          while (++j < alen) {
            result += options.fn(array[j]);
          }
          return result;
        };

        /**
         * Block helper that return an array with all duplicate
         * values removed. Best used along with a [each](#each) helper.
         *
         * ```handlebars
         * <!-- array: ['a', 'a', 'c', 'b', 'e', 'e'] -->
         * {{#each (unique array)}}{{.}}{{/each}}
         * <!-- results in: 'acbe' -->
         * ```
         * @param {Array} `array`
         * @param {Object} `options`
         * @return {Array}
         * @api public
         */

        helpers.unique = function (array, options) {
          if (util.isUndefined(array)) return "";

          return array.filter(function (item, index, arr) {
            return arr.indexOf(item) === index;
          });
        };
      },
      { "./utils": 95, "handlebars-utils": 99 },
    ],
    82: [
      function (require, module, exports) {
        "use strict";

        var util = require("handlebars-utils");
        var object = require("./object");
        var array = require("./array");
        var forEach = array.forEach;
        var forOwn = object.forOwn;
        var helpers = module.exports;

        /**
         * Inline, subexpression, or block helper that returns true (or the block)
         * if the given collection is empty, or false (or the inverse block, if
         * supplied) if the colleciton is not empty.
         *
         * ```handlebars
         * <!-- array: [] -->
         * {{#isEmpty array}}AAA{{else}}BBB{{/isEmpty}}
         * <!-- results in: 'AAA' -->
         *
         * <!-- array: [] -->
         * {{isEmpty array}}
         * <!-- results in: true -->
         * ```
         * @param {Object} `collection`
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.isEmpty = function (collection, options) {
          if (!util.isOptions(options)) {
            options = collection;
            return util.fn(true, this, options);
          }

          if (Array.isArray(collection) && !collection.length) {
            return util.fn(true, this, options);
          }

          var keys = Object.keys(collection);
          var isEmpty = typeof collection === "object" && !keys.length;
          return util.value(isEmpty, this, options);
        };

        /**
         * Block helper that iterates over an array or object. If
         * an array is given, `.forEach` is called, or if an object
         * is given, `.forOwn` is called, otherwise the inverse block
         * is returned.
         *
         * @param {Object|Array} `collection` The collection to iterate over
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.iterate = function (collection, options) {
          if (Array.isArray(collection)) {
            return forEach.apply(null, arguments);
          }
          if (util.isObject(collection)) {
            return forOwn.apply(null, arguments);
          }
          return options.inverse(this);
        };
      },
      { "./array": 81, "./object": 90, "handlebars-utils": 99 },
    ],
    83: [
      function (require, module, exports) {
        "use strict";

        var has = require("has-value");
        var util = require("handlebars-utils");
        var utils = require("./utils");
        var helpers = module.exports;

        /**
         * Helper that renders the block if **both** of the given values
         * are truthy. If an inverse block is specified it will be rendered
         * when falsy. Works as a block helper, inline helper or
         * subexpression.
         *
         * ```handlebars
         * <!-- {great: true, magnificent: true} -->
         * {{#and great magnificent}}A{{else}}B{{/and}}
         * <!-- results in: 'A' -->
         * ```
         * @param {any} `a`
         * @param {any} `b`
         * @param {Object} `options` Handlebars provided options object
         * @return {String}
         * @block
         * @api public
         */

        helpers.and = function () {
          var len = arguments.length - 1;
          var options = arguments[len];
          var val = true;

          for (var i = 0; i < len; i++) {
            if (!arguments[i]) {
              val = false;
              break;
            }
          }

          return util.value(val, this, options);
        };

        /**
         * Render a block when a comparison of the first and third
         * arguments returns true. The second argument is
         * the [arithemetic operator][operators] to use. You may also
         * optionally specify an inverse block to render when falsy.
         *
         * @param `a`
         * @param `operator` The operator to use. Operators must be enclosed in quotes: `">"`, `"="`, `"<="`, and so on.
         * @param `b`
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Block, or if specified the inverse block is rendered if falsey.
         * @block
         * @api public
         */

        helpers.compare = function (a, operator, b, options) {
          /*eslint eqeqeq: 0*/

          if (arguments.length < 4) {
            throw new Error(
              "handlebars Helper {{compare}} expects 4 arguments"
            );
          }

          var result;
          switch (operator) {
            case "==":
              result = a == b;
              break;
            case "===":
              result = a === b;
              break;
            case "!=":
              result = a != b;
              break;
            case "!==":
              result = a !== b;
              break;
            case "<":
              result = a < b;
              break;
            case ">":
              result = a > b;
              break;
            case "<=":
              result = a <= b;
              break;
            case ">=":
              result = a >= b;
              break;
            case "typeof":
              result = typeof a === b;
              break;
            default: {
              throw new Error(
                "helper {{compare}}: invalid operator: `" + operator + "`"
              );
            }
          }

          return util.value(result, this, options);
        };

        /**
         * Block helper that renders the block if `collection` has the
         * given `value`, using strict equality (`===`) for comparison,
         * otherwise the inverse block is rendered (if specified). If a
         * `startIndex` is specified and is negative, it is used as the
         * offset from the end of the collection.
         *
         * ```handlebars
         * <!-- array = ['a', 'b', 'c'] -->
         * {{#contains array "d"}}
         *   This will not be rendered.
         * {{else}}
         *   This will be rendered.
         * {{/contains}}
         * ```
         * @param {Array|Object|String} `collection` The collection to iterate over.
         * @param {any} `value` The value to check for.
         * @param {Number} `[startIndex=0]` Optionally define the starting index.
         * @param {Object} `options` Handlebars provided options object.
         * @block
         * @api public
         */

        helpers.contains = function (collection, value, startIndex, options) {
          if (typeof startIndex === "object") {
            options = startIndex;
            startIndex = undefined;
          }
          var val = utils.contains(collection, value, startIndex);
          return util.value(val, this, options);
        };

        /**
         * Returns the first value that is not undefined, otherwise the "default" value is returned.
         *
         * @param {any} `value`
         * @param {any} `defaultValue`
         * @return {String}
         * @alias .or
         * @api public
         */

        helpers.default = function () {
          for (var i = 0; i < arguments.length - 1; i++) {
            if (arguments[i] != null) return arguments[i];
          }
          return "";
        };

        /**
         * Block helper that renders a block if `a` is **equal to** `b`.
         * If an inverse block is specified it will be rendered when falsy.
         * You may optionally use the `compare=""` hash argument for the
         * second value.
         *
         * @param {String} `a`
         * @param {String} `b`
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @alias is
         * @block
         * @api public
         */

        helpers.eq = function (a, b, options) {
          if (arguments.length === 2) {
            options = b;
            b = options.hash.compare;
          }
          return util.value(a === b, this, options);
        };

        /**
         * Block helper that renders a block if `a` is **greater than** `b`.
         *
         * If an inverse block is specified it will be rendered when falsy.
         * You may optionally use the `compare=""` hash argument for the
         * second value.
         *
         * @param {String} `a`
         * @param {String} `b`
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @block
         * @api public
         */

        helpers.gt = function (a, b, options) {
          if (arguments.length === 2) {
            options = b;
            b = options.hash.compare;
          }
          return util.value(a > b, this, options);
        };

        /**
         * Block helper that renders a block if `a` is **greater than or
         * equal to** `b`.
         *
         * If an inverse block is specified it will be rendered when falsy.
         * You may optionally use the `compare=""` hash argument for the
         * second value.
         *
         * @param {String} `a`
         * @param {String} `b`
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @block
         * @api public
         */

        helpers.gte = function (a, b, options) {
          if (arguments.length === 2) {
            options = b;
            b = options.hash.compare;
          }
          return util.value(a >= b, this, options);
        };

        /**
         * Block helper that renders a block if `value` has `pattern`.
         * If an inverse block is specified it will be rendered when falsy.
         *
         * @param {any} `val` The value to check.
         * @param {any} `pattern` The pattern to check for.
         * @param {Object} `options` Handlebars provided options object
         * @return {String}
         * @block
         * @api public
         */

        helpers.has = function (value, pattern, options) {
          if (util.isOptions(value)) {
            options = value;
            pattern = null;
            value = null;
          }

          if (util.isOptions(pattern)) {
            options = pattern;
            pattern = null;
          }

          if (value === null) {
            return util.value(false, this, options);
          }

          if (arguments.length === 2) {
            return util.value(has(this, value), this, options);
          }

          if (
            (Array.isArray(value) || util.isString(value)) &&
            util.isString(pattern)
          ) {
            if (value.indexOf(pattern) > -1) {
              return util.fn(true, this, options);
            }
          }
          if (
            util.isObject(value) &&
            util.isString(pattern) &&
            pattern in value
          ) {
            return util.fn(true, this, options);
          }
          return util.inverse(false, this, options);
        };

        /**
         * Returns true if the given `value` is falsey. Uses the [falsey][]
         * library for comparisons. Please see that library for more information
         * or to report bugs with this helper.
         *
         * @param {any} `val`
         * @param {Options} `options`
         * @return {Boolean}
         * @api public
         */

        helpers.isFalsey = function (val, options) {
          return util.value(utils.falsey(val), this, options);
        };

        /**
         * Returns true if the given `value` is truthy. Uses the [falsey][]
         * library for comparisons. Please see that library for more information
         * or to report bugs with this helper.
         *
         * @param {any} `val`
         * @param {Options} `options`
         * @return {Boolean}
         * @api public
         */

        helpers.isTruthy = function (val, options) {
          return util.value(!utils.falsey(val), this, options);
        };

        /**
         * Return true if the given value is an even number.
         *
         * ```handlebars
         * {{#ifEven value}}
         *   render A
         * {{else}}
         *   render B
         * {{/ifEven}}
         * ```
         * @param {Number} `number`
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @block
         * @api public
         */

        helpers.ifEven = function (num, options) {
          return util.value(utils.isEven(num), this, options);
        };

        /**
         * Conditionally renders a block if the remainder is zero when
         * `a` operand is divided by `b`. If an inverse block is specified
         * it will be rendered when the remainder is **not zero**.
         *
         * @param {Number}
         * @param {Number}
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @block
         * @api public
         */

        helpers.ifNth = function (a, b, options) {
          var isNth = utils.isNumber(a) && utils.isNumber(b) && b % a === 0;
          return util.value(isNth, this, options);
        };

        /**
         * Block helper that renders a block if `value` is **an odd number**.
         * If an inverse block is specified it will be rendered when falsy.
         *
         * ```handlebars
         * {{#ifOdd value}}
         *   render A
         * {{else}}
         *   render B
         * {{/ifOdd}}
         * ```
         * @param {Object} `value`
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @block
         * @api public
         */

        helpers.ifOdd = function (val, options) {
          return util.value(!utils.isEven(val), this, options);
        };

        /**
         * Block helper that renders a block if `a` is **equal to** `b`.
         * If an inverse block is specified it will be rendered when falsy.
         * Similar to [eq](#eq) but does not do strict equality.
         *
         * @param {any} `a`
         * @param {any} `b`
         * @param {Object} `options` Handlebars provided options object
         * @return {String}
         * @block
         * @api public
         */

        helpers.is = function (a, b, options) {
          if (arguments.length === 2) {
            options = b;
            b = options.hash.compare;
          }
          return util.value(a == b, this, options);
        };

        /**
         * Block helper that renders a block if `a` is **not equal to** `b`.
         * If an inverse block is specified it will be rendered when falsy.
         * Similar to [unlessEq](#unlesseq) but does not use strict equality for
         * comparisons.
         *
         * @param {String} `a`
         * @param {String} `b`
         * @param {Object} `options` Handlebars provided options object
         * @return {String}
         * @block
         * @api public
         */

        helpers.isnt = function (a, b, options) {
          if (arguments.length === 2) {
            options = b;
            b = options.hash.compare;
          }
          return util.value(a != b, this, options);
        };

        /**
         * Block helper that renders a block if `a` is **less than** `b`.
         *
         * If an inverse block is specified it will be rendered when falsy.
         * You may optionally use the `compare=""` hash argument for the
         * second value.
         *
         * @param {Object} `context`
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @block
         * @api public
         */

        helpers.lt = function (a, b, options) {
          if (arguments.length === 2) {
            options = b;
            b = options.hash.compare;
          }
          return util.value(a < b, this, options);
        };

        /**
         * Block helper that renders a block if `a` is **less than or
         * equal to** `b`.
         *
         * If an inverse block is specified it will be rendered when falsy.
         * You may optionally use the `compare=""` hash argument for the
         * second value.
         *
         * @param {Sring} `a`
         * @param {Sring} `b`
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @block
         * @api public
         */

        helpers.lte = function (a, b, options) {
          if (arguments.length === 2) {
            options = b;
            b = options.hash.compare;
          }
          return util.value(a <= b, this, options);
        };

        /**
         * Block helper that renders a block if **neither of** the given values
         * are truthy. If an inverse block is specified it will be rendered
         * when falsy.
         *
         * @param {any} `a`
         * @param {any} `b`
         * @param `options` Handlebars options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @block
         * @api public
         */

        helpers.neither = function (a, b, options) {
          return util.value(!a && !b, this, options);
        };

        /**
         * Returns true if `val` is falsey. Works as a block or inline helper.
         *
         * @param {String} `val`
         * @param {Object} `options` Handlebars provided options object
         * @return {String}
         * @block
         * @api public
         */

        helpers.not = function (val, options) {
          return util.value(!val, this, options);
        };

        /**
         * Block helper that renders a block if **any of** the given values
         * is truthy. If an inverse block is specified it will be rendered
         * when falsy.
         *
         * ```handlebars
         * {{#or a b c}}
         *   If any value is true this will be rendered.
         * {{/or}}
         * ```
         *
         * @param {...any} `arguments` Variable number of arguments
         * @param {Object} `options` Handlebars options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @block
         * @api public
         */

        helpers.or = function (/* any, any, ..., options */) {
          var len = arguments.length - 1;
          var options = arguments[len];
          var val = false;

          for (var i = 0; i < len; i++) {
            if (arguments[i]) {
              val = true;
              break;
            }
          }
          return util.value(val, this, options);
        };

        /**
         * Block helper that always renders the inverse block **unless `a` is
         * is equal to `b`**.
         *
         * @param {String} `a`
         * @param {String} `b`
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Inverse block by default, or block if falsey.
         * @block
         * @api public
         */

        helpers.unlessEq = function (a, b, options) {
          if (util.isOptions(b)) {
            options = b;
            b = options.hash.compare;
          }
          return util.value(a !== b, this, options);
        };

        /**
         * Block helper that always renders the inverse block **unless `a` is
         * is greater than `b`**.
         *
         * @param {Object} `a` The default value
         * @param {Object} `b` The value to compare
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Inverse block by default, or block if falsey.
         * @block
         * @api public
         */

        helpers.unlessGt = function (a, b, options) {
          if (util.isOptions(b)) {
            options = b;
            b = options.hash.compare;
          }
          return util.value(a <= b, this, options);
        };

        /**
         * Block helper that always renders the inverse block **unless `a` is
         * is less than `b`**.
         *
         * @param {Object} `a` The default value
         * @param {Object} `b` The value to compare
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @block
         * @api public
         */

        helpers.unlessLt = function (a, b, options) {
          if (util.isOptions(b)) {
            options = b;
            b = options.hash.compare;
          }
          return util.value(a >= b, this, options);
        };

        /**
         * Block helper that always renders the inverse block **unless `a` is
         * is greater than or equal to `b`**.
         *
         * @param {any} `a`
         * @param {any} `b`
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @block
         * @api public
         */

        helpers.unlessGteq = function (a, b, options) {
          if (util.isOptions(b)) {
            options = b;
            b = options.hash.compare;
          }
          return util.value(a < b, this, options);
        };

        /**
         * Block helper that always renders the inverse block **unless `a` is
         * is less than or equal to `b`**.
         *
         * @param {any} `a`
         * @param {any} `b`
         * @param {Object} `options` Handlebars provided options object
         * @return {String} Block, or inverse block if specified and falsey.
         * @block
         * @api public
         */

        helpers.unlessLteq = function (a, b, options) {
          if (util.isOptions(b)) {
            options = b;
            b = options.hash.compare;
          }
          return util.value(a > b, this, options);
        };
      },
      { "./utils": 95, "handlebars-utils": 99, "has-value": 103 },
    ],
    84: [
      function (require, module, exports) {
        "use strict";
        var helpers = module.exports;

        /**
         * Get the current year.
         *
         * ```handlebars
         * {{year}}
         * <!-- 2017 -->
         * ```
         * @exposes year as year
         * @api public
         */

        helpers.year = require("year");

        /**
         * Use [moment][] as a helper. See [helper-date][] for more details.
         *
         * @exposes helper-date as moment
         * @api public
         */

        helpers.moment = helpers.date = require("helper-date");
      },
      { "helper-date": 109, year: 266 },
    ],
    85: [
      function (require, module, exports) {
        "use strict";

        var path = require("path");
        var util = require("handlebars-utils");
        var html = require("./utils/html");
        var utils = require("./utils");
        var parseAttr = html.parseAttributes;
        var helpers = module.exports;

        /**
         * Stringify attributes on the options `hash`.
         *
         * ```handlebars
         * <!-- value = 'bar' -->
         * <div{{attr foo=value}}></div>
         * <!-- results in: <div foo="bar"></div>
         * ```
         * @param {Object} `options`
         * @return {String}
         * @api public
         */

        helpers.attr = function (options) {
          var val = parseAttr((options && options.hash) || {});
          return val.trim() ? " " + val : "";
        };

        /**
         * Add an array of `<link>` tags. Automatically resolves
         * relative paths to `options.assets` if passed on the context.
         *
         * ```handlebars
         * <!-- {stylesheets: ['foo.css', 'bar.css']} -->
         * {{css stylesheets}}
         *
         * <!-- results in: -->
         * <!-- <link type="text/css" rel="stylesheet" href="foo.css"> -->
         * <!-- <link type="text/css" rel="stylesheet" href="bar.css"> -->
         * ```
         * @param {String|Array} `list` One or more stylesheet urls.
         * @return {String}
         * @api public
         */

        helpers.css = function (list, options) {
          if (arguments.length < 2) {
            options = list;
            list = [];
          }

          var styles = util.arrayify(list);
          var assets = "";

          if (this && this.options) {
            assets = this.options.assets || "";
          }

          if (options.hash.href) {
            styles = util.arrayify(options.hash.href);
          }

          return styles
            .map(function (item) {
              var ext = path.extname(item);
              var fp = item;

              if (!/(^\/\/)|(:\/\/)/.test(item)) {
                fp = path.posix.join(assets, item);
              }

              if (ext === ".less") {
                return (
                  '<link type="text/css" rel="stylesheet/less" href="' +
                  fp +
                  '">'
                );
              }
              return (
                '<link type="text/css" rel="stylesheet" href="' + fp + '">'
              );
            })
            .join("\n");
        };

        /**
         * Generate one or more `<script></script>` tags with paths/urls to
         * javascript or coffeescript files.
         *
         * ```handlebars
         * {{js scripts}}
         * ```
         * @param {Object} `context`
         * @return {String}
         * @api public
         */

        helpers.js = function (context) {
          if (utils.typeOf(context) === "object") {
            var attr = parseAttr(context.hash);
            return "<script" + (attr ? " " + attr : "") + "></script>";
          }

          if (utils.typeOf(context) === "string") {
            return '<script src="' + context + '"></script>';
          }

          context = util.arrayify(context);
          return context
            .map(function (fp) {
              return path.extname(fp) === ".coffee"
                ? utils.tag("script", { type: "text/coffeescript", src: fp })
                : utils.tag("script", { src: fp });
            })
            .join("\n");
        };

        /**
         * Strip HTML tags from a string, so that only the text nodes
         * are preserved.
         *
         * ```handlebars
         * {{sanitize "<span>foo</span>"}}
         * <!-- results in: 'foo' -->
         * ```
         *
         * @param {String} `str` The string of HTML to sanitize.
         * @return {String}
         * @api public
         */

        helpers.sanitize = function (str) {
          return html.sanitize(str);
        };

        /**
         * Block helper for creating unordered lists (`<ul></ul>`)
         *
         * @param {Object} `context`
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.ul = function (context, options) {
          return (
            "<ul " +
            parseAttr(options.hash) +
            ">" +
            context
              .map(function (item) {
                if (typeof item !== "string") {
                  item = options.fn(item);
                }
                return "<li>" + item + "</li>";
              })
              .join("\n") +
            "</ul>"
          );
        };

        /**
         * Block helper for creating ordered lists  (`<ol></ol>`)
         *
         * @param {Object} `context`
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.ol = function (context, options) {
          return (
            "<ol " +
            parseAttr(options.hash) +
            ">" +
            context
              .map(function (item) {
                if (typeof item !== "string") {
                  item = options.fn(item);
                }
                return "<li>" + item + "</li>";
              })
              .join("\n") +
            "</ol>"
          );
        };

        /**
         * Returns a `<figure>` with a thumbnail linked to a full picture
         *
         * @param {Object} `context` Object with values/attributes to add to the generated elements:
         * @param {String} `context.alt`
         * @param {String} `context.src`
         * @param {Number} `context.width`
         * @param {Number} `context.height`
         * @return {String} HTML `<figure>` element with image and optional caption/link.
         * @contributor: Marie Hogebrandt <https://github.com/Melindrea>
         * @api public
         */

        helpers.thumbnailImage = function (context) {
          var figure = "";
          var image = "";

          var link = context.full || false;
          var imageAttributes = {
            alt: context.alt,
            src: context.thumbnail,
            width: context.size.width,
            height: context.size.height,
          };

          var figureAttributes = { id: "image-" + context.id };
          var linkAttributes = { href: link, rel: "thumbnail" };

          if (context.classes) {
            if (context.classes.image) {
              imageAttributes.class = context.classes.image.join(" ");
            }
            if (context.classes.figure) {
              figureAttributes.class = context.classes.figure.join(" ");
            }
            if (context.classes.link) {
              linkAttributes.class = context.classes.link.join(" ");
            }
          }

          figure += "<figure " + parseAttr(figureAttributes) + ">\n";
          image += "<img " + parseAttr(imageAttributes) + ">\n";

          if (link) {
            figure +=
              "<a " + parseAttr(linkAttributes) + ">\n" + image + "</a>\n";
          } else {
            figure += image;
          }

          if (context.caption) {
            figure += "<figcaption>" + context.caption + "</figcaption>\n";
          }

          figure += "</figure>";
          return figure;
        };
      },
      { "./utils": 95, "./utils/html": 94, "handlebars-utils": 99, path: 177 },
    ],
    86: [
      function (require, module, exports) {
        "use strict";

        var util = require("handlebars-utils");
        var utils = require("./utils");
        var helpers = module.exports;

        /**
         * i18n helper. See [button-i18n](https://github.com/assemble/buttons)
         * for a working example.
         *
         * @contributor Laurent Goderre <https://github.com/LaurentGoderrre>
         * @param {String} `key`
         * @param {Object} `options`
         * @return {String}
         * @api public
         */

        helpers.i18n = function (prop, locals, options) {
          if (util.isOptions(locals)) {
            options = locals;
            locals = {};
          }

          if (!util.isString(prop)) {
            throw new Error('{{i18n}} helper expected "key" to be a string');
          }

          var opts = util.options(this, locals, options);
          var context = Object.assign({}, this, opts);

          var lang = context.language || context.lang;

          if (!util.isString(lang)) {
            throw new TypeError(
              '{{i18n}} helper expected "language" to be a string'
            );
          }

          var cache = context[lang];
          if (typeof cache === "undefined") {
            throw new Error(
              '{{i18n}} helper cannot find language "' + lang + '"'
            );
          }

          var result = utils.get(cache, prop);
          if (typeof result === "undefined") {
            throw new Error(
              '{{i18n}} helper cannot find property "' +
                prop +
                '" for language "' +
                lang +
                '"'
            );
          }

          return result;
        };
      },
      { "./utils": 95, "handlebars-utils": 99 },
    ],
    87: [
      function (require, module, exports) {
        "use strict";

        var util = require("handlebars-utils");
        var helpers = module.exports;

        /**
         * Returns either the `singular` or `plural` inflection of a word based on
         * the given `count`.
         *
         * ```handlebars
         * {{inflect 0 "string" "strings"}}
         * <!-- "strings" -->
         * {{inflect 1 "string" "strings"}}
         * <!-- "string" -->
         * {{inflect 1 "string" "strings" true}}
         * <!-- "1 string" -->
         * {{inflect 2 "string" "strings"}}
         * <!-- "strings" -->
         * {{inflect 2 "string" "strings" true}}
         * <!-- "2 strings" -->
         * ```
         * @param {Number} `count`
         * @param {String} `singular` The singular form
         * @param {String} `plural` The plural form
         * @param {String} `includeCount`
         * @return {String}
         * @api public
         */

        helpers.inflect = function (count, singular, plural, includeCount) {
          var word = count > 1 || count === 0 ? plural : singular;
          if (includeCount === true) {
            return String(count) + " " + word;
          } else {
            return word;
          }
        };

        /**
         * Returns an ordinalized number as a string.
         *
         * ```handlebars
         * {{ordinalize 1}}
         * <!-- '1st' -->
         * {{ordinalize 21}}
         * <!-- '21st' -->
         * {{ordinalize 29}}
         * <!-- '29th' -->
         * {{ordinalize 22}}
         * <!-- '22nd' -->
         * ```
         *
         * @param {String} `val` The value to ordinalize.
         * @return {String} The ordinalized number
         * @api public
         */

        helpers.ordinalize = function (val) {
          var num = Math.abs(Math.round(val));
          var str = String(val);
          var res = num % 100;

          if (util.indexOf([11, 12, 13], res) >= 0) {
            return str + "th";
          }

          switch (num % 10) {
            case 1:
              return str + "st";
            case 2:
              return str + "nd";
            case 3:
              return str + "rd";
            default: {
              return str + "th";
            }
          }
        };
      },
      { "handlebars-utils": 99 },
    ],
    88: [
      function (require, module, exports) {
        "use strict";

        var isNumber = require("is-number");
        var utils = require("./utils");
        var helpers = module.exports;

        /**
         * Return the magnitude of `a`.
         *
         * @param {Number} `a`
         * @return {Number}
         * @api public
         */

        helpers.abs = function (num) {
          if (!isNumber(num)) {
            throw new TypeError("expected a number");
          }
          return Math.abs(num);
        };

        /**
         * Return the sum of `a` plus `b`.
         *
         * @param {Number} `a`
         * @param {Number} `b`
         * @return {Number}
         * @api public
         */

        helpers.add = function (a, b) {
          if (isNumber(a) && isNumber(b)) {
            return Number(a) + Number(b);
          }
          if (typeof a === "string" && typeof b === "string") {
            return a + b;
          }
          return "";
        };

        /**
         * Returns the average of all numbers in the given array.
         *
         * ```handlebars
         * {{avg "[1, 2, 3, 4, 5]"}}
         * <!-- results in: '3' -->
         * ```
         *
         * @param {Array} `array` Array of numbers to add up.
         * @return {Number}
         * @api public
         */

        helpers.avg = function () {
          var args = [].concat.apply([], arguments);
          // remove handlebars options object
          args.pop();
          return helpers.sum(args) / args.length;
        };

        /**
         * Get the `Math.ceil()` of the given value.
         *
         * @param {Number} `value`
         * @return {Number}
         * @api public
         */

        helpers.ceil = function (num) {
          if (!isNumber(num)) {
            throw new TypeError("expected a number");
          }
          return Math.ceil(num);
        };

        /**
         * Divide `a` by `b`
         *
         * @param {Number} `a` numerator
         * @param {Number} `b` denominator
         * @api public
         */

        helpers.divide = function (a, b) {
          if (!isNumber(a)) {
            throw new TypeError("expected the first argument to be a number");
          }
          if (!isNumber(b)) {
            throw new TypeError("expected the second argument to be a number");
          }
          return Number(a) / Number(b);
        };

        /**
         * Get the `Math.floor()` of the given value.
         *
         * @param {Number} `value`
         * @return {Number}
         * @api public
         */

        helpers.floor = function (num) {
          if (!isNumber(num)) {
            throw new TypeError("expected a number");
          }
          return Math.floor(num);
        };

        /**
         * Return the difference of `a` minus `b`.
         *
         * @param {Number} `a`
         * @param {Number} `b`
         * @alias subtract
         * @api public
         */

        helpers.minus = function (a, b) {
          if (!isNumber(a)) {
            throw new TypeError("expected the first argument to be a number");
          }
          if (!isNumber(b)) {
            throw new TypeError("expected the second argument to be a number");
          }
          return Number(a) - Number(b);
        };

        /**
         * Get the remainder of a division operation.
         *
         * @param {Number} `a`
         * @param {Number} `b`
         * @return {Number}
         * @api public
         */

        helpers.modulo = function (a, b) {
          if (!isNumber(a)) {
            throw new TypeError("expected the first argument to be a number");
          }
          if (!isNumber(b)) {
            throw new TypeError("expected the second argument to be a number");
          }
          return Number(a) % Number(b);
        };

        /**
         * Return the product of `a` times `b`.
         *
         * @param {Number} `a` factor
         * @param {Number} `b` multiplier
         * @return {Number}
         * @alias times
         * @api public
         */

        helpers.multiply = function (a, b) {
          if (!isNumber(a)) {
            throw new TypeError("expected the first argument to be a number");
          }
          if (!isNumber(b)) {
            throw new TypeError("expected the second argument to be a number");
          }
          return Number(a) * Number(b);
        };

        /**
         * Add `a` by `b`.
         *
         * @param {Number} `a` factor
         * @param {Number} `b` multiplier
         * @api public
         */

        helpers.plus = function (a, b) {
          if (!isNumber(a)) {
            throw new TypeError("expected the first argument to be a number");
          }
          if (!isNumber(b)) {
            throw new TypeError("expected the second argument to be a number");
          }
          return Number(a) + Number(b);
        };

        /**
         * Generate a random number between two values
         *
         * @param {Number} `min`
         * @param {Number} `max`
         * @return {String}
         * @api public
         */

        helpers.random = function (min, max) {
          if (!isNumber(min)) {
            throw new TypeError("expected minimum to be a number");
          }
          if (!isNumber(max)) {
            throw new TypeError("expected maximum to be a number");
          }
          return utils.random(min, max);
        };

        /**
         * Get the remainder when `a` is divided by `b`.
         *
         * @param {Number} `a` a
         * @param {Number} `b` b
         * @api public
         */

        helpers.remainder = function (a, b) {
          return a % b;
        };

        /**
         * Round the given number.
         *
         * @param {Number} `number`
         * @return {Number}
         * @api public
         */

        helpers.round = function (num) {
          if (!isNumber(num)) {
            throw new TypeError("expected a number");
          }
          return Math.round(num);
        };

        /**
         * Return the product of `a` minus `b`.
         *
         * @param {Number} `a`
         * @param {Number} `b`
         * @return {Number}
         * @alias minus
         * @api public
         */

        helpers.subtract = function (a, b) {
          if (!isNumber(a)) {
            throw new TypeError("expected the first argument to be a number");
          }
          if (!isNumber(b)) {
            throw new TypeError("expected the second argument to be a number");
          }
          return Number(a) - Number(b);
        };

        /**
         * Returns the sum of all numbers in the given array.
         *
         * ```handlebars
         * {{sum "[1, 2, 3, 4, 5]"}}
         * <!-- results in: '15' -->
         * ```
         * @param {Array} `array` Array of numbers to add up.
         * @return {Number}
         * @api public
         */

        helpers.sum = function () {
          var args = [].concat.apply([], arguments);
          var len = args.length;
          var sum = 0;

          while (len--) {
            if (utils.isNumber(args[len])) {
              sum += Number(args[len]);
            }
          }
          return sum;
        };

        /**
         * Multiply number `a` by number `b`.
         *
         * @param {Number} `a` factor
         * @param {Number} `b` multiplier
         * @return {Number}
         * @alias multiply
         * @api public
         */

        helpers.times = function () {
          return helpers.multiply.apply(this, arguments);
        };
      },
      { "./utils": 95, "is-number": 97 },
    ],
    89: [
      function (require, module, exports) {
        "use strict";

        var isNumber = require("is-number");
        var util = require("handlebars-utils");
        var utils = require("./utils");
        var helpers = module.exports;

        /**
         * Format a number to it's equivalent in bytes. If a string is passed,
         * it's length will be formatted and returned.
         *
         * **Examples:**
         *
         *   - `'foo' => 3 B`
         *   - `13661855 => 13.66 MB`
         *   - `825399 => 825.39 kB`
         *   - `1396 => 1.4 kB`
         *
         * @param {Number|String} `number`
         * @return {String}
         * @api public
         */

        helpers.bytes = function (number, precision, options) {
          if (number == null) return "0 B";

          if (!utils.isNumber(number)) {
            number = number.length;
            if (!number) return "0 B";
          }

          if (!utils.isNumber(precision)) {
            precision = 2;
          }

          var abbr = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
          precision = Math.pow(10, precision);
          number = Number(number);

          var len = abbr.length - 1;
          while (len-- >= 0) {
            var size = Math.pow(10, len * 3);
            if (size <= number + 1) {
              number = Math.round((number * precision) / size) / precision;
              number += " " + abbr[len];
              break;
            }
          }

          return number;
        };

        /**
         * Add commas to numbers
         *
         * @param {Number} `num`
         * @return {Number}
         * @api public
         */

        helpers.addCommas = function (num) {
          return num.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
        };

        /**
         * Convert a string or number to a formatted phone number.
         *
         * @param {Number|String} `num` The phone number to format, e.g. `8005551212`
         * @return {Number} Formatted phone number: `(800) 555-1212`
         * @source http://bit.ly/QlPmPr
         * @api public
         */

        helpers.phoneNumber = function (num) {
          num = num.toString();

          return (
            "(" +
            num.substr(0, 3) +
            ") " +
            num.substr(3, 3) +
            "-" +
            num.substr(6, 4)
          );
        };

        /**
         * Abbreviate numbers to the given number of `precision`. This is for
         * general numbers, not size in bytes.
         *
         * @param {Number} `number`
         * @param {Number} `precision`
         * @return {String}
         * @api public
         */

        helpers.toAbbr = function (number, precision) {
          if (!utils.isNumber(number)) {
            number = 0;
          }
          if (util.isUndefined(precision)) {
            precision = 2;
          }

          number = Number(number);
          // 2 decimal places => 100, 3 => 1000, etc.
          precision = Math.pow(10, precision);
          var abbr = ["k", "m", "b", "t", "q"];
          var len = abbr.length - 1;

          while (len >= 0) {
            var size = Math.pow(10, (len + 1) * 3);
            if (size <= number + 1) {
              number = Math.round((number * precision) / size) / precision;
              number += abbr[len];
              break;
            }
            len--;
          }
          return number;
        };

        /**
         * Returns a string representing the given number in exponential notation.
         *
         * ```handlebars
         * {{toExponential number digits}};
         * ```
         * @param {Number} `number`
         * @param {Number} `fractionDigits` Optional. An integer specifying the number of digits to use after the decimal point. Defaults to as many digits as necessary to specify the number.
         * @return {Number}
         * @api public
         */

        helpers.toExponential = function (number, digits) {
          if (!utils.isNumber(number)) {
            number = 0;
          }
          if (util.isUndefined(digits)) {
            digits = 0;
          }
          return Number(number).toExponential(digits);
        };

        /**
         * Formats the given number using fixed-point notation.
         *
         * ```handlebars
         * {{toFixed "1.1234" 2}}
         * //=> '1.12'
         * ```
         * @param {Number} `number`
         * @param {Number} `digits` (Optional) The number of digits to appear after the decimal point; this may be a value between 0 and 20. If this argument is omitted, it is treated as 0.
         * @return {String} A string representing the given number using fixed-point notation.
         * @api public
         */

        helpers.toFixed = function (number, digits) {
          if (!utils.isNumber(number)) {
            number = 0;
          }
          if (!isNumber(digits)) {
            digits = 0;
          }
          return Number(number).toFixed(digits);
        };

        /**
         * @param {Number} `number`
         * @return {Number}
         * @api public
         */

        helpers.toFloat = function (number) {
          return parseFloat(number);
        };

        /**
         * @param {Number} `number`
         * @return {Number}
         * @api public
         */

        helpers.toInt = function (number) {
          return parseInt(number, 10);
        };

        /**
         * Returns a string representing the `Number` object to the specified precision.
         *
         * ```handlebars
         * {{toPrecision "1.1234" 2}}
         * //=> '1.1'
         * ```
         * @param {Number} `number`
         * @param {Number} `precision` (Optional) An integer specifying the number of significant digits. If precison is not between 1 and 100 (inclusive), it will be coerced to `0`.
         * @return {String} A string representing a Number object in fixed-point or exponential notation rounded to precision significant digits.
         * @api public
         */

        helpers.toPrecision = function (number, precision) {
          if (!utils.isNumber(number)) {
            number = 0;
          }
          if (!isNumber(precision)) {
            precision = 1;
          }
          return Number(number).toPrecision(precision);
        };
      },
      { "./utils": 95, "handlebars-utils": 99, "is-number": 97 },
    ],
    90: [
      function (require, module, exports) {
        "use strict";

        var hasOwn = Object.hasOwnProperty;
        var util = require("handlebars-utils");
        var array = require("./array");
        var utils = require("./utils/");
        var helpers = module.exports;

        /**
         * Extend the context with the properties of other objects.
         * A shallow merge is performed to avoid mutating the context.
         *
         * @param {Object} `objects` One or more objects to extend.
         * @return {Object}
         * @api public
         */

        helpers.extend = function (/*objects*/) {
          var args = [].slice.call(arguments);
          var opts = {};

          if (util.isOptions(args[args.length - 1])) {
            // remove handlebars options object
            opts = args.pop().hash;
            // re-add handlebars options.hash object
            args.push(opts);
          }

          var context = {};
          for (var i = 0; i < args.length; i++) {
            var obj = args[i];
            if (util.isObject(obj)) {
              var keys = Object.keys(obj);
              for (var j = 0; j < keys.length; j++) {
                var key = keys[j];
                context[key] = obj[key];
              }
            }
          }

          return context;
        };

        /**
         * Block helper that iterates over the properties of
         * an object, exposing each key and value on the context.
         *
         * @param {Object} `context`
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.forIn = function (obj, options) {
          if (!util.isOptions(options)) {
            return obj.inverse(this);
          }

          var data = utils.createFrame(options, options.hash);
          var result = "";

          for (var key in obj) {
            data.key = key;
            result += options.fn(obj[key], { data: data });
          }
          return result;
        };

        /**
         * Block helper that iterates over the **own** properties of
         * an object, exposing each key and value on the context.
         *
         * @param {Object} `obj` The object to iterate over.
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.forOwn = function (obj, options) {
          if (!util.isOptions(options)) {
            return obj.inverse(this);
          }

          var data = utils.createFrame(options, options.hash);
          var result = "";

          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              data.key = key;
              result += options.fn(obj[key], { data: data });
            }
          }
          return result;
        };

        /**
         * Take arguments and, if they are string or number, convert them to a dot-delineated object property path.
         *
         * @param {String|Number} `prop` The property segments to assemble (can be multiple).
         * @return {String}
         * @api public
         */

        helpers.toPath = function (/*prop*/) {
          var prop = [];
          for (var i = 0; i < arguments.length; i++) {
            if (
              typeof arguments[i] === "string" ||
              typeof arguments[i] === "number"
            ) {
              prop.push(arguments[i]);
            }
          }
          return prop.join(".");
        };

        /**
         * Use property paths (`a.b.c`) to get a value or nested value from
         * the context. Works as a regular helper or block helper.
         *
         * @param {String} `prop` The property to get, optionally using dot notation for nested properties.
         * @param {Object} `context` The context object
         * @param {Object} `options` The handlebars options object, if used as a block helper.
         * @return {String}
         * @block
         * @api public
         */

        helpers.get = function (prop, context, options) {
          var val = utils.get(context, prop);
          if (options && options.fn) {
            return val ? options.fn(val) : options.inverse(context);
          }
          return val;
        };

        /**
         * Use property paths (`a.b.c`) to get an object from
         * the context. Differs from the `get` helper in that this
         * helper will return the actual object, including the
         * given property key. Also, this helper does not work as a
         * block helper.
         *
         * @param {String} `prop` The property to get, optionally using dot notation for nested properties.
         * @param {Object} `context` The context object
         * @return {String}
         * @api public
         */

        helpers.getObject = function (prop, context) {
          return utils.getObject(context, prop);
        };

        /**
         * Return true if `key` is an own, enumerable property
         * of the given `context` object.
         *
         * ```handlebars
         * {{hasOwn context key}}
         * ```
         *
         * @param {String} `key`
         * @param {Object} `context` The context object.
         * @return {Boolean}
         * @api public
         */

        helpers.hasOwn = function (context, key) {
          return hasOwn.call(context, key);
        };

        /**
         * Return true if `value` is an object.
         *
         * ```handlebars
         * {{isObject "foo"}}
         * //=> false
         * ```
         * @param {String} `value`
         * @return {Boolean}
         * @api public
         */

        helpers.isObject = function (value) {
          return utils.typeOf(value) === "object";
        };

        /**
         * Parses the given string using `JSON.parse`.
         *
         * ```handlebars
         * <!-- string: '{"foo": "bar"}' -->
         * {{JSONparse string}}
         * <!-- results in: { foo: 'bar' } -->
         * ```
         * @param {String} `string` The string to parse
         * @contributor github.com/keeganstreet
         * @block
         * @api public
         */

        helpers.JSONparse = function (str, options) {
          return JSON.parse(str);
        };

        /**
         * Stringify an object using `JSON.stringify`.
         *
         * ```handlebars
         * <!-- object: { foo: 'bar' } -->
         * {{JSONstringify object}}
         * <!-- results in: '{"foo": "bar"}' -->
         * ```
         * @param {Object} `obj` Object to stringify
         * @return {String}
         * @api public
         */

        helpers.JSONstringify = function (obj, indent) {
          if (!utils.isNumber(indent)) {
            indent = 0;
          }
          return JSON.stringify(obj, null, indent);
        };

        /**
         * Deeply merge the properties of the given `objects` with the
         * context object.
         *
         * @param {Object} `object` The target object. Pass an empty object to shallow clone.
         * @param {Object} `objects`
         * @return {Object}
         * @api public
         */

        helpers.merge = function (context /*, objects, options*/) {
          var args = [].slice.call(arguments);
          var opts = {};

          if (util.isOptions(args[args.length - 1])) {
            // remove handlebars options object
            opts = args.pop().hash;
            // re-add options.hash
            args.push(opts);
          }

          return Object.assign.apply(null, args);
        };

        /**
         * Alias for parseJSON. this will be
         * deprecated in a future release
         */

        helpers.parseJSON = helpers.JSONparse;

        /**
         * Pick properties from the context object.
         *
         * @param {Array|String} `properties` One or more properties to pick.
         * @param {Object} `context`
         * @param {Object} `options` Handlebars options object.
         * @return {Object} Returns an object with the picked values. If used as a block helper, the values are passed as context to the inner block. If no values are found, the context is passed to the inverse block.
         * @block
         * @api public
         */

        helpers.pick = function (props, context, options) {
          var keys = array.arrayify(props);
          var len = keys.length,
            i = -1;
          var result = {};

          while (++i < len) {
            result = helpers.extend(
              {},
              result,
              utils.getObject(context, keys[i])
            );
          }

          if (options.fn) {
            if (Object.keys(result).length) {
              return options.fn(result);
            }
            return options.inverse(context);
          }
          return result;
        };

        /**
         * Alias for JSONstringify. this will be
         * deprecated in a future release
         */

        helpers.stringify = helpers.JSONstringify;
      },
      { "./array": 81, "./utils/": 95, "handlebars-utils": 99 },
    ],
    91: [
      function (require, module, exports) {
        "use strict";

        var util = require("handlebars-utils");
        var utils = require("./utils");
        var helpers = module.exports;

        /**
         * Convert the given string to a regular expression.
         *
         * ```handlebars
         * {{toRegex "foo"}}
         * <!-- results in: /foo/ -->
         * ```
         * @param {String} `str`
         * @return {RegExp}
         * @api public
         */

        helpers.toRegex = function (str, locals, options) {
          var opts = util.options({}, locals, options);
          return new RegExp(str, opts.flags);
        };

        /**
         * Returns true if the given `str` matches the given regex. A regex can
         * be passed on the context, or using the [toRegex](#toregex) helper as a
         * subexpression.
         *
         * ```handlebars
         * {{test "bar" (toRegex "foo")}}
         * <!-- results in: false -->
         * {{test "foobar" (toRegex "foo")}}
         * <!-- results in: true -->
         * {{test "foobar" (toRegex "^foo$")}}
         * <!-- results in: false -->
         * ```
         * @param {String} `str`
         * @return {RegExp}
         * @api public
         */

        helpers.test = function (str, regex) {
          if (!util.isString(str)) {
            return false;
          }
          if (!utils.typeOf(regex) === "regexp") {
            throw new TypeError("expected a regular expression");
          }
          return regex.test(str);
        };
      },
      { "./utils": 95, "handlebars-utils": 99 },
    ],
    92: [
      function (require, module, exports) {
        "use strict";

        var isNumber = require("is-number");
        var util = require("handlebars-utils");
        var utils = require("./utils");
        var helpers = module.exports;

        /**
         * Append the specified `suffix` to the given string.
         *
         * ```handlebars
         * <!-- given that "item.stem" is "foo" -->
         * {{append item.stem ".html"}}
         * <!-- results in:  'foo.html' -->
         * ```
         * @param {String} `str`
         * @param {String} `suffix`
         * @return {String}
         * @api public
         */

        helpers.append = function (str, suffix) {
          if (typeof str === "string" && typeof suffix === "string") {
            return str + suffix;
          }
          return str;
        };

        /**
         * camelCase the characters in the given `string`.
         *
         * ```handlebars
         * {{camelcase "foo bar baz"}};
         * <!-- results in:  'fooBarBaz' -->
         * ```
         * @param {String} `string` The string to camelcase.
         * @return {String}
         * @api public
         */

        helpers.camelcase = function (str) {
          if (!util.isString(str)) return "";
          return utils.changecase(str, function (ch) {
            return ch.toUpperCase();
          });
        };

        /**
         * Capitalize the first word in a sentence.
         *
         * ```handlebars
         * {{capitalize "foo bar baz"}}
         * <!-- results in:  "Foo bar baz" -->
         * ```
         * @param {String} `str`
         * @return {String}
         * @api public
         */

        helpers.capitalize = function (str) {
          if (!util.isString(str)) return "";
          return str.charAt(0).toUpperCase() + str.slice(1);
        };

        /**
         * Capitalize all words in a string.
         *
         * ```handlebars
         * {{capitalizeAll "foo bar baz"}}
         * <!-- results in:  "Foo Bar Baz" -->
         * ```
         * @param {String} `str`
         * @return {String}
         * @api public
         */

        helpers.capitalizeAll = function (str) {
          if (!util.isString(str)) return "";
          if (util.isString(str)) {
            return str.replace(/\w\S*/g, function (word) {
              return helpers.capitalize(word);
            });
          }
        };

        /**
         * Center a string using non-breaking spaces
         *
         * @param {String} `str`
         * @param {String} `spaces`
         * @return {String}
         * @api public
         */

        helpers.center = function (str, spaces) {
          if (!util.isString(str)) return "";
          var space = "";
          var i = 0;
          while (i < spaces) {
            space += "&nbsp;";
            i++;
          }
          return space + str + space;
        };

        /**
         * Like trim, but removes both extraneous whitespace **and
         * non-word characters** from the beginning and end of a string.
         *
         * ```handlebars
         * {{chop "_ABC_"}}
         * <!-- results in:  'ABC' -->
         *
         * {{chop "-ABC-"}}
         * <!-- results in:  'ABC' -->
         *
         * {{chop " ABC "}}
         * <!-- results in:  'ABC' -->
         * ```
         * @param {String} `string` The string to chop.
         * @return {String}
         * @api public
         */

        helpers.chop = function (str) {
          if (!util.isString(str)) return "";
          return utils.chop(str);
        };

        /**
         * dash-case the characters in `string`. Replaces non-word
         * characters and periods with hyphens.
         *
         * ```handlebars
         * {{dashcase "a-b-c d_e"}}
         * <!-- results in:  'a-b-c-d-e' -->
         * ```
         * @param {String} `string`
         * @return {String}
         * @api public
         */

        helpers.dashcase = function (str) {
          if (!util.isString(str)) return "";
          return utils.changecase(str, function (ch) {
            return "-" + ch;
          });
        };

        /**
         * dot.case the characters in `string`.
         *
         * ```handlebars
         * {{dotcase "a-b-c d_e"}}
         * <!-- results in:  'a.b.c.d.e' -->
         * ```
         * @param {String} `string`
         * @return {String}
         * @api public
         */

        helpers.dotcase = function (str) {
          if (!util.isString(str)) return "";
          return utils.changecase(str, function (ch) {
            return "." + ch;
          });
        };

        /**
         * Lowercase all of the characters in the given string. Alias for [lowercase](#lowercase).
         *
         * ```handlebars
         * {{downcase "aBcDeF"}}
         * <!-- results in:  'abcdef' -->
         * ```
         * @param {String} `string`
         * @return {String}
         * @alias lowercase
         * @api public
         */

        helpers.downcase = function () {
          return helpers.lowercase.apply(this, arguments);
        };

        /**
         * Truncates a string to the specified `length`, and appends
         * it with an elipsis, ``.
         *
         * ```handlebars
         * {{ellipsis (sanitize "<span>foo bar baz</span>"), 7}}
         * <!-- results in:  'foo bar' -->
         * {{ellipsis "foo bar baz", 7}}
         * <!-- results in:  'foo bar' -->
         * ```
         * @param {String} `str`
         * @param {Number} `length` The desired length of the returned string.
         * @return {String} The truncated string.
         * @api public
         */

        helpers.ellipsis = function (str, limit) {
          if (util.isString(str)) {
            if (str.length <= limit) {
              return str;
            }
            return helpers.truncate(str, limit) + "";
          }
        };

        /**
         * Replace spaces in a string with hyphens.
         *
         * ```handlebars
         * {{hyphenate "foo bar baz qux"}}
         * <!-- results in:  "foo-bar-baz-qux" -->
         * ```
         * @param {String} `str`
         * @return {String}
         * @api public
         */

        helpers.hyphenate = function (str) {
          if (!util.isString(str)) return "";
          return str.split(" ").join("-");
        };

        /**
         * Return true if `value` is a string.
         *
         * ```handlebars
         * {{isString "foo"}}
         * <!-- results in:  'true' -->
         * ```
         * @param {String} `value`
         * @return {Boolean}
         * @api public
         */

        helpers.isString = function (value) {
          return typeof value === "string";
        };

        /**
         * Lowercase all characters in the given string.
         *
         * ```handlebars
         * {{lowercase "Foo BAR baZ"}}
         * <!-- results in:  'foo bar baz' -->
         * ```
         * @param {String} `str`
         * @return {String}
         * @api public
         */

        helpers.lowercase = function (str) {
          if (util.isObject(str) && str.fn) {
            return str.fn(this).toLowerCase();
          }
          if (!util.isString(str)) return "";
          return str.toLowerCase();
        };

        /**
         * Return the number of occurrences of `substring` within the
         * given `string`.
         *
         * ```handlebars
         * {{occurrences "foo bar foo bar baz" "foo"}}
         * <!-- results in:  2 -->
         * ```
         * @param {String} `str`
         * @param {String} `substring`
         * @return {Number} Number of occurrences
         * @api public
         */

        helpers.occurrences = function (str, substring) {
          if (!util.isString(str)) return "";
          var len = substring.length;
          var pos = 0;
          var n = 0;

          while ((pos = str.indexOf(substring, pos)) > -1) {
            n++;
            pos += len;
          }
          return n;
        };

        /**
         * PascalCase the characters in `string`.
         *
         * ```handlebars
         * {{pascalcase "foo bar baz"}}
         * <!-- results in:  'FooBarBaz' -->
         * ```
         * @param {String} `string`
         * @return {String}
         * @api public
         */

        helpers.pascalcase = function (str) {
          if (!util.isString(str)) return "";
          str = utils.changecase(str, function (ch) {
            return ch.toUpperCase();
          });
          return str.charAt(0).toUpperCase() + str.slice(1);
        };

        /**
         * path/case the characters in `string`.
         *
         * ```handlebars
         * {{pathcase "a-b-c d_e"}}
         * <!-- results in:  'a/b/c/d/e' -->
         * ```
         * @param {String} `string`
         * @return {String}
         * @api public
         */

        helpers.pathcase = function (str) {
          if (!util.isString(str)) return "";
          return utils.changecase(str, function (ch) {
            return "/" + ch;
          });
        };

        /**
         * Replace spaces in the given string with pluses.
         *
         * ```handlebars
         * {{plusify "foo bar baz"}}
         * <!-- results in:  'foo+bar+baz' -->
         * ```
         * @param {String} `str` The input string
         * @return {String} Input string with spaces replaced by plus signs
         * @source Stephen Way <https://github.com/stephenway>
         * @api public
         */

        helpers.plusify = function (str, ch) {
          if (!util.isString(str)) return "";
          if (!util.isString(ch)) ch = " ";
          return str.split(ch).join("+");
        };

        /**
         * Prepends the given `string` with the specified `prefix`.
         *
         * ```handlebars
         * <!-- given that "val" is "bar" -->
         * {{prepend val "foo-"}}
         * <!-- results in:  'foo-bar' -->
         * ```
         * @param {String} `str`
         * @param {String} `prefix`
         * @return {String}
         * @api public
         */

        helpers.prepend = function (str, prefix) {
          return typeof str === "string" && typeof prefix === "string"
            ? prefix + str
            : str;
        };

        /**
         * Render a block without processing mustache templates inside the block.
         *
         * ```handlebars
         * {{{{#raw}}}}
         * {{foo}}
         * {{{{/raw}}}}
         * <!-- results in:  '{{foo}}' -->
         * ```
         *
         * @param {Object} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.raw = function (options) {
          var str = options.fn();
          var opts = util.options(this, options);
          if (opts.escape !== false) {
            var idx = 0;
            while ((idx = str.indexOf("{{", idx)) !== -1) {
              if (str[idx - 1] !== "\\") {
                str = str.slice(0, idx) + "\\" + str.slice(idx);
              }
              idx += 3;
            }
          }
          return str;
        };

        /**
         * Remove all occurrences of `substring` from the given `str`.
         *
         * ```handlebars
         * {{remove "a b a b a b" "a "}}
         * <!-- results in:  'b b b' -->
         * ```
         * @param {String} `str`
         * @param {String} `substring`
         * @return {String}
         * @api public
         */

        helpers.remove = function (str, ch) {
          if (!util.isString(str)) return "";
          if (!util.isString(ch)) return str;
          return str.split(ch).join("");
        };

        /**
         * Remove the first occurrence of `substring` from the given `str`.
         *
         * ```handlebars
         * {{remove "a b a b a b" "a"}}
         * <!-- results in:  ' b a b a b' -->
         * ```
         * @param {String} `str`
         * @param {String} `substring`
         * @return {String}
         * @api public
         */

        helpers.removeFirst = function (str, ch) {
          if (!util.isString(str)) return "";
          if (!util.isString(ch)) return str;
          return str.replace(ch, "");
        };

        /**
         * Replace all occurrences of substring `a` with substring `b`.
         *
         * ```handlebars
         * {{replace "a b a b a b" "a" "z"}}
         * <!-- results in:  'z b z b z b' -->
         * ```
         * @param {String} `str`
         * @param {String} `a`
         * @param {String} `b`
         * @return {String}
         * @api public
         */

        helpers.replace = function (str, a, b) {
          if (!util.isString(str)) return "";
          if (!util.isString(a)) return str;
          if (!util.isString(b)) b = "";
          return str.split(a).join(b);
        };

        /**
         * Replace the first occurrence of substring `a` with substring `b`.
         *
         * ```handlebars
         * {{replace "a b a b a b" "a" "z"}}
         * <!-- results in:  'z b a b a b' -->
         * ```
         * @param {String} `str`
         * @param {String} `a`
         * @param {String} `b`
         * @return {String}
         * @api public
         */

        helpers.replaceFirst = function (str, a, b) {
          if (!util.isString(str)) return "";
          if (!util.isString(a)) return str;
          if (!util.isString(b)) b = "";
          return str.replace(a, b);
        };

        /**
         * Reverse a string.
         *
         * ```handlebars
         * {{reverse "abcde"}}
         * <!-- results in:  'edcba' -->
         * ```
         * @param {String} `str`
         * @return {String}
         * @api public
         */

        helpers.reverse = function (str) {
          if (!util.isString(str)) return "";
          return str.split("").reverse().join("");
        };

        /**
         * Sentence case the given string
         *
         * ```handlebars
         * {{sentence "hello world. goodbye world."}}
         * <!-- results in:  'Hello world. Goodbye world.' -->
         * ```
         * @param {String} `str`
         * @return {String}
         * @api public
         */

        helpers.sentence = function (str) {
          if (!util.isString(str)) return "";
          return str.replace(/((?:\S[^\.\?\!]*)[\.\?\!]*)/g, function (txt) {
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
          });
        };

        /**
         * snake_case the characters in the given `string`.
         *
         * ```handlebars
         * {{snakecase "a-b-c d_e"}}
         * <!-- results in:  'a_b_c_d_e' -->
         * ```
         * @param {String} `string`
         * @return {String}
         * @api public
         */

        helpers.snakecase = function (str) {
          if (!util.isString(str)) return "";
          return utils.changecase(str, function (ch) {
            return "_" + ch;
          });
        };

        /**
         * Split `string` by the given `character`.
         *
         * ```handlebars
         * {{split "a,b,c" ","}}
         * <!-- results in:  ['a', 'b', 'c'] -->
         * ```
         * @param {String} `string` The string to split.
         * @return {String} `character` Default is an empty string.
         * @api public
         */

        helpers.split = function (str, ch) {
          if (!util.isString(str)) return "";
          if (!util.isString(ch)) ch = ",";
          return str.split(ch);
        };

        /**
         * Tests whether a string begins with the given prefix.
         *
         * ```handlebars
         * {{#startsWith "Goodbye" "Hello, world!"}}
         *   Whoops
         * {{else}}
         *   Bro, do you even hello world?
         * {{/startsWith}}
         * ```
         * @contributor Dan Fox <http://github.com/iamdanfox>
         * @param {String} `prefix`
         * @param {String} `testString`
         * @param {String} `options`
         * @return {String}
         * @block
         * @api public
         */

        helpers.startsWith = function (prefix, str, options) {
          var args = [].slice.call(arguments);
          options = args.pop();
          if (util.isString(str) && str.indexOf(prefix) === 0) {
            return options.fn(this);
          }
          if (typeof options.inverse === "function") {
            return options.inverse(this);
          }
          return "";
        };

        /**
         * Title case the given string.
         *
         * ```handlebars
         * {{titleize "this is title case"}}
         * <!-- results in:  'This Is Title Case' -->
         * ```
         * @param {String} `str`
         * @return {String}
         * @api public
         */

        helpers.titleize = function (str) {
          if (!util.isString(str)) return "";
          var title = str.replace(/[- _]+/g, " ");
          var words = title.split(" ");
          var len = words.length;
          var res = [];
          var i = 0;
          while (len--) {
            var word = words[i++];
            res.push(exports.capitalize(word));
          }
          return res.join(" ");
        };

        /**
         * Removes extraneous whitespace from the beginning and end
         * of a string.
         *
         * ```handlebars
         * {{trim " ABC "}}
         * <!-- results in:  'ABC' -->
         * ```
         * @param {String} `string` The string to trim.
         * @return {String}
         * @api public
         */

        helpers.trim = function (str) {
          return typeof str === "string" ? str.trim() : "";
        };

        /**
         * Removes extraneous whitespace from the beginning of a string.
         *
         * ```handlebars
         * {{trim " ABC "}}
         * <!-- results in:  'ABC ' -->
         * ```
         * @param {String} `string` The string to trim.
         * @return {String}
         * @api public
         */

        helpers.trimLeft = function (str) {
          if (util.isString(str)) {
            return str.replace(/^\s+/, "");
          }
        };

        /**
         * Removes extraneous whitespace from the end of a string.
         *
         * ```handlebars
         * {{trimRight " ABC "}}
         * <!-- results in:  ' ABC' -->
         * ```
         * @param {String} `string` The string to trim.
         * @return {String}
         * @api public
         */

        helpers.trimRight = function (str) {
          if (util.isString(str)) {
            return str.replace(/\s+$/, "");
          }
        };

        /**
         * Truncate a string to the specified `length`. Also see [ellipsis](#ellipsis).
         *
         * ```handlebars
         * truncate("foo bar baz", 7);
         * <!-- results in:  'foo bar' -->
         * truncate(sanitize("<span>foo bar baz</span>", 7));
         * <!-- results in:  'foo bar' -->
         * ```
         * @param {String} `str`
         * @param {Number} `limit` The desired length of the returned string.
         * @param {String} `suffix` Optionally supply a string to use as a suffix to
         * denote when the string has been truncated. Otherwise an ellipsis (``) will be used.
         * @return {String} The truncated string.
         * @api public
         */

        helpers.truncate = function (str, limit, suffix) {
          if (util.isString(str)) {
            if (typeof suffix !== "string") {
              suffix = "";
            }
            if (str.length > limit) {
              return str.slice(0, limit - suffix.length) + suffix;
            }
            return str;
          }
        };

        /**
         * Truncate a string to have the specified number of words.
         * Also see [truncate](#truncate).
         *
         * ```handlebars
         * truncateWords("foo bar baz", 1);
         * <!-- results in:  'foo' -->
         * truncateWords("foo bar baz", 2);
         * <!-- results in:  'foo bar' -->
         * truncateWords("foo bar baz", 3);
         * <!-- results in:  'foo bar baz' -->
         * ```
         * @param {String} `str`
         * @param {Number} `limit` The desired length of the returned string.
         * @param {String} `suffix` Optionally supply a string to use as a suffix to
         * denote when the string has been truncated.
         * @return {String} The truncated string.
         * @api public
         */

        helpers.truncateWords = function (str, count, suffix) {
          if (util.isString(str) && isNumber(count)) {
            if (typeof suffix !== "string") {
              suffix = "";
            }

            var num = Number(count);
            var arr = str.split(/[ \t]/);
            if (num > arr.length) {
              arr = arr.slice(0, num);
            }

            var val = arr.join(" ").trim();
            return val + suffix;
          }
        };

        /**
         * Uppercase all of the characters in the given string. Alias for [uppercase](#uppercase).
         *
         * ```handlebars
         * {{upcase "aBcDeF"}}
         * <!-- results in:  'ABCDEF' -->
         * ```
         * @param {String} `string`
         * @return {String}
         * @alias uppercase
         * @api public
         */

        helpers.upcase = function () {
          return helpers.uppercase.apply(this, arguments);
        };

        /**
         * Uppercase all of the characters in the given string. If used as a
         * block helper it will uppercase the entire block. This helper
         * does not support inverse blocks.
         *
         * ```handlebars
         * {{uppercase "aBcDeF"}}
         * <!-- results in:  'ABCDEF' -->
         * ```
         * @related capitalize capitalizeAll
         * @param {String} `str` The string to uppercase
         * @param {Object} `options` Handlebars options object
         * @return {String}
         * @block
         * @api public
         */

        helpers.uppercase = function (str) {
          if (util.isObject(str) && str.fn) {
            return str.fn(this).toUpperCase();
          }
          if (!util.isString(str)) return "";
          return str.toUpperCase();
        };
      },
      { "./utils": 95, "handlebars-utils": 99, "is-number": 97 },
    ],
    93: [
      function (require, module, exports) {
        "use strict";

        var url = require("url");
        var util = require("handlebars-utils");
        var querystring = require("querystring");
        var helpers = module.exports;

        /**
         * Encodes a Uniform Resource Identifier (URI) component
         * by replacing each instance of certain characters by
         * one, two, three, or four escape sequences representing
         * the UTF-8 encoding of the character.
         *
         * @param {String} `str` The un-encoded string
         * @return {String} The endcoded string
         * @api public
         */

        helpers.encodeURI = function (str) {
          if (util.isString(str)) {
            return encodeURIComponent(str);
          }
        };

        /**
         * Escape the given string by replacing characters with escape sequences.
         * Useful for allowing the string to be used in a URL, etc.
         *
         * @param {String} `str`
         * @return {String} Escaped string.
         * @api public
         */

        helpers.escape = function (str) {
          if (util.isString(str)) {
            return querystring.escape(str);
          }
        };

        /**
         * Decode a Uniform Resource Identifier (URI) component.
         *
         * @param {String} `str`
         * @return {String}
         * @api public
         */

        helpers.decodeURI = function (str) {
          if (util.isString(str)) {
            return decodeURIComponent(str);
          }
        };

        /**
         * Alias for [encodeURI](#encodeuri).
         * @api public
         */

        helpers.url_encode = function () {
          return helpers.encodeURI.apply(this, arguments);
        };

        /**
         * Alias for [decodeURI](#decodeuri).
         * @api public
         */

        helpers.url_decode = function (val) {
          return helpers.decodeURI.apply(this, arguments);
        };

        /**
         * Take a base URL, and a href URL, and resolve them as a
         * browser would for an anchor tag.
         *
         * @param {String} `base`
         * @param {String} `href`
         * @return {String}
         * @api public
         */

        helpers.urlResolve = function (base, href) {
          return url.resolve(base, href);
        };

        /**
         * Parses a `url` string into an object.
         *
         * @param {String} `str` URL string
         * @return {String} Returns stringified JSON
         * @api public
         */

        helpers.urlParse = function (str) {
          return url.parse(str);
        };

        /**
         * Strip the query string from the given `url`.
         *
         * @param {String} `url`
         * @return {String} the url without the queryString
         * @api public
         */

        helpers.stripQuerystring = function (str) {
          if (util.isString(str)) {
            return str.split("?")[0];
          }
        };

        /**
         * Strip protocol from a `url`. Useful for displaying media that
         * may have an 'http' protocol on secure connections.
         *
         * ```handlebars
         * <!-- url = 'http://foo.bar' -->
         * {{stripProtocol url}}
         * <!-- results in: '//foo.bar' -->
         * ```
         * @param {String} `str`
         * @return {String} the url with http protocol stripped
         * @api public
         */

        helpers.stripProtocol = function (str) {
          if (util.isString(str)) {
            var parsed = url.parse(str);
            parsed.protocol = "";
            return parsed.format();
          }
        };
      },
      { "handlebars-utils": 99, querystring: 183, url: 259 },
    ],
    94: [
      function (require, module, exports) {
        "use strict";

        var util = require("handlebars-utils");
        var striptags = require("striptags");

        /**
         * Expose `utils`
         */

        var html = module.exports;

        /**
         * Remove extra newlines from HTML, respect indentation.
         *
         * @param {String} html
         * @return {String}
         * @api public
         */

        html.condense = function (str) {
          return str.replace(/(\r\n|\r|\n|\u2028|\u2029) {2,}/g, "\n");
        };

        /**
         * Add a single newline above code comments in HTML
         *
         * @param {String} `html`
         * @return {String}
         * @api public
         */

        html.padcomments = function (str) {
          return str.replace(/(\s*<!--)/g, "\n$1");
        };

        /**
         * Parse HTML tag attributes from the `options.hash`.
         *
         * @param {Object} `hash` Helper options hash, e.g. `{foo: 'bar'}`
         * @return {String} Stringified attributes, e.g. `foo="bar"`
         * @api public
         */

        html.parseAttributes = function parseAttributes(hash) {
          return Object.keys(hash)
            .map(function (key) {
              var val = String(hash[key]).replace(/^['"]|["']$/g, "");
              return key + '="' + val + '"';
            })
            .join(" ");
        };

        /**
         * Strip HTML tags from a string, so that only the text nodes
         * are preserved.
         *
         * ```handlebars
         * {{sanitize "<span>foo</span>"}}
         * //=> 'foo'
         * ```
         *
         * @param {String} `str` The string of HTML to sanitize.
         * @return {String}
         * @api public
         */

        html.sanitize = function (str) {
          if (!util.isString(str)) return "";
          return striptags(str).trim();
        };

        html.toAttributes = function toAttributes(hash) {
          var res = "";
          var keys = Object.keys(hash);
          for (var i = 0; i < keys.length; i++) {
            var val = hash[keys[i]];
            if (val === true) {
              res += " " + keys[i];
            } else {
              res += " " + keys[i] + '="' + String(val) + '"';
            }
          }
          return res;
        };
      },
      { "handlebars-utils": 99, striptags: 243 },
    ],
    95: [
      function (require, module, exports) {
        "use strict";

        var util = require("handlebars-utils");
        var utils = require("./utils");

        /**
         * Returns true if the given value contains the given
         * `object`, optionally passing a starting index.
         *
         * @param {Array} val
         * @param {Object} obj
         * @param {Number} start
         * @return {Boolean}
         */

        utils.contains = function (val, obj, start) {
          if (val == null || obj == null || !utils.isNumber(val.length)) {
            return false;
          }
          return val.indexOf(obj, start) !== -1;
        };

        /**
         * Remove leading and trailing whitespace and non-word
         * characters from the given string.
         *
         * @param {String} `str`
         * @return {String}
         */

        utils.chop = function (str) {
          if (!util.isString(str)) return "";
          var re = /^[-_.\W\s]+|[-_.\W\s]+$/g;
          return str.trim().replace(re, "");
        };

        /**
         * Change casing on the given `string`, optionally
         * passing a delimiter to use between words in the
         * returned string.
         *
         * ```handlebars
         * utils.changecase('fooBarBaz');
         * //=> 'foo bar baz'
         *
         * utils.changecase('fooBarBaz' '-');
         * //=> 'foo-bar-baz'
         * ```
         * @param {String} `string` The string to change.
         * @return {String}
         * @api public
         */

        utils.changecase = function (str, fn) {
          if (!util.isString(str)) return "";
          if (str.length === 1) {
            return str.toLowerCase();
          }

          str = utils.chop(str).toLowerCase();
          if (typeof fn !== "function") {
            fn = utils.identity;
          }

          var re = /[-_.\W\s]+(\w|$)/g;
          return str.replace(re, function (_, ch) {
            return fn(ch);
          });
        };

        /**
         * Generate a random number
         *
         * @param {Number} `min`
         * @param {Number} `max`
         * @return {Number}
         * @api public
         */

        utils.random = function (min, max) {
          return min + Math.floor(Math.random() * (max - min + 1));
        };

        /**
         * Expose `utils`
         */

        module.exports = utils;
      },
      { "./utils": 96, "handlebars-utils": 99 },
    ],
    96: [
      function (require, module, exports) {
        "use strict";

        var utils = require("lazy-cache")(require);
        var fn = require;
        require = utils;

        // Array utils
        require("array-sort", "sortBy");
        require("arr-flatten", "flatten");

        // Html utils
        require("to-gfm-code-block", "block");
        require("html-tag", "tag");

        // JavaScript language utils
        require("kind-of", "typeOf");

        // matching utils
        require("is-glob");
        require("micromatch", "mm");
        require("falsey");

        // Number utils
        require("is-even");
        require("is-number");

        // Object utils
        require("create-frame");
        require("get-object");
        require("get-value", "get");
        require("for-own");

        // Path utils
        require("relative");
        require = fn;

        /**
         * Expose `utils`
         */

        module.exports = utils;
      },
      {
        "arr-flatten": 2,
        "array-sort": 4,
        "create-frame": 25,
        falsey: 67,
        "for-own": 71,
        "get-object": 76,
        "get-value": 79,
        "html-tag": 110,
        "is-even": 118,
        "is-glob": 122,
        "is-number": 97,
        "kind-of": 132,
        "lazy-cache": 133,
        micromatch: 136,
        relative: 187,
        "to-gfm-code-block": 245,
      },
    ],
    97: [
      function (require, module, exports) {
        /*!
         * is-number <https://github.com/jonschlinkert/is-number>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        module.exports = function isNumber(num) {
          var type = typeof num;

          if (type === "string" || num instanceof String) {
            // an empty string would be coerced to true with the below logic
            if (!num.trim()) return false;
          } else if (type !== "number" && !(num instanceof Number)) {
            return false;
          }

          return num - num + 1 >= 0;
        };
      },
      {},
    ],
    98: [
      function (require, module, exports) {
        "use strict";

        var hasOwn = Object.prototype.hasOwnProperty;

        function noop() {
          return "";
        }

        function getStack(context) {
          return context.$$layoutStack || (context.$$layoutStack = []);
        }

        function applyStack(context) {
          var stack = getStack(context);

          while (stack.length) {
            stack.shift()(context);
          }
        }

        function getActions(context) {
          return context.$$layoutActions || (context.$$layoutActions = {});
        }

        function getActionsByName(context, name) {
          var actions = getActions(context);

          return actions[name] || (actions[name] = []);
        }

        function applyAction(val, action) {
          var context = this;

          function fn() {
            return action.fn(context, action.options);
          }

          switch (action.mode) {
            case "append": {
              return val + fn();
            }

            case "prepend": {
              return fn() + val;
            }

            case "replace": {
              return fn();
            }

            default: {
              return val;
            }
          }
        }

        function mixin(target) {
          var arg,
            key,
            len = arguments.length,
            i = 1;

          for (; i < len; i++) {
            arg = arguments[i];

            if (!arg) {
              continue;
            }

            for (key in arg) {
              // istanbul ignore else
              if (hasOwn.call(arg, key)) {
                target[key] = arg[key];
              }
            }
          }

          return target;
        }

        /**
         * Generates an object of layout helpers.
         *
         * @type {Function}
         * @param {Object} handlebars Handlebars instance.
         * @return {Object} Object of helpers.
         */
        function layouts(handlebars) {
          var helpers = {
            /**
             * @method extend
             * @param {String} name
             * @param {?Object} customContext
             * @param {Object} options
             * @param {Function(Object)} options.fn
             * @param {Object} options.hash
             * @return {String} Rendered partial.
             */
            extend: function (name, customContext, options) {
              // Make `customContext` optional
              if (arguments.length < 3) {
                options = customContext;
                customContext = null;
              }

              options = options || {};

              var fn = options.fn || noop,
                context = mixin({}, this, customContext, options.hash),
                data = handlebars.createFrame(options.data),
                template = handlebars.partials[name];

              // Partial template required
              if (template == null) {
                throw new Error("Missing partial: '" + name + "'");
              }

              // Compile partial, if needed
              if (typeof template !== "function") {
                template = handlebars.compile(template);
              }

              // Add overrides to stack
              getStack(context).push(fn);

              // Render partial
              return template(context, { data: data });
            },

            /**
             * @method embed
             * @param {String} name
             * @param {?Object} customContext
             * @param {Object} options
             * @param {Function(Object)} options.fn
             * @param {Object} options.hash
             * @return {String} Rendered partial.
             */
            embed: function () {
              var context = mixin({}, this || {});

              // Reset context
              context.$$layoutStack = null;
              context.$$layoutActions = null;

              // Extend
              return helpers.extend.apply(context, arguments);
            },

            /**
             * @method block
             * @param {String} name
             * @param {Object} options
             * @param {Function(Object)} options.fn
             * @return {String} Modified block content.
             */
            block: function (name, options) {
              options = options || {};

              var fn = options.fn || noop,
                data = handlebars.createFrame(options.data),
                context = this || {};

              applyStack(context);

              return getActionsByName(context, name).reduce(
                applyAction.bind(context),
                fn(context, { data: data })
              );
            },

            /**
             * @method content
             * @param {String} name
             * @param {Object} options
             * @param {Function(Object)} options.fn
             * @param {Object} options.hash
             * @param {String} options.hash.mode
             * @return {String} Always empty.
             */
            content: function (name, options) {
              options = options || {};

              var fn = options.fn,
                data = handlebars.createFrame(options.data),
                hash = options.hash || {},
                mode = hash.mode || "replace",
                context = this || {};

              applyStack(context);

              // Getter
              if (!fn) {
                return name in getActions(context);
              }

              // Setter
              getActionsByName(context, name).push({
                options: { data: data },
                mode: mode.toLowerCase(),
                fn: fn,
              });
            },
          };

          return helpers;
        }

        /**
         * Registers layout helpers on a Handlebars instance.
         *
         * @method register
         * @param {Object} handlebars Handlebars instance.
         * @return {Object} Object of helpers.
         * @static
         */
        layouts.register = function (handlebars) {
          var helpers = layouts(handlebars);

          handlebars.registerHelper(helpers);

          return helpers;
        };

        module.exports = layouts;
      },
      {},
    ],
    99: [
      function (require, module, exports) {
        "use strict";

        var util = require("util");
        var type = require("typeof-article");
        var typeOf = require("kind-of");
        var utils = (exports = module.exports);

        /**
         * This code was taken directly from handlebars.
         * https://github.com/wycats/handlebars.js/blob/b55a120e8222785db3dc00096f6afbf91b656e8a/LICENSE
         * Released under the MIT License
         * Copyright (C) 2011-2016 by Yehuda Katz
         */

        utils.extend = extend;
        utils.indexOf = indexOf;
        utils.escapeExpression = escapeExpression;
        utils.isEmpty = isEmpty;
        utils.createFrame = createFrame;
        utils.blockParams = blockParams;
        utils.appendContextPath = appendContextPath;
        var escape = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#x27;",
          "`": "&#x60;",
          "=": "&#x3D;",
        };

        var badChars = /[&<>"'`=]/g;
        var possible = /[&<>"'`=]/;

        function escapeChar(chr) {
          return escape[chr];
        }

        function extend(obj /* , ...source */) {
          for (var i = 1; i < arguments.length; i++) {
            for (var key in arguments[i]) {
              if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
                obj[key] = arguments[i][key];
              }
            }
          }

          return obj;
        }

        var toString = Object.prototype.toString;

        utils.toString = toString;
        // Sourced from lodash
        // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
        /* eslint-disable func-style */
        var isFunction = function isFunction(value) {
          return typeof value === "function";
        };
        // fallback for older versions of Chrome and Safari
        /* istanbul ignore next */
        if (isFunction(/x/)) {
          utils.isFunction = isFunction = function (value) {
            return (
              typeof value === "function" &&
              toString.call(value) === "[object Function]"
            );
          };
        }
        utils.isFunction = isFunction;

        /* eslint-enable func-style */

        /* istanbul ignore next */
        var isArray =
          Array.isArray ||
          function (value) {
            return value && typeof value === "object"
              ? toString.call(value) === "[object Array]"
              : false;
          };

        utils.isArray = isArray;
        // Older IE versions do not directly support indexOf so we must implement our own, sadly.

        function indexOf(array, value) {
          for (var i = 0, len = array.length; i < len; i++) {
            if (array[i] === value) {
              return i;
            }
          }
          return -1;
        }

        function escapeExpression(string) {
          if (typeof string !== "string") {
            // don't escape SafeStrings, since they're already safe
            if (string && string.toHTML) {
              return string.toHTML();
            } else if (string == null) {
              return "";
            } else if (!string) {
              return string + "";
            }

            // Force a string conversion as this will be done by the append regardless and
            // the regex test will do this transparently behind the scenes, causing issues if
            // an object's to string has escaped characters in it.
            string = "" + string;
          }

          if (!possible.test(string)) {
            return string;
          }
          return string.replace(badChars, escapeChar);
        }

        function createFrame(object) {
          var frame = extend({}, object);
          frame._parent = object;
          return frame;
        }

        function blockParams(params, ids) {
          params.path = ids;
          return params;
        }

        function appendContextPath(contextPath, id) {
          return (contextPath ? contextPath + "." : "") + id;
        }

        //
        // The code below this line was not sourced from handlebars
        // --------------------------------------------------------
        //

        utils.expectedType = function (param, expected, actual) {
          var exp = type.types[expected];
          var val = util.inspect(actual);
          return (
            "expected " +
            param +
            " to be " +
            exp +
            " but received " +
            type(actual) +
            ": " +
            val
          );
        };

        /**
         * Returns true if a helper is a block helper.
         *
         * ```js
         * Handlebars.registerHelper('example', function(options) {
         *   if (utils.isBlock(options)) {
         *     // do something if this is a block helper
         *   } else {
         *     // do something else if this is a not block helper
         *   }
         * });
         * ```
         * @param {Object} `options` Helper options object
         * @return {Boolean}
         * @api public
         */

        utils.isBlock = function (options) {
          return (
            utils.isOptions(options) &&
            typeof options.fn === "function" &&
            typeof options.inverse === "function"
          );
        };

        /**
         * Returns the given value or renders the block if it's a block helper.
         *
         * ```js
         * Handlebars.registerHelper('example', function(val, locals, options) {
         *   return utils.fn(val, locals, options);
         * });
         * ```
         * @param {any} `val`
         * @param {Object} `options`
         * @param {Object} `context`
         * @return {String} Either returns the value, or renders the block.
         * @api public
         */

        utils.fn = function (val, context, options) {
          if (utils.isOptions(val)) {
            return utils.fn("", val, options);
          }
          if (utils.isOptions(context)) {
            return utils.fn(val, {}, context);
          }
          return utils.isBlock(options) ? options.fn(context) : val;
        };

        /**
         * Returns the given value or renders the inverse block if it's a block helper.
         *
         * ```js
         * Handlebars.registerHelper('example', function(val, locals, options) {
         *   return utils.inverse(val, locals, options);
         * });
         * ```
         * @param {any} `val`
         * @param {Object} `options`
         * @param {Object} `context`
         * @return {String} Either returns the value, or renders the inverse block.
         * @api public
         */

        utils.inverse = function (val, context, options) {
          if (utils.isOptions(val)) {
            return utils.identity("", val, options);
          }
          if (utils.isOptions(context)) {
            return utils.inverse(val, {}, context);
          }
          return utils.isBlock(options) ? options.inverse(context) : val;
        };

        /**
         * Gets the return value for a helper, by either rendering the block
         * or inverse block if it's a block helper, or returning the given value
         * (when truthy) or an empty string (when falsey) if it's a non-block expression.
         *
         * ```js
         * Handlebars.registerHelper('example', function(val, locals, options) {
         *   return utils.value(val, locals, options);
         * });
         * ```
         * @param {any} `val`
         * @param {Object} `options`
         * @param {Object} `context`
         * @return {String}
         * @api public
         */

        utils.value = function (val, context, options) {
          if (utils.isOptions(val)) {
            return utils.value(null, val, options);
          }
          if (utils.isOptions(context)) {
            return utils.value(val, {}, context);
          }
          if (utils.isBlock(options)) {
            return !!val ? options.fn(context) : options.inverse(context);
          }
          return val;
        };

        /**
         * Returns true if the given value is a handlebar `options` object.
         *
         * ```js
         * Handlebars.registerHelper('example', function(val, locals, options) {
         *   if (utils.isOptions(locals)) {
         *     options = locals;
         *     locals = {};
         *   }
         *   // do stuff
         * });
         * ```
         * @param {Object} `val`
         * @return {Boolean}
         * @api public
         */

        utils.isOptions = function (val) {
          return utils.isObject(val) && utils.isObject(val.hash);
        };

        /**
         * Returns true if the given value is `undefined` or is a handlebars
         * options hash (which means that a value was not passed by the user).
         *
         * ```js
         * Handlebars.registerHelper('example', function(val, options) {
         *   if (utils.isUndefined(val)) {
         *     return '';
         *   }
         *   // do stuff
         * });
         * ```
         * @param {any} `value`
         * @return {Boolean}
         * @api public
         */

        utils.isUndefined = function (val) {
          return val == null || (utils.isOptions(val) && val.hash != null);
        };

        /**
         * Returns true if an `app` propery is on the context, which means
         * the context was created by [assemble][], [templates][], [verb][],
         * or any other library that follows this convention.
         *
         * ```js
         * Handlebars.registerHelper('example', function(val, options) {
         *   var context = options.hash;
         *   if (utils.isApp(this)) {
         *     context = Object.assign({}, this.context, context);
         *   }
         *   // do stuff
         * });
         * ```
         * @param {any} `value`
         * @return {Boolean}
         * @api public
         */

        utils.isApp = function (thisArg) {
          return (
            utils.isObject(thisArg) &&
            utils.isObject(thisArg.options) &&
            utils.isObject(thisArg.app)
          );
        };

        /**
         * Creates an options object from the `context`, `locals` and `options.`
         * Handlebars' `options.hash` is merged onto the options, and if the context
         * is created by [templates][], `this.options` will be merged onto the
         * options as well.
         *
         * @param {Object} `context`
         * @param {Object} `locals` Options or locals
         * @param {Object} `options`
         * @return {Boolean}
         * @api public
         */

        utils.options = function (thisArg, locals, options) {
          if (utils.isOptions(thisArg)) {
            return utils.options({}, locals, thisArg);
          }
          if (utils.isOptions(locals)) {
            return utils.options(thisArg, options, locals);
          }
          options = options || {};
          if (!utils.isOptions(options)) {
            locals = Object.assign({}, locals, options);
          }
          var opts = Object.assign({}, locals, options.hash);
          if (utils.isObject(thisArg)) {
            opts = Object.assign({}, thisArg.options, opts);
          }
          if (opts[options.name]) {
            opts = Object.assign({}, opts[options.name], opts);
          }
          return opts;
        };

        /**
         * Get the context to use for rendering.
         *
         * @param {Object} `thisArg` Optional invocation context `this`
         * @return {Object}
         * @api public
         */

        utils.context = function (thisArg, locals, options) {
          if (utils.isOptions(thisArg)) {
            return utils.context({}, locals, thisArg);
          }
          // ensure args are in the correct order
          if (utils.isOptions(locals)) {
            return utils.context(thisArg, options, locals);
          }
          var appContext = utils.isApp(thisArg) ? thisArg.context : {};
          options = options || {};

          // if "options" is not handlebars options, merge it onto locals
          if (!utils.isOptions(options)) {
            locals = Object.assign({}, locals, options);
          }
          // merge handlebars root data onto locals if specified on the hash
          if (utils.isOptions(options) && options.hash.root === true) {
            locals = Object.assign({}, options.data.root, locals);
          }
          var context = Object.assign({}, appContext, locals, options.hash);
          if (!utils.isApp(thisArg)) {
            context = Object.assign({}, thisArg, context);
          }
          if (utils.isApp(thisArg) && thisArg.view && thisArg.view.data) {
            context = Object.assign({}, context, thisArg.view.data);
          }
          return context;
        };

        /**
         * Returns true if the given value is an object.
         *
         * ```js
         * console.log(utils.isObject(null));
         * //=> false
         * console.log(utils.isObject([]));
         * //=> false
         * console.log(utils.isObject(function() {}));
         * //=> false
         * console.log(utils.isObject({}));
         * //=> true
         * ```
         * @param {Object} `val`
         * @return {Boolean}
         * @api public
         */

        utils.isObject = function (val) {
          return typeOf(val) === "object";
        };

        /**
         * Returns true if the given value is "empty".
         *
         * ```js
         * console.log(utils.isEmpty(0));
         * //=> false
         * console.log(utils.isEmpty(''));
         * //=> true
         * console.log(utils.isEmpty([]));
         * //=> true
         * console.log(utils.isEmpty({}));
         * //=> true
         * ```
         * @name .isEmpty
         * @param {any} `value`
         * @return {Boolean}
         * @api public
         */

        function isEmpty(val) {
          if (val === 0 || typeof val === "boolean") {
            return false;
          }
          if (val == null) {
            return true;
          }
          if (utils.isObject(val)) {
            val = Object.keys(val);
          }
          if (!val.length) {
            return true;
          }
          return false;
        }

        /**
         * Returns the given value. If the value is a function it will be
         * called with the current context, otherwise the value is returned.
         *
         * ```js
         * console.log(utils.result('foo'));
         * //=> 'foo'
         * console.log(utils.result(function() {
         *   return 'foo';
         * }));
         * //=> 'foo'
         * ```
         * @param  {any} `val`
         * @return {any}
         * @api public
         */

        utils.result = function (val) {
          if (typeof val === "function") {
            return val.apply(this, [].slice.call(arguments, 1));
          }
          return val;
        };

        /**
         * Returns the given value as-is, unchanged.
         *
         * ```js
         * console.log(utils.result('foo'));
         * //=> 'foo'
         * console.log(utils.result(function() {
         *   return 'foo';
         * }));
         * //=> [function]
         * ```
         * @param  {any} `val`
         * @return {any}
         * @api public
         */

        utils.identity = function (val) {
          return val;
        };

        /**
         * Return true if `val` is a non-empty string.
         *
         * @param  {any} `val` The value to check
         * @return {Boolean}
         * @api public
         */

        utils.isString = function (val) {
          return typeof val === "string" && val !== "";
        };

        /**
         * Cast the given `val` to an array.
         *
         * ```js
         * console.log(utils.arrayify(''));
         * //=> []
         * console.log(utils.arrayify('foo'));
         * //=> ['foo']
         * console.log(utils.arrayify(['foo']));
         * //=> ['foo']
         * ```
         * @param  {any} `val`
         * @return {Array}
         * @api public
         */

        utils.arrayify = function (val) {
          return val != null ? (Array.isArray(val) ? val : [val]) : [];
        };

        /**
         * Try to parse the given `string` as JSON. Fails
         * gracefully and always returns an object if the value cannot be parsed.
         *
         * @param {String} `string`
         * @return {Object}
         * @api public
         */

        utils.tryParse = function (str) {
          try {
            return JSON.parse(str);
          } catch (err) {}
          return {};
        };
      },
      { "kind-of": 132, "typeof-article": 252, util: 264 },
    ],
    100: [
      function (require, module, exports) {
        "use strict";

        var origSymbol = typeof Symbol !== "undefined" && Symbol;
        var hasSymbolSham = require("./shams");

        module.exports = function hasNativeSymbols() {
          if (typeof origSymbol !== "function") {
            return false;
          }
          if (typeof Symbol !== "function") {
            return false;
          }
          if (typeof origSymbol("foo") !== "symbol") {
            return false;
          }
          if (typeof Symbol("bar") !== "symbol") {
            return false;
          }

          return hasSymbolSham();
        };
      },
      { "./shams": 101 },
    ],
    101: [
      function (require, module, exports) {
        "use strict";

        /* eslint complexity: [2, 18], max-statements: [2, 33] */
        module.exports = function hasSymbols() {
          if (
            typeof Symbol !== "function" ||
            typeof Object.getOwnPropertySymbols !== "function"
          ) {
            return false;
          }
          if (typeof Symbol.iterator === "symbol") {
            return true;
          }

          var obj = {};
          var sym = Symbol("test");
          var symObj = Object(sym);
          if (typeof sym === "string") {
            return false;
          }

          if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
            return false;
          }
          if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
            return false;
          }

          // temp disabled per https://github.com/ljharb/object.assign/issues/17
          // if (sym instanceof Symbol) { return false; }
          // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
          // if (!(symObj instanceof Symbol)) { return false; }

          // if (typeof Symbol.prototype.toString !== 'function') { return false; }
          // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

          var symVal = 42;
          obj[sym] = symVal;
          for (sym in obj) {
            return false;
          } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
          if (
            typeof Object.keys === "function" &&
            Object.keys(obj).length !== 0
          ) {
            return false;
          }

          if (
            typeof Object.getOwnPropertyNames === "function" &&
            Object.getOwnPropertyNames(obj).length !== 0
          ) {
            return false;
          }

          var syms = Object.getOwnPropertySymbols(obj);
          if (syms.length !== 1 || syms[0] !== sym) {
            return false;
          }

          if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
            return false;
          }

          if (typeof Object.getOwnPropertyDescriptor === "function") {
            var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
            if (descriptor.value !== symVal || descriptor.enumerable !== true) {
              return false;
            }
          }

          return true;
        };
      },
      {},
    ],
    102: [
      function (require, module, exports) {
        "use strict";

        var hasSymbols = require("has-symbols/shams");

        module.exports = function hasToStringTagShams() {
          return hasSymbols() && !!Symbol.toStringTag;
        };
      },
      { "has-symbols/shams": 101 },
    ],
    103: [
      function (require, module, exports) {
        /*!
         * has-value <https://github.com/jonschlinkert/has-value>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        var isObject = require("isobject");
        var hasValues = require("has-values");
        var get = require("get-value");

        module.exports = function (val, prop) {
          return hasValues(isObject(val) && prop ? get(val, prop) : val);
        };
      },
      { "get-value": 79, "has-values": 104, isobject: 131 },
    ],
    104: [
      function (require, module, exports) {
        /*!
         * has-values <https://github.com/jonschlinkert/has-values>
         *
         * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var typeOf = require("kind-of");
        var isNumber = require("is-number");

        module.exports = function hasValue(val) {
          // is-number checks for NaN and other edge cases
          if (isNumber(val)) {
            return true;
          }

          switch (typeOf(val)) {
            case "null":
            case "boolean":
            case "function":
              return true;
            case "string":
            case "arguments":
              return val.length !== 0;
            case "error":
              return val.message !== "";
            case "array":
              var len = val.length;
              if (len === 0) {
                return false;
              }
              for (var i = 0; i < len; i++) {
                if (hasValue(val[i])) {
                  return true;
                }
              }
              return false;
            case "file":
            case "map":
            case "set":
              return val.size !== 0;
            case "object":
              var keys = Object.keys(val);
              if (keys.length === 0) {
                return false;
              }
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (hasValue(val[key])) {
                  return true;
                }
              }
              return false;
            default: {
              return false;
            }
          }
        };
      },
      { "is-number": 105, "kind-of": 107 },
    ],
    105: [
      function (require, module, exports) {
        /*!
         * is-number <https://github.com/jonschlinkert/is-number>
         *
         * Copyright (c) 2014-2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        var typeOf = require("kind-of");

        module.exports = function isNumber(num) {
          var type = typeOf(num);

          if (type === "string") {
            if (!num.trim()) return false;
          } else if (type !== "number") {
            return false;
          }

          return num - num + 1 >= 0;
        };
      },
      { "kind-of": 106 },
    ],
    106: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    107: [
      function (require, module, exports) {
        var isBuffer = require("is-buffer");
        var toString = Object.prototype.toString;

        /**
         * Get the native `typeof` a value.
         *
         * @param  {*} `val`
         * @return {*} Native javascript type
         */

        module.exports = function kindOf(val) {
          // primitivies
          if (typeof val === "undefined") {
            return "undefined";
          }
          if (val === null) {
            return "null";
          }
          if (val === true || val === false || val instanceof Boolean) {
            return "boolean";
          }
          if (typeof val === "string" || val instanceof String) {
            return "string";
          }
          if (typeof val === "number" || val instanceof Number) {
            return "number";
          }

          // functions
          if (typeof val === "function" || val instanceof Function) {
            return "function";
          }

          // array
          if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
            return "array";
          }

          // check for instances of RegExp and Date before calling `toString`
          if (val instanceof RegExp) {
            return "regexp";
          }
          if (val instanceof Date) {
            return "date";
          }

          // other objects
          var type = toString.call(val);

          if (type === "[object RegExp]") {
            return "regexp";
          }
          if (type === "[object Date]") {
            return "date";
          }
          if (type === "[object Arguments]") {
            return "arguments";
          }
          if (type === "[object Error]") {
            return "error";
          }
          if (type === "[object Promise]") {
            return "promise";
          }

          // buffer
          if (isBuffer(val)) {
            return "buffer";
          }

          // es6: Map, WeakMap, Set, WeakSet
          if (type === "[object Set]") {
            return "set";
          }
          if (type === "[object WeakSet]") {
            return "weakset";
          }
          if (type === "[object Map]") {
            return "map";
          }
          if (type === "[object WeakMap]") {
            return "weakmap";
          }
          if (type === "[object Symbol]") {
            return "symbol";
          }

          // typed arrays
          if (type === "[object Int8Array]") {
            return "int8array";
          }
          if (type === "[object Uint8Array]") {
            return "uint8array";
          }
          if (type === "[object Uint8ClampedArray]") {
            return "uint8clampedarray";
          }
          if (type === "[object Int16Array]") {
            return "int16array";
          }
          if (type === "[object Uint16Array]") {
            return "uint16array";
          }
          if (type === "[object Int32Array]") {
            return "int32array";
          }
          if (type === "[object Uint32Array]") {
            return "uint32array";
          }
          if (type === "[object Float32Array]") {
            return "float32array";
          }
          if (type === "[object Float64Array]") {
            return "float64array";
          }

          // must be a plain object
          return "object";
        };
      },
      { "is-buffer": 114 },
    ],
    108: [
      function (require, module, exports) {
        "use strict";

        var bind = require("function-bind");

        module.exports = bind.call(
          Function.call,
          Object.prototype.hasOwnProperty
        );
      },
      { "function-bind": 74 },
    ],
    109: [
      function (require, module, exports) {
        "use strict";

        var utils = require("handlebars-utils");
        var moment = require("moment");
        var date = require("date.js");

        module.exports = function dateHelper(str, pattern, options) {
          if (utils.isOptions(pattern)) {
            options = pattern;
            pattern = null;
          }

          if (utils.isOptions(str)) {
            options = str;
            pattern = null;
            str = null;
          }

          // if no args are passed, return a formatted date
          if (str == null && pattern == null) {
            moment.locale("en");
            return moment().format("MMMM DD, YYYY");
          }

          var defaults = { lang: "en", date: new Date(str) };
          var opts = utils.context(this, defaults, options);

          // set the language to use
          moment.locale(opts.lang || opts.language);

          if (opts.datejs === false) {
            return moment(new Date(str)).format(pattern);
          }

          // if both args are strings, this could apply to either lib.
          // so instead of doing magic we'll just ask the user to tell
          // us if the args should be passed to date.js or moment.
          if (typeof str === "string" && typeof pattern === "string") {
            return moment(date(str)).format(pattern);
          }

          // If handlebars, expose moment methods as hash properties
          if (options && options.hash) {
            if (options.context) {
              options.hash = Object.assign({}, options.hash, options.context);
            }

            var res = moment(str);
            for (var key in options.hash) {
              if (typeof res[key] === "function") {
                return res[key](options.hash[key]);
              } else {
                console.error('moment.js does not support "' + key + '"');
              }
            }
          }

          if (utils.isObject(str)) {
            return moment(str).format(pattern);
          }

          // if only a string is passed, assume it's a date pattern ('YYYY')
          if (typeof str === "string" && !pattern) {
            return moment().format(str);
          }

          return moment(str).format(pattern);
        };
      },
      { "date.js": 34, "handlebars-utils": 99, moment: 157 },
    ],
    110: [
      function (require, module, exports) {
        /*!
         * html-tag <https://github.com/jonschlinkert/html-tag>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var typeOf = require("kind-of");
        var isVoid = require("is-self-closing");

        module.exports = function (tag, attribs, text) {
          var voided = text === false || attribs === false;

          if (typeOf(attribs) !== "object") {
            text = attribs;
            attribs = {};
          }

          if (typeof text === "undefined" || text === false) {
            text = "";
          }

          if (typeof text !== "string") {
            throw new TypeError("expected text to be a string");
          }

          var html = "<" + tag;
          for (var key in attribs) {
            var val = attribs[key];
            if (val === true) {
              html += " " + key;
            }
            if (typeof val === "string") {
              html += " " + key + '="' + val + '"';
            }
          }

          if (isVoid(tag) || voided === true) {
            return html + ">" + text;
          }

          return html + ">" + text + "</" + tag + ">";
        };
      },
      { "is-self-closing": 127, "kind-of": 132 },
    ],
    111: [
      function (require, module, exports) {
        if (typeof Object.create === "function") {
          // implementation from standard node.js 'util' module
          module.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              });
            }
          };
        } else {
          // old school shim for old browsers
          module.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function () {};
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            }
          };
        }
      },
      {},
    ],
    112: [
      function (require, module, exports) {
        /*!
         * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
         *
         * Copyright (c) 2015-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var typeOf = require("kind-of");

        // accessor descriptor properties
        var accessor = {
          get: "function",
          set: "function",
          configurable: "boolean",
          enumerable: "boolean",
        };

        function isAccessorDescriptor(obj, prop) {
          if (typeof prop === "string") {
            var val = Object.getOwnPropertyDescriptor(obj, prop);
            return typeof val !== "undefined";
          }

          if (typeOf(obj) !== "object") {
            return false;
          }

          if (has(obj, "value") || has(obj, "writable")) {
            return false;
          }

          if (!has(obj, "get") || typeof obj.get !== "function") {
            return false;
          }

          // tldr: it's valid to have "set" be undefined
          // "set" might be undefined if `Object.getOwnPropertyDescriptor`
          // was used to get the value, and only `get` was defined by the user
          if (
            has(obj, "set") &&
            typeof obj[key] !== "function" &&
            typeof obj[key] !== "undefined"
          ) {
            return false;
          }

          for (var key in obj) {
            if (!accessor.hasOwnProperty(key)) {
              continue;
            }

            if (typeOf(obj[key]) === accessor[key]) {
              continue;
            }

            if (typeof obj[key] !== "undefined") {
              return false;
            }
          }
          return true;
        }

        function has(obj, key) {
          return {}.hasOwnProperty.call(obj, key);
        }

        /**
         * Expose `isAccessorDescriptor`
         */

        module.exports = isAccessorDescriptor;
      },
      { "kind-of": 132 },
    ],
    113: [
      function (require, module, exports) {
        "use strict";

        var hasToStringTag = require("has-tostringtag/shams")();
        var callBound = require("call-bind/callBound");

        var $toString = callBound("Object.prototype.toString");

        var isStandardArguments = function isArguments(value) {
          if (
            hasToStringTag &&
            value &&
            typeof value === "object" &&
            Symbol.toStringTag in value
          ) {
            return false;
          }
          return $toString(value) === "[object Arguments]";
        };

        var isLegacyArguments = function isArguments(value) {
          if (isStandardArguments(value)) {
            return true;
          }
          return (
            value !== null &&
            typeof value === "object" &&
            typeof value.length === "number" &&
            value.length >= 0 &&
            $toString(value) !== "[object Array]" &&
            $toString(value.callee) === "[object Function]"
          );
        };

        var supportsStandardArguments = (function () {
          return isStandardArguments(arguments);
        })();

        isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

        module.exports = supportsStandardArguments
          ? isStandardArguments
          : isLegacyArguments;
      },
      { "call-bind/callBound": 12, "has-tostringtag/shams": 102 },
    ],
    114: [
      function (require, module, exports) {
        /*!
         * Determine if an object is a Buffer
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */

        // The _isBuffer check is for Safari 5-7 support, because it's missing
        // Object.prototype.constructor. Remove this eventually
        module.exports = function (obj) {
          return (
            obj != null &&
            (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
          );
        };

        function isBuffer(obj) {
          return (
            !!obj.constructor &&
            typeof obj.constructor.isBuffer === "function" &&
            obj.constructor.isBuffer(obj)
          );
        }

        // For Node v0.10 support. Remove this eventually.
        function isSlowBuffer(obj) {
          return (
            typeof obj.readFloatLE === "function" &&
            typeof obj.slice === "function" &&
            isBuffer(obj.slice(0, 0))
          );
        }
      },
      {},
    ],
    115: [
      function (require, module, exports) {
        "use strict";

        var fnToStr = Function.prototype.toString;
        var reflectApply =
          typeof Reflect === "object" && Reflect !== null && Reflect.apply;
        var badArrayLike;
        var isCallableMarker;
        if (
          typeof reflectApply === "function" &&
          typeof Object.defineProperty === "function"
        ) {
          try {
            badArrayLike = Object.defineProperty({}, "length", {
              get: function () {
                throw isCallableMarker;
              },
            });
            isCallableMarker = {};
            // eslint-disable-next-line no-throw-literal
            reflectApply(
              function () {
                throw 42;
              },
              null,
              badArrayLike
            );
          } catch (_) {
            if (_ !== isCallableMarker) {
              reflectApply = null;
            }
          }
        } else {
          reflectApply = null;
        }

        var constructorRegex = /^\s*class\b/;
        var isES6ClassFn = function isES6ClassFunction(value) {
          try {
            var fnStr = fnToStr.call(value);
            return constructorRegex.test(fnStr);
          } catch (e) {
            return false; // not a function
          }
        };

        var tryFunctionObject = function tryFunctionToStr(value) {
          try {
            if (isES6ClassFn(value)) {
              return false;
            }
            fnToStr.call(value);
            return true;
          } catch (e) {
            return false;
          }
        };
        var toStr = Object.prototype.toString;
        var objectClass = "[object Object]";
        var fnClass = "[object Function]";
        var genClass = "[object GeneratorFunction]";
        var ddaClass = "[object HTMLAllCollection]"; // IE 11
        var ddaClass2 = "[object HTML document.all class]";
        var ddaClass3 = "[object HTMLCollection]"; // IE 9-10
        var hasToStringTag =
          typeof Symbol === "function" && !!Symbol.toStringTag; // better: use `has-tostringtag`

        var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

        var isDDA = function isDocumentDotAll() {
          return false;
        };
        if (typeof document === "object") {
          // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
          var all = document.all;
          if (toStr.call(all) === toStr.call(document.all)) {
            isDDA = function isDocumentDotAll(value) {
              /* globals document: false */
              // in IE 6-8, typeof document.all is "object" and it's truthy
              if (
                (isIE68 || !value) &&
                (typeof value === "undefined" || typeof value === "object")
              ) {
                try {
                  var str = toStr.call(value);
                  return (
                    (str === ddaClass ||
                      str === ddaClass2 ||
                      str === ddaClass3 || // opera 12.16
                      str === objectClass) && // IE 6-8
                    value("") == null
                  ); // eslint-disable-line eqeqeq
                } catch (e) {
                  /**/
                }
              }
              return false;
            };
          }
        }

        module.exports = reflectApply
          ? function isCallable(value) {
              if (isDDA(value)) {
                return true;
              }
              if (!value) {
                return false;
              }
              if (typeof value !== "function" && typeof value !== "object") {
                return false;
              }
              try {
                reflectApply(value, null, badArrayLike);
              } catch (e) {
                if (e !== isCallableMarker) {
                  return false;
                }
              }
              return !isES6ClassFn(value) && tryFunctionObject(value);
            }
          : function isCallable(value) {
              if (isDDA(value)) {
                return true;
              }
              if (!value) {
                return false;
              }
              if (typeof value !== "function" && typeof value !== "object") {
                return false;
              }
              if (hasToStringTag) {
                return tryFunctionObject(value);
              }
              if (isES6ClassFn(value)) {
                return false;
              }
              var strClass = toStr.call(value);
              if (
                strClass !== fnClass &&
                strClass !== genClass &&
                !/^\[object HTML/.test(strClass)
              ) {
                return false;
              }
              return tryFunctionObject(value);
            };
      },
      {},
    ],
    116: [
      function (require, module, exports) {
        /*!
         * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
         *
         * Copyright (c) 2015-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var typeOf = require("kind-of");

        module.exports = function isDataDescriptor(obj, prop) {
          // data descriptor properties
          var data = {
            configurable: "boolean",
            enumerable: "boolean",
            writable: "boolean",
          };

          if (typeOf(obj) !== "object") {
            return false;
          }

          if (typeof prop === "string") {
            var val = Object.getOwnPropertyDescriptor(obj, prop);
            return typeof val !== "undefined";
          }

          if (!("value" in obj) && !("writable" in obj)) {
            return false;
          }

          for (var key in obj) {
            if (key === "value") continue;

            if (!data.hasOwnProperty(key)) {
              continue;
            }

            if (typeOf(obj[key]) === data[key]) {
              continue;
            }

            if (typeof obj[key] !== "undefined") {
              return false;
            }
          }
          return true;
        };
      },
      { "kind-of": 132 },
    ],
    117: [
      function (require, module, exports) {
        arguments[4][20][0].apply(exports, arguments);
      },
      {
        dup: 20,
        "is-accessor-descriptor": 112,
        "is-data-descriptor": 116,
        "kind-of": 132,
      },
    ],
    118: [
      function (require, module, exports) {
        /*!
         * is-even <https://github.com/jonschlinkert/is-even>
         *
         * Copyright (c) 2015, 2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var isOdd = require("is-odd");

        module.exports = function isEven(i) {
          return !isOdd(i);
        };
      },
      { "is-odd": 123 },
    ],
    119: [
      function (require, module, exports) {
        /*!
         * is-extendable <https://github.com/jonschlinkert/is-extendable>
         *
         * Copyright (c) 2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        module.exports = function isExtendable(val) {
          return (
            typeof val !== "undefined" &&
            val !== null &&
            (typeof val === "object" || typeof val === "function")
          );
        };
      },
      {},
    ],
    120: [
      function (require, module, exports) {
        /*!
         * is-extglob <https://github.com/jonschlinkert/is-extglob>
         *
         * Copyright (c) 2014-2016, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        module.exports = function isExtglob(str) {
          if (typeof str !== "string" || str === "") {
            return false;
          }

          var match;
          while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
            if (match[2]) return true;
            str = str.slice(match.index + match[0].length);
          }

          return false;
        };
      },
      {},
    ],
    121: [
      function (require, module, exports) {
        "use strict";

        var toStr = Object.prototype.toString;
        var fnToStr = Function.prototype.toString;
        var isFnRegex = /^\s*(?:function)?\*/;
        var hasToStringTag = require("has-tostringtag/shams")();
        var getProto = Object.getPrototypeOf;
        var getGeneratorFunc = function () {
          // eslint-disable-line consistent-return
          if (!hasToStringTag) {
            return false;
          }
          try {
            return Function("return function*() {}")();
          } catch (e) {}
        };
        var GeneratorFunction;

        module.exports = function isGeneratorFunction(fn) {
          if (typeof fn !== "function") {
            return false;
          }
          if (isFnRegex.test(fnToStr.call(fn))) {
            return true;
          }
          if (!hasToStringTag) {
            var str = toStr.call(fn);
            return str === "[object GeneratorFunction]";
          }
          if (!getProto) {
            return false;
          }
          if (typeof GeneratorFunction === "undefined") {
            var generatorFunc = getGeneratorFunc();
            GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
          }
          return getProto(fn) === GeneratorFunction;
        };
      },
      { "has-tostringtag/shams": 102 },
    ],
    122: [
      function (require, module, exports) {
        /*!
         * is-glob <https://github.com/jonschlinkert/is-glob>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        var isExtglob = require("is-extglob");
        var chars = { "{": "}", "(": ")", "[": "]" };
        var strictCheck = function (str) {
          if (str[0] === "!") {
            return true;
          }
          var index = 0;
          var pipeIndex = -2;
          var closeSquareIndex = -2;
          var closeCurlyIndex = -2;
          var closeParenIndex = -2;
          var backSlashIndex = -2;
          while (index < str.length) {
            if (str[index] === "*") {
              return true;
            }

            if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
              return true;
            }

            if (
              closeSquareIndex !== -1 &&
              str[index] === "[" &&
              str[index + 1] !== "]"
            ) {
              if (closeSquareIndex < index) {
                closeSquareIndex = str.indexOf("]", index);
              }
              if (closeSquareIndex > index) {
                if (
                  backSlashIndex === -1 ||
                  backSlashIndex > closeSquareIndex
                ) {
                  return true;
                }
                backSlashIndex = str.indexOf("\\", index);
                if (
                  backSlashIndex === -1 ||
                  backSlashIndex > closeSquareIndex
                ) {
                  return true;
                }
              }
            }

            if (
              closeCurlyIndex !== -1 &&
              str[index] === "{" &&
              str[index + 1] !== "}"
            ) {
              closeCurlyIndex = str.indexOf("}", index);
              if (closeCurlyIndex > index) {
                backSlashIndex = str.indexOf("\\", index);
                if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
                  return true;
                }
              }
            }

            if (
              closeParenIndex !== -1 &&
              str[index] === "(" &&
              str[index + 1] === "?" &&
              /[:!=]/.test(str[index + 2]) &&
              str[index + 3] !== ")"
            ) {
              closeParenIndex = str.indexOf(")", index);
              if (closeParenIndex > index) {
                backSlashIndex = str.indexOf("\\", index);
                if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                  return true;
                }
              }
            }

            if (
              pipeIndex !== -1 &&
              str[index] === "(" &&
              str[index + 1] !== "|"
            ) {
              if (pipeIndex < index) {
                pipeIndex = str.indexOf("|", index);
              }
              if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
                closeParenIndex = str.indexOf(")", pipeIndex);
                if (closeParenIndex > pipeIndex) {
                  backSlashIndex = str.indexOf("\\", pipeIndex);
                  if (
                    backSlashIndex === -1 ||
                    backSlashIndex > closeParenIndex
                  ) {
                    return true;
                  }
                }
              }
            }

            if (str[index] === "\\") {
              var open = str[index + 1];
              index += 2;
              var close = chars[open];

              if (close) {
                var n = str.indexOf(close, index);
                if (n !== -1) {
                  index = n + 1;
                }
              }

              if (str[index] === "!") {
                return true;
              }
            } else {
              index++;
            }
          }
          return false;
        };

        var relaxedCheck = function (str) {
          if (str[0] === "!") {
            return true;
          }
          var index = 0;
          while (index < str.length) {
            if (/[*?{}()[\]]/.test(str[index])) {
              return true;
            }

            if (str[index] === "\\") {
              var open = str[index + 1];
              index += 2;
              var close = chars[open];

              if (close) {
                var n = str.indexOf(close, index);
                if (n !== -1) {
                  index = n + 1;
                }
              }

              if (str[index] === "!") {
                return true;
              }
            } else {
              index++;
            }
          }
          return false;
        };

        module.exports = function isGlob(str, options) {
          if (typeof str !== "string" || str === "") {
            return false;
          }

          if (isExtglob(str)) {
            return true;
          }

          var check = strictCheck;

          // optionally relax check
          if (options && options.strict === false) {
            check = relaxedCheck;
          }

          return check(str);
        };
      },
      { "is-extglob": 120 },
    ],
    123: [
      function (require, module, exports) {
        /*!
         * is-odd <https://github.com/jonschlinkert/is-odd>
         *
         * Copyright (c) 2015-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var isNumber = require("is-number");

        module.exports = function isOdd(i) {
          if (!isNumber(i)) {
            throw new TypeError("is-odd expects a number.");
          }
          if (Number(i) !== Math.floor(i)) {
            throw new RangeError("is-odd expects an integer.");
          }
          return !!(~~i & 1);
        };
      },
      { "is-number": 124 },
    ],
    124: [
      function (require, module, exports) {
        arguments[4][105][0].apply(exports, arguments);
      },
      { dup: 105, "kind-of": 125 },
    ],
    125: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    126: [
      function (require, module, exports) {
        /*!
         * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var isObject = require("isobject");

        function isObjectObject(o) {
          return (
            isObject(o) === true &&
            Object.prototype.toString.call(o) === "[object Object]"
          );
        }

        module.exports = function isPlainObject(o) {
          var ctor, prot;

          if (isObjectObject(o) === false) return false;

          // If has modified constructor
          ctor = o.constructor;
          if (typeof ctor !== "function") return false;

          // If has modified prototype
          prot = ctor.prototype;
          if (isObjectObject(prot) === false) return false;

          // If constructor does not have an Object-specific method
          if (prot.hasOwnProperty("isPrototypeOf") === false) {
            return false;
          }

          // Most likely a plain Object
          return true;
        };
      },
      { isobject: 131 },
    ],
    127: [
      function (require, module, exports) {
        "use strict";

        var tags = require("self-closing-tags");

        module.exports = function (name) {
          if (typeof name !== "string") {
            throw new TypeError("expected name to be a string");
          }
          return tags.indexOf(name.toLowerCase()) !== -1;
        };
      },
      { "self-closing-tags": 198 },
    ],
    128: [
      function (require, module, exports) {
        (function (global) {
          (function () {
            "use strict";

            var forEach = require("for-each");
            var availableTypedArrays = require("available-typed-arrays");
            var callBound = require("call-bind/callBound");

            var $toString = callBound("Object.prototype.toString");
            var hasToStringTag = require("has-tostringtag/shams")();
            var gOPD = require("gopd");

            var g = typeof globalThis === "undefined" ? global : globalThis;
            var typedArrays = availableTypedArrays();

            var $indexOf =
              callBound("Array.prototype.indexOf", true) ||
              function indexOf(array, value) {
                for (var i = 0; i < array.length; i += 1) {
                  if (array[i] === value) {
                    return i;
                  }
                }
                return -1;
              };
            var $slice = callBound("String.prototype.slice");
            var toStrTags = {};
            var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
            if (hasToStringTag && gOPD && getPrototypeOf) {
              forEach(typedArrays, function (typedArray) {
                var arr = new g[typedArray]();
                if (Symbol.toStringTag in arr) {
                  var proto = getPrototypeOf(arr);
                  var descriptor = gOPD(proto, Symbol.toStringTag);
                  if (!descriptor) {
                    var superProto = getPrototypeOf(proto);
                    descriptor = gOPD(superProto, Symbol.toStringTag);
                  }
                  toStrTags[typedArray] = descriptor.get;
                }
              });
            }

            var tryTypedArrays = function tryAllTypedArrays(value) {
              var anyTrue = false;
              forEach(toStrTags, function (getter, typedArray) {
                if (!anyTrue) {
                  try {
                    anyTrue = getter.call(value) === typedArray;
                  } catch (e) {
                    /**/
                  }
                }
              });
              return anyTrue;
            };

            module.exports = function isTypedArray(value) {
              if (!value || typeof value !== "object") {
                return false;
              }
              if (!hasToStringTag || !(Symbol.toStringTag in value)) {
                var tag = $slice($toString(value), 8, -1);
                return $indexOf(typedArrays, tag) > -1;
              }
              if (!gOPD) {
                return false;
              }
              return tryTypedArrays(value);
            };
          }.call(this));
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      {
        "available-typed-arrays": 8,
        "call-bind/callBound": 12,
        "for-each": 69,
        gopd: 80,
        "has-tostringtag/shams": 102,
      },
    ],
    129: [
      function (require, module, exports) {
        (function (process, global) {
          (function () {
            /*!
             * is-windows <https://github.com/jonschlinkert/is-windows>
             *
             * Copyright  2015-2018, Jon Schlinkert.
             * Released under the MIT License.
             */

            (function (factory) {
              if (
                exports &&
                typeof exports === "object" &&
                typeof module !== "undefined"
              ) {
                module.exports = factory();
              } else if (typeof define === "function" && define.amd) {
                define([], factory);
              } else if (typeof window !== "undefined") {
                window.isWindows = factory();
              } else if (typeof global !== "undefined") {
                global.isWindows = factory();
              } else if (typeof self !== "undefined") {
                self.isWindows = factory();
              } else {
                this.isWindows = factory();
              }
            })(function () {
              "use strict";
              return function isWindows() {
                return (
                  process &&
                  (process.platform === "win32" ||
                    /^(msys|cygwin)$/.test(process.env.OSTYPE))
                );
              };
            });
          }.call(this));
        }.call(
          this,
          require("_process"),
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      { _process: 179 },
    ],
    130: [
      function (require, module, exports) {
        var toString = {}.toString;

        module.exports =
          Array.isArray ||
          function (arr) {
            return toString.call(arr) == "[object Array]";
          };
      },
      {},
    ],
    131: [
      function (require, module, exports) {
        /*!
         * isobject <https://github.com/jonschlinkert/isobject>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        module.exports = function isObject(val) {
          return (
            val != null &&
            typeof val === "object" &&
            Array.isArray(val) === false
          );
        };
      },
      {},
    ],
    132: [
      function (require, module, exports) {
        var toString = Object.prototype.toString;

        module.exports = function kindOf(val) {
          if (val === void 0) return "undefined";
          if (val === null) return "null";

          var type = typeof val;
          if (type === "boolean") return "boolean";
          if (type === "string") return "string";
          if (type === "number") return "number";
          if (type === "symbol") return "symbol";
          if (type === "function") {
            return isGeneratorFn(val) ? "generatorfunction" : "function";
          }

          if (isArray(val)) return "array";
          if (isBuffer(val)) return "buffer";
          if (isArguments(val)) return "arguments";
          if (isDate(val)) return "date";
          if (isError(val)) return "error";
          if (isRegexp(val)) return "regexp";

          switch (ctorName(val)) {
            case "Symbol":
              return "symbol";
            case "Promise":
              return "promise";

            // Set, Map, WeakSet, WeakMap
            case "WeakMap":
              return "weakmap";
            case "WeakSet":
              return "weakset";
            case "Map":
              return "map";
            case "Set":
              return "set";

            // 8-bit typed arrays
            case "Int8Array":
              return "int8array";
            case "Uint8Array":
              return "uint8array";
            case "Uint8ClampedArray":
              return "uint8clampedarray";

            // 16-bit typed arrays
            case "Int16Array":
              return "int16array";
            case "Uint16Array":
              return "uint16array";

            // 32-bit typed arrays
            case "Int32Array":
              return "int32array";
            case "Uint32Array":
              return "uint32array";
            case "Float32Array":
              return "float32array";
            case "Float64Array":
              return "float64array";
          }

          if (isGeneratorObj(val)) {
            return "generator";
          }

          // Non-plain objects
          type = toString.call(val);
          switch (type) {
            case "[object Object]":
              return "object";
            // iterators
            case "[object Map Iterator]":
              return "mapiterator";
            case "[object Set Iterator]":
              return "setiterator";
            case "[object String Iterator]":
              return "stringiterator";
            case "[object Array Iterator]":
              return "arrayiterator";
          }

          // other
          return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
        };

        function ctorName(val) {
          return typeof val.constructor === "function"
            ? val.constructor.name
            : null;
        }

        function isArray(val) {
          if (Array.isArray) return Array.isArray(val);
          return val instanceof Array;
        }

        function isError(val) {
          return (
            val instanceof Error ||
            (typeof val.message === "string" &&
              val.constructor &&
              typeof val.constructor.stackTraceLimit === "number")
          );
        }

        function isDate(val) {
          if (val instanceof Date) return true;
          return (
            typeof val.toDateString === "function" &&
            typeof val.getDate === "function" &&
            typeof val.setDate === "function"
          );
        }

        function isRegexp(val) {
          if (val instanceof RegExp) return true;
          return (
            typeof val.flags === "string" &&
            typeof val.ignoreCase === "boolean" &&
            typeof val.multiline === "boolean" &&
            typeof val.global === "boolean"
          );
        }

        function isGeneratorFn(name, val) {
          return ctorName(name) === "GeneratorFunction";
        }

        function isGeneratorObj(val) {
          return (
            typeof val.throw === "function" &&
            typeof val.return === "function" &&
            typeof val.next === "function"
          );
        }

        function isArguments(val) {
          try {
            if (
              typeof val.length === "number" &&
              typeof val.callee === "function"
            ) {
              return true;
            }
          } catch (err) {
            if (err.message.indexOf("callee") !== -1) {
              return true;
            }
          }
          return false;
        }

        /**
         * If you need to support Safari 5-7 (8-10 yr-old browser),
         * take a look at https://github.com/feross/is-buffer
         */

        function isBuffer(val) {
          if (
            val.constructor &&
            typeof val.constructor.isBuffer === "function"
          ) {
            return val.constructor.isBuffer(val);
          }
          return false;
        }
      },
      {},
    ],
    133: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            "use strict";

            var set = require("set-getter");

            /**
             * Cache results of the first function call to ensure only calling once.
             *
             * ```js
             * var utils = require('lazy-cache')(require);
             * // cache the call to `require('ansi-yellow')`
             * utils('ansi-yellow', 'yellow');
             * // use `ansi-yellow`
             * console.log(utils.yellow('this is yellow'));
             * ```
             *
             * @param  {Function} `fn` Function that will be called only once.
             * @return {Function} Function that can be called to get the cached function
             * @api public
             */

            function lazyCache(requireFn) {
              var cache = {};

              return function proxy(name, alias) {
                var key = alias;

                // camel-case the module `name` if `alias` is not defined
                if (typeof key !== "string") {
                  key = camelcase(name);
                }

                // create a getter to lazily invoke the module the first time it's called
                function getter() {
                  return cache[key] || (cache[key] = requireFn(name));
                }

                // trip the getter if `process.env.UNLAZY` is defined
                if (unlazy(process.env)) {
                  getter();
                }

                set(proxy, key, getter);
                return getter;
              };
            }

            /**
             * Return true if `process.env.LAZY` is true, or travis is running.
             */

            function unlazy(env) {
              return env.UNLAZY === "true" || env.UNLAZY === true || env.TRAVIS;
            }

            /**
             * Camelcase the the given module `name`.
             */

            function camelcase(str) {
              if (str.length === 1) {
                return str.toLowerCase();
              }
              str = str.replace(/^[\W_]+|[\W_]+$/g, "").toLowerCase();
              return str.replace(/[\W_]+(\w|$)/g, function (_, ch) {
                return ch.toUpperCase();
              });
            }

            /**
             * Expose `lazyCache`
             */

            module.exports = lazyCache;
          }.call(this));
        }.call(this, require("_process")));
      },
      { _process: 179, "set-getter": 199 },
    ],
    134: [
      function (require, module, exports) {
        /*!
         * map-cache <https://github.com/jonschlinkert/map-cache>
         *
         * Copyright (c) 2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        var hasOwn = Object.prototype.hasOwnProperty;

        /**
         * Expose `MapCache`
         */

        module.exports = MapCache;

        /**
         * Creates a cache object to store key/value pairs.
         *
         * ```js
         * var cache = new MapCache();
         * ```
         *
         * @api public
         */

        function MapCache(data) {
          this.__data__ = data || {};
        }

        /**
         * Adds `value` to `key` on the cache.
         *
         * ```js
         * cache.set('foo', 'bar');
         * ```
         *
         * @param {String} `key` The key of the value to cache.
         * @param {*} `value` The value to cache.
         * @returns {Object} Returns the `Cache` object for chaining.
         * @api public
         */

        MapCache.prototype.set = function mapSet(key, value) {
          if (key !== "__proto__") {
            this.__data__[key] = value;
          }
          return this;
        };

        /**
         * Gets the cached value for `key`.
         *
         * ```js
         * cache.get('foo');
         * //=> 'bar'
         * ```
         *
         * @param {String} `key` The key of the value to get.
         * @returns {*} Returns the cached value.
         * @api public
         */

        MapCache.prototype.get = function mapGet(key) {
          return key === "__proto__" ? undefined : this.__data__[key];
        };

        /**
         * Checks if a cached value for `key` exists.
         *
         * ```js
         * cache.has('foo');
         * //=> true
         * ```
         *
         * @param {String} `key` The key of the entry to check.
         * @returns {Boolean} Returns `true` if an entry for `key` exists, else `false`.
         * @api public
         */

        MapCache.prototype.has = function mapHas(key) {
          return key !== "__proto__" && hasOwn.call(this.__data__, key);
        };

        /**
         * Removes `key` and its value from the cache.
         *
         * ```js
         * cache.del('foo');
         * ```
         * @title .del
         * @param {String} `key` The key of the value to remove.
         * @returns {Boolean} Returns `true` if the entry was removed successfully, else `false`.
         * @api public
         */

        MapCache.prototype.del = function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        };
      },
      {},
    ],
    135: [
      function (require, module, exports) {
        "use strict";

        var util = require("util");
        var visit = require("object-visit");

        /**
         * Map `visit` over an array of objects.
         *
         * @param  {Object} `collection` The context in which to invoke `method`
         * @param  {String} `method` Name of the method to call on `collection`
         * @param  {Object} `arr` Array of objects.
         */

        module.exports = function mapVisit(collection, method, val) {
          if (isObject(val)) {
            return visit.apply(null, arguments);
          }

          if (!Array.isArray(val)) {
            throw new TypeError("expected an array: " + util.inspect(val));
          }

          var args = [].slice.call(arguments, 3);

          for (var i = 0; i < val.length; i++) {
            var ele = val[i];
            if (isObject(ele)) {
              visit.apply(null, [collection, method, ele].concat(args));
            } else {
              collection[method].apply(collection, [ele].concat(args));
            }
          }
        };

        function isObject(val) {
          return (
            val &&
            (typeof val === "function" ||
              (!Array.isArray(val) && typeof val === "object"))
          );
        }
      },
      { "object-visit": 174, util: 264 },
    ],
    136: [
      function (require, module, exports) {
        "use strict";

        /**
         * Module dependencies
         */

        var util = require("util");
        var braces = require("braces");
        var toRegex = require("to-regex");
        var extend = require("extend-shallow");

        /**
         * Local dependencies
         */

        var compilers = require("./lib/compilers");
        var parsers = require("./lib/parsers");
        var cache = require("./lib/cache");
        var utils = require("./lib/utils");
        var MAX_LENGTH = 1024 * 64;

        /**
         * The main function takes a list of strings and one or more
         * glob patterns to use for matching.
         *
         * ```js
         * var mm = require('micromatch');
         * mm(list, patterns[, options]);
         *
         * console.log(mm(['a.js', 'a.txt'], ['*.js']));
         * //=> [ 'a.js' ]
         * ```
         * @param {Array} `list` A list of strings to match
         * @param {String|Array} `patterns` One or more glob patterns to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Array} Returns an array of matches
         * @summary false
         * @api public
         */

        function micromatch(list, patterns, options) {
          patterns = utils.arrayify(patterns);
          list = utils.arrayify(list);

          var len = patterns.length;
          if (list.length === 0 || len === 0) {
            return [];
          }

          if (len === 1) {
            return micromatch.match(list, patterns[0], options);
          }

          var omit = [];
          var keep = [];
          var idx = -1;

          while (++idx < len) {
            var pattern = patterns[idx];

            if (
              typeof pattern === "string" &&
              pattern.charCodeAt(0) === 33 /* ! */
            ) {
              omit.push.apply(
                omit,
                micromatch.match(list, pattern.slice(1), options)
              );
            } else {
              keep.push.apply(keep, micromatch.match(list, pattern, options));
            }
          }

          var matches = utils.diff(keep, omit);
          if (!options || options.nodupes !== false) {
            return utils.unique(matches);
          }

          return matches;
        }

        /**
         * Similar to the main function, but `pattern` must be a string.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.match(list, pattern[, options]);
         *
         * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
         * //=> ['a.a', 'a.aa']
         * ```
         * @param {Array} `list` Array of strings to match
         * @param {String} `pattern` Glob pattern to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Array} Returns an array of matches
         * @api public
         */

        micromatch.match = function (list, pattern, options) {
          if (Array.isArray(pattern)) {
            throw new TypeError("expected pattern to be a string");
          }

          var unixify = utils.unixify(options);
          var isMatch = memoize("match", pattern, options, micromatch.matcher);
          var matches = [];

          list = utils.arrayify(list);
          var len = list.length;
          var idx = -1;

          while (++idx < len) {
            var ele = list[idx];
            if (ele === pattern || isMatch(ele)) {
              matches.push(utils.value(ele, unixify, options));
            }
          }

          // if no options were passed, uniquify results and return
          if (typeof options === "undefined") {
            return utils.unique(matches);
          }

          if (matches.length === 0) {
            if (options.failglob === true) {
              throw new Error('no matches found for "' + pattern + '"');
            }
            if (options.nonull === true || options.nullglob === true) {
              return [options.unescape ? utils.unescape(pattern) : pattern];
            }
          }

          // if `opts.ignore` was defined, diff ignored list
          if (options.ignore) {
            matches = micromatch.not(matches, options.ignore, options);
          }

          return options.nodupes !== false ? utils.unique(matches) : matches;
        };

        /**
         * Returns true if the specified `string` matches the given glob `pattern`.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.isMatch(string, pattern[, options]);
         *
         * console.log(mm.isMatch('a.a', '*.a'));
         * //=> true
         * console.log(mm.isMatch('a.b', '*.a'));
         * //=> false
         * ```
         * @param {String} `string` String to match
         * @param {String} `pattern` Glob pattern to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns true if the string matches the glob pattern.
         * @api public
         */

        micromatch.isMatch = function (str, pattern, options) {
          if (typeof str !== "string") {
            throw new TypeError(
              'expected a string: "' + util.inspect(str) + '"'
            );
          }

          if (isEmptyString(str) || isEmptyString(pattern)) {
            return false;
          }

          var equals = utils.equalsPattern(options);
          if (equals(str)) {
            return true;
          }

          var isMatch = memoize(
            "isMatch",
            pattern,
            options,
            micromatch.matcher
          );
          return isMatch(str);
        };

        /**
         * Returns true if some of the strings in the given `list` match any of the
         * given glob `patterns`.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.some(list, patterns[, options]);
         *
         * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
         * // true
         * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
         * // false
         * ```
         * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
         * @param {String|Array} `patterns` One or more glob patterns to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns true if any patterns match `str`
         * @api public
         */

        micromatch.some = function (list, patterns, options) {
          if (typeof list === "string") {
            list = [list];
          }
          for (var i = 0; i < list.length; i++) {
            if (micromatch(list[i], patterns, options).length === 1) {
              return true;
            }
          }
          return false;
        };

        /**
         * Returns true if every string in the given `list` matches
         * any of the given glob `patterns`.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.every(list, patterns[, options]);
         *
         * console.log(mm.every('foo.js', ['foo.js']));
         * // true
         * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
         * // true
         * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
         * // false
         * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
         * // false
         * ```
         * @param  {String|Array} `list` The string or array of strings to test.
         * @param {String|Array} `patterns` One or more glob patterns to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns true if any patterns match `str`
         * @api public
         */

        micromatch.every = function (list, patterns, options) {
          if (typeof list === "string") {
            list = [list];
          }
          for (var i = 0; i < list.length; i++) {
            if (micromatch(list[i], patterns, options).length !== 1) {
              return false;
            }
          }
          return true;
        };

        /**
         * Returns true if **any** of the given glob `patterns`
         * match the specified `string`.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.any(string, patterns[, options]);
         *
         * console.log(mm.any('a.a', ['b.*', '*.a']));
         * //=> true
         * console.log(mm.any('a.a', 'b.*'));
         * //=> false
         * ```
         * @param  {String|Array} `str` The string to test.
         * @param {String|Array} `patterns` One or more glob patterns to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns true if any patterns match `str`
         * @api public
         */

        micromatch.any = function (str, patterns, options) {
          if (typeof str !== "string") {
            throw new TypeError(
              'expected a string: "' + util.inspect(str) + '"'
            );
          }

          if (isEmptyString(str) || isEmptyString(patterns)) {
            return false;
          }

          if (typeof patterns === "string") {
            patterns = [patterns];
          }

          for (var i = 0; i < patterns.length; i++) {
            if (micromatch.isMatch(str, patterns[i], options)) {
              return true;
            }
          }
          return false;
        };

        /**
         * Returns true if **all** of the given `patterns` match
         * the specified string.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.all(string, patterns[, options]);
         *
         * console.log(mm.all('foo.js', ['foo.js']));
         * // true
         *
         * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
         * // false
         *
         * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
         * // true
         *
         * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
         * // true
         * ```
         * @param  {String|Array} `str` The string to test.
         * @param {String|Array} `patterns` One or more glob patterns to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns true if any patterns match `str`
         * @api public
         */

        micromatch.all = function (str, patterns, options) {
          if (typeof str !== "string") {
            throw new TypeError(
              'expected a string: "' + util.inspect(str) + '"'
            );
          }
          if (typeof patterns === "string") {
            patterns = [patterns];
          }
          for (var i = 0; i < patterns.length; i++) {
            if (!micromatch.isMatch(str, patterns[i], options)) {
              return false;
            }
          }
          return true;
        };

        /**
         * Returns a list of strings that _**do not match any**_ of the given `patterns`.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.not(list, patterns[, options]);
         *
         * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
         * //=> ['b.b', 'c.c']
         * ```
         * @param {Array} `list` Array of strings to match.
         * @param {String|Array} `patterns` One or more glob pattern to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Array} Returns an array of strings that **do not match** the given patterns.
         * @api public
         */

        micromatch.not = function (list, patterns, options) {
          var opts = extend({}, options);
          var ignore = opts.ignore;
          delete opts.ignore;

          var unixify = utils.unixify(opts);
          list = utils.arrayify(list).map(unixify);

          var matches = utils.diff(list, micromatch(list, patterns, opts));
          if (ignore) {
            matches = utils.diff(matches, micromatch(list, ignore));
          }

          return opts.nodupes !== false ? utils.unique(matches) : matches;
        };

        /**
         * Returns true if the given `string` contains the given pattern. Similar
         * to [.isMatch](#isMatch) but the pattern can match any part of the string.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.contains(string, pattern[, options]);
         *
         * console.log(mm.contains('aa/bb/cc', '*b'));
         * //=> true
         * console.log(mm.contains('aa/bb/cc', '*d'));
         * //=> false
         * ```
         * @param {String} `str` The string to match.
         * @param {String|Array} `patterns` Glob pattern to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns true if the patter matches any part of `str`.
         * @api public
         */

        micromatch.contains = function (str, patterns, options) {
          if (typeof str !== "string") {
            throw new TypeError(
              'expected a string: "' + util.inspect(str) + '"'
            );
          }

          if (typeof patterns === "string") {
            if (isEmptyString(str) || isEmptyString(patterns)) {
              return false;
            }

            var equals = utils.equalsPattern(patterns, options);
            if (equals(str)) {
              return true;
            }
            var contains = utils.containsPattern(patterns, options);
            if (contains(str)) {
              return true;
            }
          }

          var opts = extend({}, options, { contains: true });
          return micromatch.any(str, patterns, opts);
        };

        /**
         * Returns true if the given pattern and options should enable
         * the `matchBase` option.
         * @return {Boolean}
         * @api private
         */

        micromatch.matchBase = function (pattern, options) {
          if ((pattern && pattern.indexOf("/") !== -1) || !options)
            return false;
          return options.basename === true || options.matchBase === true;
        };

        /**
         * Filter the keys of the given object with the given `glob` pattern
         * and `options`. Does not attempt to match nested keys. If you need this feature,
         * use [glob-object][] instead.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.matchKeys(object, patterns[, options]);
         *
         * var obj = { aa: 'a', ab: 'b', ac: 'c' };
         * console.log(mm.matchKeys(obj, '*b'));
         * //=> { ab: 'b' }
         * ```
         * @param {Object} `object` The object with keys to filter.
         * @param {String|Array} `patterns` One or more glob patterns to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Object} Returns an object with only keys that match the given patterns.
         * @api public
         */

        micromatch.matchKeys = function (obj, patterns, options) {
          if (!utils.isObject(obj)) {
            throw new TypeError("expected the first argument to be an object");
          }
          var keys = micromatch(Object.keys(obj), patterns, options);
          return utils.pick(obj, keys);
        };

        /**
         * Returns a memoized matcher function from the given glob `pattern` and `options`.
         * The returned function takes a string to match as its only argument and returns
         * true if the string is a match.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.matcher(pattern[, options]);
         *
         * var isMatch = mm.matcher('*.!(*a)');
         * console.log(isMatch('a.a'));
         * //=> false
         * console.log(isMatch('a.b'));
         * //=> true
         * ```
         * @param {String} `pattern` Glob pattern
         * @param {Object} `options` See available [options](#options) for changing how matches are performed.
         * @return {Function} Returns a matcher function.
         * @api public
         */

        micromatch.matcher = function matcher(pattern, options) {
          if (Array.isArray(pattern)) {
            return compose(pattern, options, matcher);
          }

          // if pattern is a regex
          if (pattern instanceof RegExp) {
            return test(pattern);
          }

          // if pattern is invalid
          if (!utils.isString(pattern)) {
            throw new TypeError(
              "expected pattern to be an array, string or regex"
            );
          }

          // if pattern is a non-glob string
          if (!utils.hasSpecialChars(pattern)) {
            if (options && options.nocase === true) {
              pattern = pattern.toLowerCase();
            }
            return utils.matchPath(pattern, options);
          }

          // if pattern is a glob string
          var re = micromatch.makeRe(pattern, options);

          // if `options.matchBase` or `options.basename` is defined
          if (micromatch.matchBase(pattern, options)) {
            return utils.matchBasename(re, options);
          }

          function test(regex) {
            var equals = utils.equalsPattern(options);
            var unixify = utils.unixify(options);

            return function (str) {
              if (equals(str)) {
                return true;
              }

              if (regex.test(unixify(str))) {
                return true;
              }
              return false;
            };
          }

          var fn = test(re);
          Object.defineProperty(fn, "result", {
            configurable: true,
            enumerable: false,
            value: re.result,
          });
          return fn;
        };

        /**
         * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.capture(pattern, string[, options]);
         *
         * console.log(mm.capture('test/*.js', 'test/foo.js'));
         * //=> ['foo']
         * console.log(mm.capture('test/*.js', 'foo/bar.css'));
         * //=> null
         * ```
         * @param {String} `pattern` Glob pattern to use for matching.
         * @param {String} `string` String to match
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
         * @api public
         */

        micromatch.capture = function (pattern, str, options) {
          var re = micromatch.makeRe(
            pattern,
            extend({ capture: true }, options)
          );
          var unixify = utils.unixify(options);

          function match() {
            return function (string) {
              var match = re.exec(unixify(string));
              if (!match) {
                return null;
              }

              return match.slice(1);
            };
          }

          var capture = memoize("capture", pattern, options, match);
          return capture(str);
        };

        /**
         * Create a regular expression from the given glob `pattern`.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.makeRe(pattern[, options]);
         *
         * console.log(mm.makeRe('*.js'));
         * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
         * ```
         * @param {String} `pattern` A glob pattern to convert to regex.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed.
         * @return {RegExp} Returns a regex created from the given pattern.
         * @api public
         */

        micromatch.makeRe = function (pattern, options) {
          if (typeof pattern !== "string") {
            throw new TypeError("expected pattern to be a string");
          }

          if (pattern.length > MAX_LENGTH) {
            throw new Error(
              "expected pattern to be less than " + MAX_LENGTH + " characters"
            );
          }

          function makeRe() {
            var result = micromatch.create(pattern, options);
            var ast_array = [];
            var output = result.map(function (obj) {
              obj.ast.state = obj.state;
              ast_array.push(obj.ast);
              return obj.output;
            });

            var regex = toRegex(output.join("|"), options);
            Object.defineProperty(regex, "result", {
              configurable: true,
              enumerable: false,
              value: ast_array,
            });
            return regex;
          }

          return memoize("makeRe", pattern, options, makeRe);
        };

        /**
         * Expand the given brace `pattern`.
         *
         * ```js
         * var mm = require('micromatch');
         * console.log(mm.braces('foo/{a,b}/bar'));
         * //=> ['foo/(a|b)/bar']
         *
         * console.log(mm.braces('foo/{a,b}/bar', {expand: true}));
         * //=> ['foo/(a|b)/bar']
         * ```
         * @param {String} `pattern` String with brace pattern to expand.
         * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
         * @return {Array}
         * @api public
         */

        micromatch.braces = function (pattern, options) {
          if (typeof pattern !== "string" && !Array.isArray(pattern)) {
            throw new TypeError("expected pattern to be an array or string");
          }

          function expand() {
            if (
              (options && options.nobrace === true) ||
              !/\{.*\}/.test(pattern)
            ) {
              return utils.arrayify(pattern);
            }
            return braces(pattern, options);
          }

          return memoize("braces", pattern, options, expand);
        };

        /**
         * Proxy to the [micromatch.braces](#method), for parity with
         * minimatch.
         */

        micromatch.braceExpand = function (pattern, options) {
          var opts = extend({}, options, { expand: true });
          return micromatch.braces(pattern, opts);
        };

        /**
         * Parses the given glob `pattern` and returns an array of abstract syntax
         * trees (ASTs), with the compiled `output` and optional source `map` on
         * each AST.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.create(pattern[, options]);
         *
         * console.log(mm.create('abc/*.js'));
         * // [{ options: { source: 'string', sourcemap: true },
         * //   state: {},
         * //   compilers:
         * //    { ... },
         * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
         * //   ast:
         * //    { type: 'root',
         * //      errors: [],
         * //      nodes:
         * //       [ ... ],
         * //      dot: false,
         * //      input: 'abc/*.js' },
         * //   parsingErrors: [],
         * //   map:
         * //    { version: 3,
         * //      sources: [ 'string' ],
         * //      names: [],
         * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
         * //      sourcesContent: [ 'abc/*.js' ] },
         * //   position: { line: 1, column: 28 },
         * //   content: {},
         * //   files: {},
         * //   idx: 6 }]
         * ```
         * @param {String} `pattern` Glob pattern to parse and compile.
         * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.
         * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.
         * @api public
         */

        micromatch.create = function (pattern, options) {
          return memoize("create", pattern, options, function () {
            function create(str, opts) {
              return micromatch.compile(micromatch.parse(str, opts), opts);
            }

            pattern = micromatch.braces(pattern, options);
            var len = pattern.length;
            var idx = -1;
            var res = [];

            while (++idx < len) {
              res.push(create(pattern[idx], options));
            }
            return res;
          });
        };

        /**
         * Parse the given `str` with the given `options`.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.parse(pattern[, options]);
         *
         * var ast = mm.parse('a/{b,c}/d');
         * console.log(ast);
         * // { type: 'root',
         * //   errors: [],
         * //   input: 'a/{b,c}/d',
         * //   nodes:
         * //    [ { type: 'bos', val: '' },
         * //      { type: 'text', val: 'a/' },
         * //      { type: 'brace',
         * //        nodes:
         * //         [ { type: 'brace.open', val: '{' },
         * //           { type: 'text', val: 'b,c' },
         * //           { type: 'brace.close', val: '}' } ] },
         * //      { type: 'text', val: '/d' },
         * //      { type: 'eos', val: '' } ] }
         * ```
         * @param {String} `str`
         * @param {Object} `options`
         * @return {Object} Returns an AST
         * @api public
         */

        micromatch.parse = function (pattern, options) {
          if (typeof pattern !== "string") {
            throw new TypeError("expected a string");
          }

          function parse() {
            var snapdragon = utils.instantiate(null, options);
            parsers(snapdragon, options);

            var ast = snapdragon.parse(pattern, options);
            utils.define(ast, "snapdragon", snapdragon);
            ast.input = pattern;
            return ast;
          }

          return memoize("parse", pattern, options, parse);
        };

        /**
         * Compile the given `ast` or string with the given `options`.
         *
         * ```js
         * var mm = require('micromatch');
         * mm.compile(ast[, options]);
         *
         * var ast = mm.parse('a/{b,c}/d');
         * console.log(mm.compile(ast));
         * // { options: { source: 'string' },
         * //   state: {},
         * //   compilers:
         * //    { eos: [Function],
         * //      noop: [Function],
         * //      bos: [Function],
         * //      brace: [Function],
         * //      'brace.open': [Function],
         * //      text: [Function],
         * //      'brace.close': [Function] },
         * //   output: [ 'a/(b|c)/d' ],
         * //   ast:
         * //    { ... },
         * //   parsingErrors: [] }
         * ```
         * @param {Object|String} `ast`
         * @param {Object} `options`
         * @return {Object} Returns an object that has an `output` property with the compiled string.
         * @api public
         */

        micromatch.compile = function (ast, options) {
          if (typeof ast === "string") {
            ast = micromatch.parse(ast, options);
          }

          return memoize("compile", ast.input, options, function () {
            var snapdragon = utils.instantiate(ast, options);
            compilers(snapdragon, options);
            return snapdragon.compile(ast, options);
          });
        };

        /**
         * Clear the regex cache.
         *
         * ```js
         * mm.clearCache();
         * ```
         * @api public
         */

        micromatch.clearCache = function () {
          micromatch.cache.caches = {};
        };

        /**
         * Returns true if the given value is effectively an empty string
         */

        function isEmptyString(val) {
          return String(val) === "" || String(val) === "./";
        }

        /**
         * Compose a matcher function with the given patterns.
         * This allows matcher functions to be compiled once and
         * called multiple times.
         */

        function compose(patterns, options, matcher) {
          var matchers;

          return memoize("compose", String(patterns), options, function () {
            return function (file) {
              // delay composition until it's invoked the first time,
              // after that it won't be called again
              if (!matchers) {
                matchers = [];
                for (var i = 0; i < patterns.length; i++) {
                  matchers.push(matcher(patterns[i], options));
                }
              }

              var len = matchers.length;
              while (len--) {
                if (matchers[len](file) === true) {
                  return true;
                }
              }
              return false;
            };
          });
        }

        /**
         * Memoize a generated regex or function. A unique key is generated
         * from the `type` (usually method name), the `pattern`, and
         * user-defined options.
         */

        function memoize(type, pattern, options, fn) {
          var key = utils.createKey(type + "=" + pattern, options);

          if (options && options.cache === false) {
            return fn(pattern, options);
          }

          if (cache.has(type, key)) {
            return cache.get(type, key);
          }

          var val = fn(pattern, options);
          cache.set(type, key, val);
          return val;
        }

        /**
         * Expose compiler, parser and cache on `micromatch`
         */

        micromatch.compilers = compilers;
        micromatch.parsers = parsers;
        micromatch.caches = cache.caches;

        /**
         * Expose `micromatch`
         * @type {Function}
         */

        module.exports = micromatch;
      },
      {
        "./lib/cache": 137,
        "./lib/compilers": 138,
        "./lib/parsers": 139,
        "./lib/utils": 140,
        braces: 141,
        "extend-shallow": 148,
        "to-regex": 248,
        util: 264,
      },
    ],
    137: [
      function (require, module, exports) {
        module.exports = new (require("fragment-cache"))();
      },
      { "fragment-cache": 72 },
    ],
    138: [
      function (require, module, exports) {
        "use strict";

        var nanomatch = require("nanomatch");
        var extglob = require("extglob");

        module.exports = function (snapdragon) {
          var compilers = snapdragon.compiler.compilers;
          var opts = snapdragon.options;

          // register nanomatch compilers
          snapdragon.use(nanomatch.compilers);

          // get references to some specific nanomatch compilers before they
          // are overridden by the extglob and/or custom compilers
          var escape = compilers.escape;
          var qmark = compilers.qmark;
          var slash = compilers.slash;
          var star = compilers.star;
          var text = compilers.text;
          var plus = compilers.plus;
          var dot = compilers.dot;

          // register extglob compilers or escape exglobs if disabled
          if (opts.extglob === false || opts.noext === true) {
            snapdragon.compiler.use(escapeExtglobs);
          } else {
            snapdragon.use(extglob.compilers);
          }

          snapdragon.use(function () {
            this.options.star =
              this.options.star ||
              function (/*node*/) {
                return "[^\\\\/]*?";
              };
          });

          // custom micromatch compilers
          snapdragon.compiler

            // reset referenced compiler
            .set("dot", dot)
            .set("escape", escape)
            .set("plus", plus)
            .set("slash", slash)
            .set("qmark", qmark)
            .set("star", star)
            .set("text", text);
        };

        function escapeExtglobs(compiler) {
          compiler.set("paren", function (node) {
            var val = "";
            visit(node, function (tok) {
              if (tok.val) val += (/^\W/.test(tok.val) ? "\\" : "") + tok.val;
            });
            return this.emit(val, node);
          });

          /**
           * Visit `node` with the given `fn`
           */

          function visit(node, fn) {
            return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
          }

          /**
           * Map visit over array of `nodes`.
           */

          function mapVisit(nodes, fn) {
            var len = nodes.length;
            var idx = -1;
            while (++idx < len) {
              visit(nodes[idx], fn);
            }
          }
        }
      },
      { extglob: 62, nanomatch: 159 },
    ],
    139: [
      function (require, module, exports) {
        "use strict";

        var extglob = require("extglob");
        var nanomatch = require("nanomatch");
        var regexNot = require("regex-not");
        var toRegex = require("to-regex");
        var not;

        /**
         * Characters to use in negation regex (we want to "not" match
         * characters that are matched by other parsers)
         */

        var TEXT = "([!@*?+]?\\(|\\)|\\[:?(?=.*?:?\\])|:?\\]|[*+?!^$.\\\\/])+";
        var createNotRegex = function (opts) {
          return not || (not = textRegex(TEXT));
        };

        /**
         * Parsers
         */

        module.exports = function (snapdragon) {
          var parsers = snapdragon.parser.parsers;

          // register nanomatch parsers
          snapdragon.use(nanomatch.parsers);

          // get references to some specific nanomatch parsers before they
          // are overridden by the extglob and/or parsers
          var escape = parsers.escape;
          var slash = parsers.slash;
          var qmark = parsers.qmark;
          var plus = parsers.plus;
          var star = parsers.star;
          var dot = parsers.dot;

          // register extglob parsers
          snapdragon.use(extglob.parsers);

          // custom micromatch parsers
          snapdragon.parser
            .use(function () {
              // override "notRegex" created in nanomatch parser
              this.notRegex = /^\!+(?!\()/;
            })
            // reset the referenced parsers
            .capture("escape", escape)
            .capture("slash", slash)
            .capture("qmark", qmark)
            .capture("star", star)
            .capture("plus", plus)
            .capture("dot", dot)

            /**
             * Override `text` parser
             */

            .capture("text", function () {
              if (this.isInside("bracket")) return;
              var pos = this.position();
              var m = this.match(createNotRegex(this.options));
              if (!m || !m[0]) return;

              // escape regex boundary characters and simple brackets
              var val = m[0].replace(/([[\]^$])/g, "\\$1");

              return pos({
                type: "text",
                val: val,
              });
            });
        };

        /**
         * Create text regex
         */

        function textRegex(pattern) {
          var notStr = regexNot.create(pattern, {
            contains: true,
            strictClose: false,
          });
          var prefix = "(?:[\\^]|\\\\|";
          return toRegex(prefix + notStr + ")", { strictClose: false });
        }
      },
      { extglob: 62, nanomatch: 159, "regex-not": 184, "to-regex": 248 },
    ],
    140: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            "use strict";

            var utils = module.exports;
            var path = require("path");

            /**
             * Module dependencies
             */

            var Snapdragon = require("snapdragon");
            utils.define = require("define-property");
            utils.diff = require("arr-diff");
            utils.extend = require("extend-shallow");
            utils.pick = require("object.pick");
            utils.typeOf = require("kind-of");
            utils.unique = require("array-unique");

            /**
             * Returns true if the platform is windows, or `path.sep` is `\\`.
             * This is defined as a function to allow `path.sep` to be set in unit tests,
             * or by the user, if there is a reason to do so.
             * @return {Boolean}
             */

            utils.isWindows = function () {
              return path.sep === "\\" || process.platform === "win32";
            };

            /**
             * Get the `Snapdragon` instance to use
             */

            utils.instantiate = function (ast, options) {
              var snapdragon;
              // if an instance was created by `.parse`, use that instance
              if (utils.typeOf(ast) === "object" && ast.snapdragon) {
                snapdragon = ast.snapdragon;
                // if the user supplies an instance on options, use that instance
              } else if (
                utils.typeOf(options) === "object" &&
                options.snapdragon
              ) {
                snapdragon = options.snapdragon;
                // create a new instance
              } else {
                snapdragon = new Snapdragon(options);
              }

              utils.define(snapdragon, "parse", function (str, options) {
                var parsed = Snapdragon.prototype.parse.apply(this, arguments);
                parsed.input = str;

                // escape unmatched brace/bracket/parens
                var last = this.parser.stack.pop();
                if (last && this.options.strictErrors !== true) {
                  var open = last.nodes[0];
                  var inner = last.nodes[1];
                  if (last.type === "bracket") {
                    if (inner.val.charAt(0) === "[") {
                      inner.val = "\\" + inner.val;
                    }
                  } else {
                    open.val = "\\" + open.val;
                    var sibling = open.parent.nodes[1];
                    if (sibling.type === "star") {
                      sibling.loose = true;
                    }
                  }
                }

                // add non-enumerable parser reference
                utils.define(parsed, "parser", this.parser);
                return parsed;
              });

              return snapdragon;
            };

            /**
             * Create the key to use for memoization. The key is generated
             * by iterating over the options and concatenating key-value pairs
             * to the pattern string.
             */

            utils.createKey = function (pattern, options) {
              if (utils.typeOf(options) !== "object") {
                return pattern;
              }
              var val = pattern;
              var keys = Object.keys(options);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                val += ";" + key + "=" + String(options[key]);
              }
              return val;
            };

            /**
             * Cast `val` to an array
             * @return {Array}
             */

            utils.arrayify = function (val) {
              if (typeof val === "string") return [val];
              return val ? (Array.isArray(val) ? val : [val]) : [];
            };

            /**
             * Return true if `val` is a non-empty string
             */

            utils.isString = function (val) {
              return typeof val === "string";
            };

            /**
             * Return true if `val` is a non-empty string
             */

            utils.isObject = function (val) {
              return utils.typeOf(val) === "object";
            };

            /**
             * Returns true if the given `str` has special characters
             */

            utils.hasSpecialChars = function (str) {
              return /(?:(?:(^|\/)[!.])|[*?+()|\[\]{}]|[+@]\()/.test(str);
            };

            /**
             * Escape regex characters in the given string
             */

            utils.escapeRegex = function (str) {
              return str.replace(/[-[\]{}()^$|*+?.\\\/\s]/g, "\\$&");
            };

            /**
             * Normalize slashes in the given filepath.
             *
             * @param {String} `filepath`
             * @return {String}
             */

            utils.toPosixPath = function (str) {
              return str.replace(/\\+/g, "/");
            };

            /**
             * Strip backslashes before special characters in a string.
             *
             * @param {String} `str`
             * @return {String}
             */

            utils.unescape = function (str) {
              return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ""));
            };

            /**
             * Strip the prefix from a filepath
             * @param {String} `fp`
             * @return {String}
             */

            utils.stripPrefix = function (str) {
              if (str.charAt(0) !== ".") {
                return str;
              }
              var ch = str.charAt(1);
              if (utils.isSlash(ch)) {
                return str.slice(2);
              }
              return str;
            };

            /**
             * Returns true if the given str is an escaped or
             * unescaped path character
             */

            utils.isSlash = function (str) {
              return (
                str === "/" || str === "\\/" || str === "\\" || str === "\\\\"
              );
            };

            /**
             * Returns a function that returns true if the given
             * pattern matches or contains a `filepath`
             *
             * @param {String} `pattern`
             * @return {Function}
             */

            utils.matchPath = function (pattern, options) {
              return options && options.contains
                ? utils.containsPattern(pattern, options)
                : utils.equalsPattern(pattern, options);
            };

            /**
             * Returns true if the given (original) filepath or unixified path are equal
             * to the given pattern.
             */

            utils._equals = function (filepath, unixPath, pattern) {
              return pattern === filepath || pattern === unixPath;
            };

            /**
             * Returns true if the given (original) filepath or unixified path contain
             * the given pattern.
             */

            utils._contains = function (filepath, unixPath, pattern) {
              return (
                filepath.indexOf(pattern) !== -1 ||
                unixPath.indexOf(pattern) !== -1
              );
            };

            /**
             * Returns a function that returns true if the given
             * pattern is the same as a given `filepath`
             *
             * @param {String} `pattern`
             * @return {Function}
             */

            utils.equalsPattern = function (pattern, options) {
              var unixify = utils.unixify(options);
              options = options || {};

              return function fn(filepath) {
                var equal = utils._equals(filepath, unixify(filepath), pattern);
                if (equal === true || options.nocase !== true) {
                  return equal;
                }
                var lower = filepath.toLowerCase();
                return utils._equals(lower, unixify(lower), pattern);
              };
            };

            /**
             * Returns a function that returns true if the given
             * pattern contains a `filepath`
             *
             * @param {String} `pattern`
             * @return {Function}
             */

            utils.containsPattern = function (pattern, options) {
              var unixify = utils.unixify(options);
              options = options || {};

              return function (filepath) {
                var contains = utils._contains(
                  filepath,
                  unixify(filepath),
                  pattern
                );
                if (contains === true || options.nocase !== true) {
                  return contains;
                }
                var lower = filepath.toLowerCase();
                return utils._contains(lower, unixify(lower), pattern);
              };
            };

            /**
             * Returns a function that returns true if the given
             * regex matches the `filename` of a file path.
             *
             * @param {RegExp} `re` Matching regex
             * @return {Function}
             */

            utils.matchBasename = function (re) {
              return function (filepath) {
                return re.test(path.basename(filepath));
              };
            };

            /**
             * Determines the filepath to return based on the provided options.
             * @return {any}
             */

            utils.value = function (str, unixify, options) {
              if (options && options.unixify === false) {
                return str;
              }
              return unixify(str);
            };

            /**
             * Returns a function that normalizes slashes in a string to forward
             * slashes, strips `./` from beginning of paths, and optionally unescapes
             * special characters.
             * @return {Function}
             */

            utils.unixify = function (options) {
              options = options || {};
              return function (filepath) {
                if (utils.isWindows() || options.unixify === true) {
                  filepath = utils.toPosixPath(filepath);
                }
                if (options.stripPrefix !== false) {
                  filepath = utils.stripPrefix(filepath);
                }
                if (options.unescape === true) {
                  filepath = utils.unescape(filepath);
                }
                return filepath;
              };
            };
          }.call(this));
        }.call(this, require("_process")));
      },
      {
        _process: 179,
        "arr-diff": 1,
        "array-unique": 6,
        "define-property": 147,
        "extend-shallow": 148,
        "kind-of": 132,
        "object.pick": 175,
        path: 177,
        snapdragon: 204,
      },
    ],
    141: [
      function (require, module, exports) {
        "use strict";

        /**
         * Module dependencies
         */

        var toRegex = require("to-regex");
        var unique = require("array-unique");
        var extend = require("extend-shallow");

        /**
         * Local dependencies
         */

        var compilers = require("./lib/compilers");
        var parsers = require("./lib/parsers");
        var Braces = require("./lib/braces");
        var utils = require("./lib/utils");
        var MAX_LENGTH = 1024 * 64;
        var cache = {};

        /**
         * Convert the given `braces` pattern into a regex-compatible string. By default, only one string is generated for every input string. Set `options.expand` to true to return an array of patterns (similar to Bash or minimatch. Before using `options.expand`, it's recommended that you read the [performance notes](#performance)).
         *
         * ```js
         * var braces = require('braces');
         * console.log(braces('{a,b,c}'));
         * //=> ['(a|b|c)']
         *
         * console.log(braces('{a,b,c}', {expand: true}));
         * //=> ['a', 'b', 'c']
         * ```
         * @param {String} `str`
         * @param {Object} `options`
         * @return {String}
         * @api public
         */

        function braces(pattern, options) {
          var key = utils.createKey(String(pattern), options);
          var arr = [];

          var disabled = options && options.cache === false;
          if (!disabled && cache.hasOwnProperty(key)) {
            return cache[key];
          }

          if (Array.isArray(pattern)) {
            for (var i = 0; i < pattern.length; i++) {
              arr.push.apply(arr, braces.create(pattern[i], options));
            }
          } else {
            arr = braces.create(pattern, options);
          }

          if (options && options.nodupes === true) {
            arr = unique(arr);
          }

          if (!disabled) {
            cache[key] = arr;
          }
          return arr;
        }

        /**
         * Expands a brace pattern into an array. This method is called by the main [braces](#braces) function when `options.expand` is true. Before using this method it's recommended that you read the [performance notes](#performance)) and advantages of using [.optimize](#optimize) instead.
         *
         * ```js
         * var braces = require('braces');
         * console.log(braces.expand('a/{b,c}/d'));
         * //=> ['a/b/d', 'a/c/d'];
         * ```
         * @param {String} `pattern` Brace pattern
         * @param {Object} `options`
         * @return {Array} Returns an array of expanded values.
         * @api public
         */

        braces.expand = function (pattern, options) {
          return braces.create(pattern, extend({}, options, { expand: true }));
        };

        /**
         * Expands a brace pattern into a regex-compatible, optimized string. This method is called by the main [braces](#braces) function by default.
         *
         * ```js
         * var braces = require('braces');
         * console.log(braces.expand('a/{b,c}/d'));
         * //=> ['a/(b|c)/d']
         * ```
         * @param {String} `pattern` Brace pattern
         * @param {Object} `options`
         * @return {Array} Returns an array of expanded values.
         * @api public
         */

        braces.optimize = function (pattern, options) {
          return braces.create(pattern, options);
        };

        /**
         * Processes a brace pattern and returns either an expanded array (if `options.expand` is true), a highly optimized regex-compatible string. This method is called by the main [braces](#braces) function.
         *
         * ```js
         * var braces = require('braces');
         * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
         * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
         * ```
         * @param {String} `pattern` Brace pattern
         * @param {Object} `options`
         * @return {Array} Returns an array of expanded values.
         * @api public
         */

        braces.create = function (pattern, options) {
          if (typeof pattern !== "string") {
            throw new TypeError("expected a string");
          }

          var maxLength = (options && options.maxLength) || MAX_LENGTH;
          if (pattern.length >= maxLength) {
            throw new Error(
              "expected pattern to be less than " + maxLength + " characters"
            );
          }

          function create() {
            if (pattern === "" || pattern.length < 3) {
              return [pattern];
            }

            if (utils.isEmptySets(pattern)) {
              return [];
            }

            if (utils.isQuotedString(pattern)) {
              return [pattern.slice(1, -1)];
            }

            var proto = new Braces(options);
            var result =
              !options || options.expand !== true
                ? proto.optimize(pattern, options)
                : proto.expand(pattern, options);

            // get the generated pattern(s)
            var arr = result.output;

            // filter out empty strings if specified
            if (options && options.noempty === true) {
              arr = arr.filter(Boolean);
            }

            // filter out duplicates if specified
            if (options && options.nodupes === true) {
              arr = unique(arr);
            }

            Object.defineProperty(arr, "result", {
              enumerable: false,
              value: result,
            });

            return arr;
          }

          return memoize("create", pattern, options, create);
        };

        /**
         * Create a regular expression from the given string `pattern`.
         *
         * ```js
         * var braces = require('braces');
         *
         * console.log(braces.makeRe('id-{200..300}'));
         * //=> /^(?:id-(20[0-9]|2[1-9][0-9]|300))$/
         * ```
         * @param {String} `pattern` The pattern to convert to regex.
         * @param {Object} `options`
         * @return {RegExp}
         * @api public
         */

        braces.makeRe = function (pattern, options) {
          if (typeof pattern !== "string") {
            throw new TypeError("expected a string");
          }

          var maxLength = (options && options.maxLength) || MAX_LENGTH;
          if (pattern.length >= maxLength) {
            throw new Error(
              "expected pattern to be less than " + maxLength + " characters"
            );
          }

          function makeRe() {
            var arr = braces(pattern, options);
            var opts = extend({ strictErrors: false }, options);
            return toRegex(arr, opts);
          }

          return memoize("makeRe", pattern, options, makeRe);
        };

        /**
         * Parse the given `str` with the given `options`.
         *
         * ```js
         * var braces = require('braces');
         * var ast = braces.parse('a/{b,c}/d');
         * console.log(ast);
         * // { type: 'root',
         * //   errors: [],
         * //   input: 'a/{b,c}/d',
         * //   nodes:
         * //    [ { type: 'bos', val: '' },
         * //      { type: 'text', val: 'a/' },
         * //      { type: 'brace',
         * //        nodes:
         * //         [ { type: 'brace.open', val: '{' },
         * //           { type: 'text', val: 'b,c' },
         * //           { type: 'brace.close', val: '}' } ] },
         * //      { type: 'text', val: '/d' },
         * //      { type: 'eos', val: '' } ] }
         * ```
         * @param {String} `pattern` Brace pattern to parse
         * @param {Object} `options`
         * @return {Object} Returns an AST
         * @api public
         */

        braces.parse = function (pattern, options) {
          var proto = new Braces(options);
          return proto.parse(pattern, options);
        };

        /**
         * Compile the given `ast` or string with the given `options`.
         *
         * ```js
         * var braces = require('braces');
         * var ast = braces.parse('a/{b,c}/d');
         * console.log(braces.compile(ast));
         * // { options: { source: 'string' },
         * //   state: {},
         * //   compilers:
         * //    { eos: [Function],
         * //      noop: [Function],
         * //      bos: [Function],
         * //      brace: [Function],
         * //      'brace.open': [Function],
         * //      text: [Function],
         * //      'brace.close': [Function] },
         * //   output: [ 'a/(b|c)/d' ],
         * //   ast:
         * //    { ... },
         * //   parsingErrors: [] }
         * ```
         * @param {Object|String} `ast` AST from [.parse](#parse). If a string is passed it will be parsed first.
         * @param {Object} `options`
         * @return {Object} Returns an object that has an `output` property with the compiled string.
         * @api public
         */

        braces.compile = function (ast, options) {
          var proto = new Braces(options);
          return proto.compile(ast, options);
        };

        /**
         * Clear the regex cache.
         *
         * ```js
         * braces.clearCache();
         * ```
         * @api public
         */

        braces.clearCache = function () {
          cache = braces.cache = {};
        };

        /**
         * Memoize a generated regex or function. A unique key is generated
         * from the method name, pattern, and user-defined options. Set
         * options.memoize to false to disable.
         */

        function memoize(type, pattern, options, fn) {
          var key = utils.createKey(type + ":" + pattern, options);
          var disabled = options && options.cache === false;
          if (disabled) {
            braces.clearCache();
            return fn(pattern, options);
          }

          if (cache.hasOwnProperty(key)) {
            return cache[key];
          }

          var res = fn(pattern, options);
          cache[key] = res;
          return res;
        }

        /**
         * Expose `Braces` constructor and methods
         * @type {Function}
         */

        braces.Braces = Braces;
        braces.compilers = compilers;
        braces.parsers = parsers;
        braces.cache = cache;

        /**
         * Expose `braces`
         * @type {Function}
         */

        module.exports = braces;
      },
      {
        "./lib/braces": 142,
        "./lib/compilers": 143,
        "./lib/parsers": 144,
        "./lib/utils": 145,
        "array-unique": 6,
        "extend-shallow": 146,
        "to-regex": 248,
      },
    ],
    142: [
      function (require, module, exports) {
        "use strict";

        var extend = require("extend-shallow");
        var Snapdragon = require("snapdragon");
        var compilers = require("./compilers");
        var parsers = require("./parsers");
        var utils = require("./utils");

        /**
         * Customize Snapdragon parser and renderer
         */

        function Braces(options) {
          this.options = extend({}, options);
        }

        /**
         * Initialize braces
         */

        Braces.prototype.init = function (options) {
          if (this.isInitialized) return;
          this.isInitialized = true;
          var opts = utils.createOptions({}, this.options, options);
          this.snapdragon = this.options.snapdragon || new Snapdragon(opts);
          this.compiler = this.snapdragon.compiler;
          this.parser = this.snapdragon.parser;

          compilers(this.snapdragon, opts);
          parsers(this.snapdragon, opts);

          /**
           * Call Snapdragon `.parse` method. When AST is returned, we check to
           * see if any unclosed braces are left on the stack and, if so, we iterate
           * over the stack and correct the AST so that compilers are called in the correct
           * order and unbalance braces are properly escaped.
           */

          utils.define(this.snapdragon, "parse", function (pattern, options) {
            var parsed = Snapdragon.prototype.parse.apply(this, arguments);
            this.parser.ast.input = pattern;

            var stack = this.parser.stack;
            while (stack.length) {
              addParent({ type: "brace.close", val: "" }, stack.pop());
            }

            function addParent(node, parent) {
              utils.define(node, "parent", parent);
              parent.nodes.push(node);
            }

            // add non-enumerable parser reference
            utils.define(parsed, "parser", this.parser);
            return parsed;
          });
        };

        /**
         * Decorate `.parse` method
         */

        Braces.prototype.parse = function (ast, options) {
          if (ast && typeof ast === "object" && ast.nodes) return ast;
          this.init(options);
          return this.snapdragon.parse(ast, options);
        };

        /**
         * Decorate `.compile` method
         */

        Braces.prototype.compile = function (ast, options) {
          if (typeof ast === "string") {
            ast = this.parse(ast, options);
          } else {
            this.init(options);
          }
          return this.snapdragon.compile(ast, options);
        };

        /**
         * Expand
         */

        Braces.prototype.expand = function (pattern) {
          var ast = this.parse(pattern, { expand: true });
          return this.compile(ast, { expand: true });
        };

        /**
         * Optimize
         */

        Braces.prototype.optimize = function (pattern) {
          var ast = this.parse(pattern, { optimize: true });
          return this.compile(ast, { optimize: true });
        };

        /**
         * Expose `Braces`
         */

        module.exports = Braces;
      },
      {
        "./compilers": 143,
        "./parsers": 144,
        "./utils": 145,
        "extend-shallow": 146,
        snapdragon: 204,
      },
    ],
    143: [
      function (require, module, exports) {
        "use strict";

        var utils = require("./utils");

        module.exports = function (braces, options) {
          braces.compiler

            /**
             * bos
             */

            .set("bos", function () {
              if (this.output) return;
              this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];
              this.ast.count = 1;
            })

            /**
             * Square brackets
             */

            .set("bracket", function (node) {
              var close = node.close;
              var open = !node.escaped ? "[" : "\\[";
              var negated = node.negated;
              var inner = node.inner;

              inner = inner.replace(/\\(?=[\\\w]|$)/g, "\\\\");
              if (inner === "]-") {
                inner = "\\]\\-";
              }

              if (negated && inner.indexOf(".") === -1) {
                inner += ".";
              }
              if (negated && inner.indexOf("/") === -1) {
                inner += "/";
              }

              var val = open + negated + inner + close;
              var queue = node.parent.queue;
              var last = utils.arrayify(queue.pop());

              queue.push(utils.join(last, val));
              queue.push.apply(queue, []);
            })

            /**
             * Brace
             */

            .set("brace", function (node) {
              node.queue = isEscaped(node) ? [node.val] : [];
              node.count = 1;
              return this.mapVisit(node.nodes);
            })

            /**
             * Open
             */

            .set("brace.open", function (node) {
              node.parent.open = node.val;
            })

            /**
             * Inner
             */

            .set("text", function (node) {
              var queue = node.parent.queue;
              var escaped = node.escaped;
              var segs = [node.val];

              if (node.optimize === false) {
                options = utils.extend({}, options, { optimize: false });
              }

              if (node.multiplier > 1) {
                node.parent.count *= node.multiplier;
              }

              if (
                options.quantifiers === true &&
                utils.isQuantifier(node.val)
              ) {
                escaped = true;
              } else if (node.val.length > 1) {
                if (isType(node.parent, "brace") && !isEscaped(node)) {
                  var expanded = utils.expand(node.val, options);
                  segs = expanded.segs;

                  if (expanded.isOptimized) {
                    node.parent.isOptimized = true;
                  }

                  // if nothing was expanded, we probably have a literal brace
                  if (!segs.length) {
                    var val = expanded.val || node.val;
                    if (options.unescape !== false) {
                      // unescape unexpanded brace sequence/set separators
                      val = val.replace(/\\([,.])/g, "$1");
                      // strip quotes
                      val = val.replace(/["'`]/g, "");
                    }

                    segs = [val];
                    escaped = true;
                  }
                }
              } else if (node.val === ",") {
                if (options.expand) {
                  node.parent.queue.push([""]);
                  segs = [""];
                } else {
                  segs = ["|"];
                }
              } else {
                escaped = true;
              }

              if (escaped && isType(node.parent, "brace")) {
                if (node.parent.nodes.length <= 4 && node.parent.count === 1) {
                  node.parent.escaped = true;
                } else if (node.parent.length <= 3) {
                  node.parent.escaped = true;
                }
              }

              if (!hasQueue(node.parent)) {
                node.parent.queue = segs;
                return;
              }

              var last = utils.arrayify(queue.pop());
              if (node.parent.count > 1 && options.expand) {
                last = multiply(last, node.parent.count);
                node.parent.count = 1;
              }

              queue.push(utils.join(utils.flatten(last), segs.shift()));
              queue.push.apply(queue, segs);
            })

            /**
             * Close
             */

            .set("brace.close", function (node) {
              var queue = node.parent.queue;
              var prev = node.parent.parent;
              var last = prev.queue.pop();
              var open = node.parent.open;
              var close = node.val;

              if (open && close && isOptimized(node, options)) {
                open = "(";
                close = ")";
              }

              // if a close brace exists, and the previous segment is one character
              // don't wrap the result in braces or parens
              var ele = utils.last(queue);
              if (node.parent.count > 1 && options.expand) {
                ele = multiply(queue.pop(), node.parent.count);
                node.parent.count = 1;
                queue.push(ele);
              }

              if (close && typeof ele === "string" && ele.length === 1) {
                open = "";
                close = "";
              }

              if (
                (isLiteralBrace(node, options) || noInner(node)) &&
                !node.parent.hasEmpty
              ) {
                queue.push(utils.join(open, queue.pop() || ""));
                queue = utils.flatten(utils.join(queue, close));
              }

              if (typeof last === "undefined") {
                prev.queue = [queue];
              } else {
                prev.queue.push(utils.flatten(utils.join(last, queue)));
              }
            })

            /**
             * eos
             */

            .set("eos", function (node) {
              if (this.input) return;

              if (options.optimize !== false) {
                this.output = utils.last(utils.flatten(this.ast.queue));
              } else if (Array.isArray(utils.last(this.ast.queue))) {
                this.output = utils.flatten(this.ast.queue.pop());
              } else {
                this.output = utils.flatten(this.ast.queue);
              }

              if (node.parent.count > 1 && options.expand) {
                this.output = multiply(this.output, node.parent.count);
              }

              this.output = utils.arrayify(this.output);
              this.ast.queue = [];
            });
        };

        /**
         * Multiply the segments in the current brace level
         */

        function multiply(queue, n, options) {
          return utils.flatten(utils.repeat(utils.arrayify(queue), n));
        }

        /**
         * Return true if `node` is escaped
         */

        function isEscaped(node) {
          return node.escaped === true;
        }

        /**
         * Returns true if regex parens should be used for sets. If the parent `type`
         * is not `brace`, then we're on a root node, which means we should never
         * expand segments and open/close braces should be `{}` (since this indicates
         * a brace is missing from the set)
         */

        function isOptimized(node, options) {
          if (node.parent.isOptimized) return true;
          return (
            isType(node.parent, "brace") &&
            !isEscaped(node.parent) &&
            options.expand !== true
          );
        }

        /**
         * Returns true if the value in `node` should be wrapped in a literal brace.
         * @return {Boolean}
         */

        function isLiteralBrace(node, options) {
          return isEscaped(node.parent) || options.optimize !== false;
        }

        /**
         * Returns true if the given `node` does not have an inner value.
         * @return {Boolean}
         */

        function noInner(node, type) {
          if (node.parent.queue.length === 1) {
            return true;
          }
          var nodes = node.parent.nodes;
          return (
            nodes.length === 3 &&
            isType(nodes[0], "brace.open") &&
            !isType(nodes[1], "text") &&
            isType(nodes[2], "brace.close")
          );
        }

        /**
         * Returns true if the given `node` is the given `type`
         * @return {Boolean}
         */

        function isType(node, type) {
          return typeof node !== "undefined" && node.type === type;
        }

        /**
         * Returns true if the given `node` has a non-empty queue.
         * @return {Boolean}
         */

        function hasQueue(node) {
          return Array.isArray(node.queue) && node.queue.length;
        }
      },
      { "./utils": 145 },
    ],
    144: [
      function (require, module, exports) {
        "use strict";

        var Node = require("snapdragon-node");
        var utils = require("./utils");

        /**
         * Braces parsers
         */

        module.exports = function (braces, options) {
          braces.parser
            .set("bos", function () {
              if (!this.parsed) {
                this.ast = this.nodes[0] = new Node(this.ast);
              }
            })

            /**
             * Character parsers
             */

            .set("escape", function () {
              var pos = this.position();
              var m = this.match(/^(?:\\(.)|\$\{)/);
              if (!m) return;

              var prev = this.prev();
              var last = utils.last(prev.nodes);

              var node = pos(
                new Node({
                  type: "text",
                  multiplier: 1,
                  val: m[0],
                })
              );

              if (node.val === "\\\\") {
                return node;
              }

              if (node.val === "${") {
                var str = this.input;
                var idx = -1;
                var ch;

                while ((ch = str[++idx])) {
                  this.consume(1);
                  node.val += ch;
                  if (ch === "\\") {
                    node.val += str[++idx];
                    continue;
                  }
                  if (ch === "}") {
                    break;
                  }
                }
              }

              if (this.options.unescape !== false) {
                node.val = node.val.replace(/\\([{}])/g, "$1");
              }

              if (last.val === '"' && this.input.charAt(0) === '"') {
                last.val = node.val;
                this.consume(1);
                return;
              }

              return concatNodes.call(this, pos, node, prev, options);
            })

            /**
             * Brackets: "[...]" (basic, this is overridden by
             * other parsers in more advanced implementations)
             */

            .set("bracket", function () {
              var isInside = this.isInside("brace");
              var pos = this.position();
              var m = this.match(
                /^(?:\[([!^]?)([^\]]{2,}|\]-)(\]|[^*+?]+)|\[)/
              );
              if (!m) return;

              var prev = this.prev();
              var val = m[0];
              var negated = m[1] ? "^" : "";
              var inner = m[2] || "";
              var close = m[3] || "";

              if (isInside && prev.type === "brace") {
                prev.text = prev.text || "";
                prev.text += val;
              }

              var esc = this.input.slice(0, 2);
              if (inner === "" && esc === "\\]") {
                inner += esc;
                this.consume(2);

                var str = this.input;
                var idx = -1;
                var ch;

                while ((ch = str[++idx])) {
                  this.consume(1);
                  if (ch === "]") {
                    close = ch;
                    break;
                  }
                  inner += ch;
                }
              }

              return pos(
                new Node({
                  type: "bracket",
                  val: val,
                  escaped: close !== "]",
                  negated: negated,
                  inner: inner,
                  close: close,
                })
              );
            })

            /**
             * Empty braces (we capture these early to
             * speed up processing in the compiler)
             */

            .set("multiplier", function () {
              var isInside = this.isInside("brace");
              var pos = this.position();
              var m = this.match(/^\{((?:,|\{,+\})+)\}/);
              if (!m) return;

              this.multiplier = true;
              var prev = this.prev();
              var val = m[0];

              if (isInside && prev.type === "brace") {
                prev.text = prev.text || "";
                prev.text += val;
              }

              var node = pos(
                new Node({
                  type: "text",
                  multiplier: 1,
                  match: m,
                  val: val,
                })
              );

              return concatNodes.call(this, pos, node, prev, options);
            })

            /**
             * Open
             */

            .set("brace.open", function () {
              var pos = this.position();
              var m = this.match(/^\{(?!(?:[^\\}]?|,+)\})/);
              if (!m) return;

              var prev = this.prev();
              var last = utils.last(prev.nodes);

              // if the last parsed character was an extglob character
              // we need to _not optimize_ the brace pattern because
              // it might be mistaken for an extglob by a downstream parser
              if (last && last.val && isExtglobChar(last.val.slice(-1))) {
                last.optimize = false;
              }

              var open = pos(
                new Node({
                  type: "brace.open",
                  val: m[0],
                })
              );

              var node = pos(
                new Node({
                  type: "brace",
                  nodes: [],
                })
              );

              node.push(open);
              prev.push(node);
              this.push("brace", node);
            })

            /**
             * Close
             */

            .set("brace.close", function () {
              var pos = this.position();
              var m = this.match(/^\}/);
              if (!m || !m[0]) return;

              var brace = this.pop("brace");
              var node = pos(
                new Node({
                  type: "brace.close",
                  val: m[0],
                })
              );

              if (!this.isType(brace, "brace")) {
                if (this.options.strict) {
                  throw new Error('missing opening "{"');
                }
                node.type = "text";
                node.multiplier = 0;
                node.escaped = true;
                return node;
              }

              var prev = this.prev();
              var last = utils.last(prev.nodes);
              if (last.text) {
                var lastNode = utils.last(last.nodes);
                if (lastNode.val === ")" && /[!@*?+]\(/.test(last.text)) {
                  var open = last.nodes[0];
                  var text = last.nodes[1];
                  if (
                    open.type === "brace.open" &&
                    text &&
                    text.type === "text"
                  ) {
                    text.optimize = false;
                  }
                }
              }

              if (brace.nodes.length > 2) {
                var first = brace.nodes[1];
                if (first.type === "text" && first.val === ",") {
                  brace.nodes.splice(1, 1);
                  brace.nodes.push(first);
                }
              }

              brace.push(node);
            })

            /**
             * Capture boundary characters
             */

            .set("boundary", function () {
              var pos = this.position();
              var m = this.match(/^[$^](?!\{)/);
              if (!m) return;
              return pos(
                new Node({
                  type: "text",
                  val: m[0],
                })
              );
            })

            /**
             * One or zero, non-comma characters wrapped in braces
             */

            .set("nobrace", function () {
              var isInside = this.isInside("brace");
              var pos = this.position();
              var m = this.match(/^\{[^,]?\}/);
              if (!m) return;

              var prev = this.prev();
              var val = m[0];

              if (isInside && prev.type === "brace") {
                prev.text = prev.text || "";
                prev.text += val;
              }

              return pos(
                new Node({
                  type: "text",
                  multiplier: 0,
                  val: val,
                })
              );
            })

            /**
             * Text
             */

            .set("text", function () {
              var isInside = this.isInside("brace");
              var pos = this.position();
              var m = this.match(/^((?!\\)[^${}[\]])+/);
              if (!m) return;

              var prev = this.prev();
              var val = m[0];

              if (isInside && prev.type === "brace") {
                prev.text = prev.text || "";
                prev.text += val;
              }

              var node = pos(
                new Node({
                  type: "text",
                  multiplier: 1,
                  val: val,
                })
              );

              return concatNodes.call(this, pos, node, prev, options);
            });
        };

        /**
         * Returns true if the character is an extglob character.
         */

        function isExtglobChar(ch) {
          return (
            ch === "!" || ch === "@" || ch === "*" || ch === "?" || ch === "+"
          );
        }

        /**
         * Combine text nodes, and calculate empty sets (`{,,}`)
         * @param {Function} `pos` Function to calculate node position
         * @param {Object} `node` AST node
         * @return {Object}
         */

        function concatNodes(pos, node, parent, options) {
          node.orig = node.val;
          var prev = this.prev();
          var last = utils.last(prev.nodes);
          var isEscaped = false;

          if (node.val.length > 1) {
            var a = node.val.charAt(0);
            var b = node.val.slice(-1);

            isEscaped =
              (a === '"' && b === '"') ||
              (a === "'" && b === "'") ||
              (a === "`" && b === "`");
          }

          if (isEscaped && options.unescape !== false) {
            node.val = node.val.slice(1, node.val.length - 1);
            node.escaped = true;
          }

          if (node.match) {
            var match = node.match[1];
            if (!match || match.indexOf("}") === -1) {
              match = node.match[0];
            }

            // replace each set with a single ","
            var val = match.replace(/\{/g, ",").replace(/\}/g, "");
            node.multiplier *= val.length;
            node.val = "";
          }

          var simpleText =
            last.type === "text" &&
            last.multiplier === 1 &&
            node.multiplier === 1 &&
            node.val;

          if (simpleText) {
            last.val += node.val;
            return;
          }

          prev.push(node);
        }
      },
      { "./utils": 145, "snapdragon-node": 201 },
    ],
    145: [
      function (require, module, exports) {
        "use strict";

        var splitString = require("split-string");
        var utils = module.exports;

        /**
         * Module dependencies
         */

        utils.extend = require("extend-shallow");
        utils.flatten = require("arr-flatten");
        utils.isObject = require("isobject");
        utils.fillRange = require("fill-range");
        utils.repeat = require("repeat-element");
        utils.unique = require("array-unique");

        utils.define = function (obj, key, val) {
          Object.defineProperty(obj, key, {
            writable: true,
            configurable: true,
            enumerable: false,
            value: val,
          });
        };

        /**
         * Returns true if the given string contains only empty brace sets.
         */

        utils.isEmptySets = function (str) {
          return /^(?:\{,\})+$/.test(str);
        };

        /**
         * Returns true if the given string contains only empty brace sets.
         */

        utils.isQuotedString = function (str) {
          var open = str.charAt(0);
          if (open === "'" || open === '"' || open === "`") {
            return str.slice(-1) === open;
          }
          return false;
        };

        /**
         * Create the key to use for memoization. The unique key is generated
         * by iterating over the options and concatenating key-value pairs
         * to the pattern string.
         */

        utils.createKey = function (pattern, options) {
          var id = pattern;
          if (typeof options === "undefined") {
            return id;
          }
          var keys = Object.keys(options);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            id += ";" + key + "=" + String(options[key]);
          }
          return id;
        };

        /**
         * Normalize options
         */

        utils.createOptions = function (options) {
          var opts = utils.extend.apply(null, arguments);
          if (typeof opts.expand === "boolean") {
            opts.optimize = !opts.expand;
          }
          if (typeof opts.optimize === "boolean") {
            opts.expand = !opts.optimize;
          }
          if (opts.optimize === true) {
            opts.makeRe = true;
          }
          return opts;
        };

        /**
         * Join patterns in `a` to patterns in `b`
         */

        utils.join = function (a, b, options) {
          options = options || {};
          a = utils.arrayify(a);
          b = utils.arrayify(b);

          if (!a.length) return b;
          if (!b.length) return a;

          var len = a.length;
          var idx = -1;
          var arr = [];

          while (++idx < len) {
            var val = a[idx];
            if (Array.isArray(val)) {
              for (var i = 0; i < val.length; i++) {
                val[i] = utils.join(val[i], b, options);
              }
              arr.push(val);
              continue;
            }

            for (var j = 0; j < b.length; j++) {
              var bval = b[j];

              if (Array.isArray(bval)) {
                arr.push(utils.join(val, bval, options));
              } else {
                arr.push(val + bval);
              }
            }
          }
          return arr;
        };

        /**
         * Split the given string on `,` if not escaped.
         */

        utils.split = function (str, options) {
          var opts = utils.extend({ sep: "," }, options);
          if (typeof opts.keepQuotes !== "boolean") {
            opts.keepQuotes = true;
          }
          if (opts.unescape === false) {
            opts.keepEscaping = true;
          }
          return splitString(str, opts, utils.escapeBrackets(opts));
        };

        /**
         * Expand ranges or sets in the given `pattern`.
         *
         * @param {String} `str`
         * @param {Object} `options`
         * @return {Object}
         */

        utils.expand = function (str, options) {
          var opts = utils.extend({ rangeLimit: 10000 }, options);
          var segs = utils.split(str, opts);
          var tok = { segs: segs };

          if (utils.isQuotedString(str)) {
            return tok;
          }

          if (opts.rangeLimit === true) {
            opts.rangeLimit = 10000;
          }

          if (segs.length > 1) {
            if (opts.optimize === false) {
              tok.val = segs[0];
              return tok;
            }

            tok.segs = utils.stringifyArray(tok.segs);
          } else if (segs.length === 1) {
            var arr = str.split("..");

            if (arr.length === 1) {
              tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;
              tok.segs = [];
              return tok;
            }

            if (arr.length === 2 && arr[0] === arr[1]) {
              tok.escaped = true;
              tok.val = arr[0];
              tok.segs = [];
              return tok;
            }

            if (arr.length > 1) {
              if (opts.optimize !== false) {
                opts.optimize = true;
                delete opts.expand;
              }

              if (opts.optimize !== true) {
                var min = Math.min(arr[0], arr[1]);
                var max = Math.max(arr[0], arr[1]);
                var step = arr[2] || 1;

                if (
                  opts.rangeLimit !== false &&
                  (max - min) / step >= opts.rangeLimit
                ) {
                  throw new RangeError(
                    "expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit."
                  );
                }
              }

              arr.push(opts);
              tok.segs = utils.fillRange.apply(null, arr);

              if (!tok.segs.length) {
                tok.escaped = true;
                tok.val = str;
                return tok;
              }

              if (opts.optimize === true) {
                tok.segs = utils.stringifyArray(tok.segs);
              }

              if (tok.segs === "") {
                tok.val = str;
              } else {
                tok.val = tok.segs[0];
              }
              return tok;
            }
          } else {
            tok.val = str;
          }
          return tok;
        };

        /**
         * Ensure commas inside brackets and parens are not split.
         * @param {Object} `tok` Token from the `split-string` module
         * @return {undefined}
         */

        utils.escapeBrackets = function (options) {
          return function (tok) {
            if (tok.escaped && tok.val === "b") {
              tok.val = "\\b";
              return;
            }

            if (tok.val !== "(" && tok.val !== "[") return;
            var opts = utils.extend({}, options);
            var brackets = [];
            var parens = [];
            var stack = [];
            var val = tok.val;
            var str = tok.str;
            var i = tok.idx - 1;

            while (++i < str.length) {
              var ch = str[i];

              if (ch === "\\") {
                val += (opts.keepEscaping === false ? "" : ch) + str[++i];
                continue;
              }

              if (ch === "(") {
                parens.push(ch);
                stack.push(ch);
              }

              if (ch === "[") {
                brackets.push(ch);
                stack.push(ch);
              }

              if (ch === ")") {
                parens.pop();
                stack.pop();
                if (!stack.length) {
                  val += ch;
                  break;
                }
              }

              if (ch === "]") {
                brackets.pop();
                stack.pop();
                if (!stack.length) {
                  val += ch;
                  break;
                }
              }
              val += ch;
            }

            tok.split = false;
            tok.val = val.slice(1);
            tok.idx = i;
          };
        };

        /**
         * Returns true if the given string looks like a regex quantifier
         * @return {Boolean}
         */

        utils.isQuantifier = function (str) {
          return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);
        };

        /**
         * Cast `val` to an array.
         * @param {*} `val`
         */

        utils.stringifyArray = function (arr) {
          return [utils.arrayify(arr).join("|")];
        };

        /**
         * Cast `val` to an array.
         * @param {*} `val`
         */

        utils.arrayify = function (arr) {
          if (typeof arr === "undefined") {
            return [];
          }
          if (typeof arr === "string") {
            return [arr];
          }
          return arr;
        };

        /**
         * Returns true if the given `str` is a non-empty string
         * @return {Boolean}
         */

        utils.isString = function (str) {
          return str != null && typeof str === "string";
        };

        /**
         * Get the last element from `array`
         * @param {Array} `array`
         * @return {*}
         */

        utils.last = function (arr, n) {
          return arr[arr.length - (n || 1)];
        };

        utils.escapeRegex = function (str) {
          return str.replace(/\\?([!^*?()[\]{}+?/])/g, "\\$1");
        };
      },
      {
        "arr-flatten": 2,
        "array-unique": 6,
        "extend-shallow": 146,
        "fill-range": 150,
        isobject: 131,
        "repeat-element": 189,
        "split-string": 232,
      },
    ],
    146: [
      function (require, module, exports) {
        arguments[4][61][0].apply(exports, arguments);
      },
      { dup: 61, "is-extendable": 119 },
    ],
    147: [
      function (require, module, exports) {
        /*!
         * define-property <https://github.com/jonschlinkert/define-property>
         *
         * Copyright (c) 2015-2018, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var isobject = require("isobject");
        var isDescriptor = require("is-descriptor");
        var define =
          typeof Reflect !== "undefined" && Reflect.defineProperty
            ? Reflect.defineProperty
            : Object.defineProperty;

        module.exports = function defineProperty(obj, key, val) {
          if (
            !isobject(obj) &&
            typeof obj !== "function" &&
            !Array.isArray(obj)
          ) {
            throw new TypeError("expected an object, function, or array");
          }

          if (typeof key !== "string") {
            throw new TypeError('expected "key" to be a string');
          }

          if (isDescriptor(val)) {
            define(obj, key, val);
            return obj;
          }

          define(obj, key, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: val,
          });

          return obj;
        };
      },
      { "is-descriptor": 117, isobject: 131 },
    ],
    148: [
      function (require, module, exports) {
        "use strict";

        var isExtendable = require("is-extendable");
        var assignSymbols = require("assign-symbols");

        module.exports =
          Object.assign ||
          function (obj /*, objects*/) {
            if (obj === null || typeof obj === "undefined") {
              throw new TypeError("Cannot convert undefined or null to object");
            }
            if (!isObject(obj)) {
              obj = {};
            }
            for (var i = 1; i < arguments.length; i++) {
              var val = arguments[i];
              if (isString(val)) {
                val = toObject(val);
              }
              if (isObject(val)) {
                assign(obj, val);
                assignSymbols(obj, val);
              }
            }
            return obj;
          };

        function assign(a, b) {
          for (var key in b) {
            if (hasOwn(b, key)) {
              a[key] = b[key];
            }
          }
        }

        function isString(val) {
          return val && typeof val === "string";
        }

        function toObject(str) {
          var obj = {};
          for (var i in str) {
            obj[i] = str[i];
          }
          return obj;
        }

        function isObject(val) {
          return (val && typeof val === "object") || isExtendable(val);
        }

        /**
         * Returns true if the given `key` is an own property of `obj`.
         */

        function hasOwn(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        }

        function isEnum(obj, key) {
          return Object.prototype.propertyIsEnumerable.call(obj, key);
        }
      },
      { "assign-symbols": 7, "is-extendable": 149 },
    ],
    149: [
      function (require, module, exports) {
        /*!
         * is-extendable <https://github.com/jonschlinkert/is-extendable>
         *
         * Copyright (c) 2015-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var isPlainObject = require("is-plain-object");

        module.exports = function isExtendable(val) {
          return (
            isPlainObject(val) ||
            typeof val === "function" ||
            Array.isArray(val)
          );
        };
      },
      { "is-plain-object": 126 },
    ],
    150: [
      function (require, module, exports) {
        /*!
         * fill-range <https://github.com/jonschlinkert/fill-range>
         *
         * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var util = require("util");
        var isNumber = require("is-number");
        var extend = require("extend-shallow");
        var repeat = require("repeat-string");
        var toRegex = require("to-regex-range");

        /**
         * Return a range of numbers or letters.
         *
         * @param  {String} `start` Start of the range
         * @param  {String} `stop` End of the range
         * @param  {String} `step` Increment or decrement to use.
         * @param  {Function} `fn` Custom function to modify each element in the range.
         * @return {Array}
         */

        function fillRange(start, stop, step, options) {
          if (typeof start === "undefined") {
            return [];
          }

          if (typeof stop === "undefined" || start === stop) {
            // special case, for handling negative zero
            var isString = typeof start === "string";
            if (isNumber(start) && !toNumber(start)) {
              return [isString ? "0" : 0];
            }
            return [start];
          }

          if (typeof step !== "number" && typeof step !== "string") {
            options = step;
            step = undefined;
          }

          if (typeof options === "function") {
            options = { transform: options };
          }

          var opts = extend({ step: step }, options);
          if (opts.step && !isValidNumber(opts.step)) {
            if (opts.strictRanges === true) {
              throw new TypeError("expected options.step to be a number");
            }
            return [];
          }

          opts.isNumber = isValidNumber(start) && isValidNumber(stop);
          if (!opts.isNumber && !isValid(start, stop)) {
            if (opts.strictRanges === true) {
              throw new RangeError(
                "invalid range arguments: " + util.inspect([start, stop])
              );
            }
            return [];
          }

          opts.isPadded = isPadded(start) || isPadded(stop);
          opts.toString =
            opts.stringify ||
            typeof opts.step === "string" ||
            typeof start === "string" ||
            typeof stop === "string" ||
            !opts.isNumber;

          if (opts.isPadded) {
            opts.maxLength = Math.max(
              String(start).length,
              String(stop).length
            );
          }

          // support legacy minimatch/fill-range options
          if (typeof opts.optimize === "boolean") opts.toRegex = opts.optimize;
          if (typeof opts.makeRe === "boolean") opts.toRegex = opts.makeRe;
          return expand(start, stop, opts);
        }

        function expand(start, stop, options) {
          var a = options.isNumber ? toNumber(start) : start.charCodeAt(0);
          var b = options.isNumber ? toNumber(stop) : stop.charCodeAt(0);

          var step = Math.abs(toNumber(options.step)) || 1;
          if (options.toRegex && step === 1) {
            return toRange(a, b, start, stop, options);
          }

          var zero = { greater: [], lesser: [] };
          var asc = a < b;
          var arr = new Array(Math.round((asc ? b - a : a - b) / step));
          var idx = 0;

          while (asc ? a <= b : a >= b) {
            var val = options.isNumber ? a : String.fromCharCode(a);
            if (options.toRegex && (val >= 0 || !options.isNumber)) {
              zero.greater.push(val);
            } else {
              zero.lesser.push(Math.abs(val));
            }

            if (options.isPadded) {
              val = zeros(val, options);
            }

            if (options.toString) {
              val = String(val);
            }

            if (typeof options.transform === "function") {
              arr[idx++] = options.transform(
                val,
                a,
                b,
                step,
                idx,
                arr,
                options
              );
            } else {
              arr[idx++] = val;
            }

            if (asc) {
              a += step;
            } else {
              a -= step;
            }
          }

          if (options.toRegex === true) {
            return toSequence(arr, zero, options);
          }
          return arr;
        }

        function toRange(a, b, start, stop, options) {
          if (options.isPadded) {
            return toRegex(start, stop, options);
          }

          if (options.isNumber) {
            return toRegex(Math.min(a, b), Math.max(a, b), options);
          }

          var start = String.fromCharCode(Math.min(a, b));
          var stop = String.fromCharCode(Math.max(a, b));
          return "[" + start + "-" + stop + "]";
        }

        function toSequence(arr, zeros, options) {
          var greater = "",
            lesser = "";
          if (zeros.greater.length) {
            greater = zeros.greater.join("|");
          }
          if (zeros.lesser.length) {
            lesser = "-(" + zeros.lesser.join("|") + ")";
          }
          var res =
            greater && lesser ? greater + "|" + lesser : greater || lesser;

          if (options.capture) {
            return "(" + res + ")";
          }
          return res;
        }

        function zeros(val, options) {
          if (options.isPadded) {
            var str = String(val);
            var len = str.length;
            var dash = "";
            if (str.charAt(0) === "-") {
              dash = "-";
              str = str.slice(1);
            }
            var diff = options.maxLength - len;
            var pad = repeat("0", diff);
            val = dash + pad + str;
          }
          if (options.stringify) {
            return String(val);
          }
          return val;
        }

        function toNumber(val) {
          return Number(val) || 0;
        }

        function isPadded(str) {
          return /^-?0\d/.test(str);
        }

        function isValid(min, max) {
          return (
            (isValidNumber(min) || isValidLetter(min)) &&
            (isValidNumber(max) || isValidLetter(max))
          );
        }

        function isValidLetter(ch) {
          return typeof ch === "string" && ch.length === 1 && /^\w+$/.test(ch);
        }

        function isValidNumber(n) {
          return isNumber(n) && !/\./.test(n);
        }

        /**
         * Expose `fillRange`
         * @type {Function}
         */

        module.exports = fillRange;
      },
      {
        "extend-shallow": 151,
        "is-number": 152,
        "repeat-string": 190,
        "to-regex-range": 154,
        util: 264,
      },
    ],
    151: [
      function (require, module, exports) {
        arguments[4][61][0].apply(exports, arguments);
      },
      { dup: 61, "is-extendable": 119 },
    ],
    152: [
      function (require, module, exports) {
        arguments[4][105][0].apply(exports, arguments);
      },
      { dup: 105, "kind-of": 153 },
    ],
    153: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    154: [
      function (require, module, exports) {
        /*!
         * to-regex-range <https://github.com/jonschlinkert/to-regex-range>
         *
         * Copyright (c) 2015, 2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var repeat = require("repeat-string");
        var isNumber = require("is-number");
        var cache = {};

        function toRegexRange(min, max, options) {
          if (isNumber(min) === false) {
            throw new RangeError("toRegexRange: first argument is invalid.");
          }

          if (typeof max === "undefined" || min === max) {
            return String(min);
          }

          if (isNumber(max) === false) {
            throw new RangeError("toRegexRange: second argument is invalid.");
          }

          options = options || {};
          var relax = String(options.relaxZeros);
          var shorthand = String(options.shorthand);
          var capture = String(options.capture);
          var key = min + ":" + max + "=" + relax + shorthand + capture;
          if (cache.hasOwnProperty(key)) {
            return cache[key].result;
          }

          var a = Math.min(min, max);
          var b = Math.max(min, max);

          if (Math.abs(a - b) === 1) {
            var result = min + "|" + max;
            if (options.capture) {
              return "(" + result + ")";
            }
            return result;
          }

          var isPadded = padding(min) || padding(max);
          var positives = [];
          var negatives = [];

          var tok = { min: min, max: max, a: a, b: b };
          if (isPadded) {
            tok.isPadded = isPadded;
            tok.maxLen = String(tok.max).length;
          }

          if (a < 0) {
            var newMin = b < 0 ? Math.abs(b) : 1;
            var newMax = Math.abs(a);
            negatives = splitToPatterns(newMin, newMax, tok, options);
            a = tok.a = 0;
          }

          if (b >= 0) {
            positives = splitToPatterns(a, b, tok, options);
          }

          tok.negatives = negatives;
          tok.positives = positives;
          tok.result = siftPatterns(negatives, positives, options);

          if (options.capture && positives.length + negatives.length > 1) {
            tok.result = "(" + tok.result + ")";
          }

          cache[key] = tok;
          return tok.result;
        }

        function siftPatterns(neg, pos, options) {
          var onlyNegative =
            filterPatterns(neg, pos, "-", false, options) || [];
          var onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
          var intersected = filterPatterns(neg, pos, "-?", true, options) || [];
          var subpatterns = onlyNegative
            .concat(intersected)
            .concat(onlyPositive);
          return subpatterns.join("|");
        }

        function splitToRanges(min, max) {
          min = Number(min);
          max = Number(max);

          var nines = 1;
          var stops = [max];
          var stop = +countNines(min, nines);

          while (min <= stop && stop <= max) {
            stops = push(stops, stop);
            nines += 1;
            stop = +countNines(min, nines);
          }

          var zeros = 1;
          stop = countZeros(max + 1, zeros) - 1;

          while (min < stop && stop <= max) {
            stops = push(stops, stop);
            zeros += 1;
            stop = countZeros(max + 1, zeros) - 1;
          }

          stops.sort(compare);
          return stops;
        }

        /**
         * Convert a range to a regex pattern
         * @param {Number} `start`
         * @param {Number} `stop`
         * @return {String}
         */

        function rangeToPattern(start, stop, options) {
          if (start === stop) {
            return { pattern: String(start), digits: [] };
          }

          var zipped = zip(String(start), String(stop));
          var len = zipped.length,
            i = -1;

          var pattern = "";
          var digits = 0;

          while (++i < len) {
            var numbers = zipped[i];
            var startDigit = numbers[0];
            var stopDigit = numbers[1];

            if (startDigit === stopDigit) {
              pattern += startDigit;
            } else if (startDigit !== "0" || stopDigit !== "9") {
              pattern += toCharacterClass(startDigit, stopDigit);
            } else {
              digits += 1;
            }
          }

          if (digits) {
            pattern += options.shorthand ? "\\d" : "[0-9]";
          }

          return { pattern: pattern, digits: [digits] };
        }

        function splitToPatterns(min, max, tok, options) {
          var ranges = splitToRanges(min, max);
          var len = ranges.length;
          var idx = -1;

          var tokens = [];
          var start = min;
          var prev;

          while (++idx < len) {
            var range = ranges[idx];
            var obj = rangeToPattern(start, range, options);
            var zeros = "";

            if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
              if (prev.digits.length > 1) {
                prev.digits.pop();
              }
              prev.digits.push(obj.digits[0]);
              prev.string = prev.pattern + toQuantifier(prev.digits);
              start = range + 1;
              continue;
            }

            if (tok.isPadded) {
              zeros = padZeros(range, tok);
            }

            obj.string = zeros + obj.pattern + toQuantifier(obj.digits);
            tokens.push(obj);
            start = range + 1;
            prev = obj;
          }

          return tokens;
        }

        function filterPatterns(
          arr,
          comparison,
          prefix,
          intersection,
          options
        ) {
          var res = [];

          for (var i = 0; i < arr.length; i++) {
            var tok = arr[i];
            var ele = tok.string;

            if (options.relaxZeros !== false) {
              if (prefix === "-" && ele.charAt(0) === "0") {
                if (ele.charAt(1) === "{") {
                  ele = "0*" + ele.replace(/^0\{\d+\}/, "");
                } else {
                  ele = "0*" + ele.slice(1);
                }
              }
            }

            if (!intersection && !contains(comparison, "string", ele)) {
              res.push(prefix + ele);
            }

            if (intersection && contains(comparison, "string", ele)) {
              res.push(prefix + ele);
            }
          }
          return res;
        }

        /**
         * Zip strings (`for in` can be used on string characters)
         */

        function zip(a, b) {
          var arr = [];
          for (var ch in a) arr.push([a[ch], b[ch]]);
          return arr;
        }

        function compare(a, b) {
          return a > b ? 1 : b > a ? -1 : 0;
        }

        function push(arr, ele) {
          if (arr.indexOf(ele) === -1) arr.push(ele);
          return arr;
        }

        function contains(arr, key, val) {
          for (var i = 0; i < arr.length; i++) {
            if (arr[i][key] === val) {
              return true;
            }
          }
          return false;
        }

        function countNines(min, len) {
          return String(min).slice(0, -len) + repeat("9", len);
        }

        function countZeros(integer, zeros) {
          return integer - (integer % Math.pow(10, zeros));
        }

        function toQuantifier(digits) {
          var start = digits[0];
          var stop = digits[1] ? "," + digits[1] : "";
          if (!stop && (!start || start === 1)) {
            return "";
          }
          return "{" + start + stop + "}";
        }

        function toCharacterClass(a, b) {
          return "[" + a + (b - a === 1 ? "" : "-") + b + "]";
        }

        function padding(str) {
          return /^-?(0+)\d/.exec(str);
        }

        function padZeros(val, tok) {
          if (tok.isPadded) {
            var diff = Math.abs(tok.maxLen - String(val).length);
            switch (diff) {
              case 0:
                return "";
              case 1:
                return "0";
              default: {
                return "0{" + diff + "}";
              }
            }
          }
          return val;
        }

        /**
         * Expose `toRegexRange`
         */

        module.exports = toRegexRange;
      },
      { "is-number": 152, "repeat-string": 190 },
    ],
    155: [
      function (require, module, exports) {
        "use strict";

        var isExtendable = require("is-extendable");
        var forIn = require("for-in");

        function mixinDeep(target, objects) {
          var len = arguments.length,
            i = 0;
          while (++i < len) {
            var obj = arguments[i];
            if (isObject(obj)) {
              forIn(obj, copy, target);
            }
          }
          return target;
        }

        /**
         * Copy properties from the source object to the
         * target object.
         *
         * @param  {*} `val`
         * @param  {String} `key`
         */

        function copy(val, key) {
          if (!isValidKey(key)) {
            return;
          }

          var obj = this[key];
          if (isObject(val) && isObject(obj)) {
            mixinDeep(obj, val);
          } else {
            this[key] = val;
          }
        }

        /**
         * Returns true if `val` is an object or function.
         *
         * @param  {any} val
         * @return {Boolean}
         */

        function isObject(val) {
          return isExtendable(val) && !Array.isArray(val);
        }

        /**
         * Returns true if `key` is a valid key to use when extending objects.
         *
         * @param  {String} `key`
         * @return {Boolean}
         */

        function isValidKey(key) {
          return (
            key !== "__proto__" && key !== "constructor" && key !== "prototype"
          );
        }

        /**
         * Expose `mixinDeep`
         */

        module.exports = mixinDeep;
      },
      { "for-in": 70, "is-extendable": 156 },
    ],
    156: [
      function (require, module, exports) {
        arguments[4][149][0].apply(exports, arguments);
      },
      { dup: 149, "is-plain-object": 126 },
    ],
    157: [
      function (require, module, exports) {
        //! moment.js
        //! version : 2.29.4
        //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
        //! license : MIT
        //! momentjs.com

        (function (global, factory) {
          typeof exports === "object" && typeof module !== "undefined"
            ? (module.exports = factory())
            : typeof define === "function" && define.amd
            ? define(factory)
            : (global.moment = factory());
        })(this, function () {
          "use strict";

          var hookCallback;

          function hooks() {
            return hookCallback.apply(null, arguments);
          }

          // This is done to register the method called with moment()
          // without creating circular dependencies.
          function setHookCallback(callback) {
            hookCallback = callback;
          }

          function isArray(input) {
            return (
              input instanceof Array ||
              Object.prototype.toString.call(input) === "[object Array]"
            );
          }

          function isObject(input) {
            // IE8 will treat undefined and null as object if it wasn't for
            // input != null
            return (
              input != null &&
              Object.prototype.toString.call(input) === "[object Object]"
            );
          }

          function hasOwnProp(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b);
          }

          function isObjectEmpty(obj) {
            if (Object.getOwnPropertyNames) {
              return Object.getOwnPropertyNames(obj).length === 0;
            } else {
              var k;
              for (k in obj) {
                if (hasOwnProp(obj, k)) {
                  return false;
                }
              }
              return true;
            }
          }

          function isUndefined(input) {
            return input === void 0;
          }

          function isNumber(input) {
            return (
              typeof input === "number" ||
              Object.prototype.toString.call(input) === "[object Number]"
            );
          }

          function isDate(input) {
            return (
              input instanceof Date ||
              Object.prototype.toString.call(input) === "[object Date]"
            );
          }

          function map(arr, fn) {
            var res = [],
              i,
              arrLen = arr.length;
            for (i = 0; i < arrLen; ++i) {
              res.push(fn(arr[i], i));
            }
            return res;
          }

          function extend(a, b) {
            for (var i in b) {
              if (hasOwnProp(b, i)) {
                a[i] = b[i];
              }
            }

            if (hasOwnProp(b, "toString")) {
              a.toString = b.toString;
            }

            if (hasOwnProp(b, "valueOf")) {
              a.valueOf = b.valueOf;
            }

            return a;
          }

          function createUTC(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, true).utc();
          }

          function defaultParsingFlags() {
            // We need to deep clone this object.
            return {
              empty: false,
              unusedTokens: [],
              unusedInput: [],
              overflow: -2,
              charsLeftOver: 0,
              nullInput: false,
              invalidEra: null,
              invalidMonth: null,
              invalidFormat: false,
              userInvalidated: false,
              iso: false,
              parsedDateParts: [],
              era: null,
              meridiem: null,
              rfc2822: false,
              weekdayMismatch: false,
            };
          }

          function getParsingFlags(m) {
            if (m._pf == null) {
              m._pf = defaultParsingFlags();
            }
            return m._pf;
          }

          var some;
          if (Array.prototype.some) {
            some = Array.prototype.some;
          } else {
            some = function (fun) {
              var t = Object(this),
                len = t.length >>> 0,
                i;

              for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                  return true;
                }
              }

              return false;
            };
          }

          function isValid(m) {
            if (m._isValid == null) {
              var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
                  return i != null;
                }),
                isNowValid =
                  !isNaN(m._d.getTime()) &&
                  flags.overflow < 0 &&
                  !flags.empty &&
                  !flags.invalidEra &&
                  !flags.invalidMonth &&
                  !flags.invalidWeekday &&
                  !flags.weekdayMismatch &&
                  !flags.nullInput &&
                  !flags.invalidFormat &&
                  !flags.userInvalidated &&
                  (!flags.meridiem || (flags.meridiem && parsedParts));

              if (m._strict) {
                isNowValid =
                  isNowValid &&
                  flags.charsLeftOver === 0 &&
                  flags.unusedTokens.length === 0 &&
                  flags.bigHour === undefined;
              }

              if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
              } else {
                return isNowValid;
              }
            }
            return m._isValid;
          }

          function createInvalid(flags) {
            var m = createUTC(NaN);
            if (flags != null) {
              extend(getParsingFlags(m), flags);
            } else {
              getParsingFlags(m).userInvalidated = true;
            }

            return m;
          }

          // Plugins that add properties should also add the key here (null value),
          // so we can properly clone ourselves.
          var momentProperties = (hooks.momentProperties = []),
            updateInProgress = false;

          function copyConfig(to, from) {
            var i,
              prop,
              val,
              momentPropertiesLen = momentProperties.length;

            if (!isUndefined(from._isAMomentObject)) {
              to._isAMomentObject = from._isAMomentObject;
            }
            if (!isUndefined(from._i)) {
              to._i = from._i;
            }
            if (!isUndefined(from._f)) {
              to._f = from._f;
            }
            if (!isUndefined(from._l)) {
              to._l = from._l;
            }
            if (!isUndefined(from._strict)) {
              to._strict = from._strict;
            }
            if (!isUndefined(from._tzm)) {
              to._tzm = from._tzm;
            }
            if (!isUndefined(from._isUTC)) {
              to._isUTC = from._isUTC;
            }
            if (!isUndefined(from._offset)) {
              to._offset = from._offset;
            }
            if (!isUndefined(from._pf)) {
              to._pf = getParsingFlags(from);
            }
            if (!isUndefined(from._locale)) {
              to._locale = from._locale;
            }

            if (momentPropertiesLen > 0) {
              for (i = 0; i < momentPropertiesLen; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                  to[prop] = val;
                }
              }
            }

            return to;
          }

          // Moment prototype object
          function Moment(config) {
            copyConfig(this, config);
            this._d = new Date(config._d != null ? config._d.getTime() : NaN);
            if (!this.isValid()) {
              this._d = new Date(NaN);
            }
            // Prevent infinite loop in case updateOffset creates new moment
            // objects.
            if (updateInProgress === false) {
              updateInProgress = true;
              hooks.updateOffset(this);
              updateInProgress = false;
            }
          }

          function isMoment(obj) {
            return (
              obj instanceof Moment ||
              (obj != null && obj._isAMomentObject != null)
            );
          }

          function warn(msg) {
            if (
              hooks.suppressDeprecationWarnings === false &&
              typeof console !== "undefined" &&
              console.warn
            ) {
              console.warn("Deprecation warning: " + msg);
            }
          }

          function deprecate(msg, fn) {
            var firstTime = true;

            return extend(function () {
              if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
              }
              if (firstTime) {
                var args = [],
                  arg,
                  i,
                  key,
                  argLen = arguments.length;
                for (i = 0; i < argLen; i++) {
                  arg = "";
                  if (typeof arguments[i] === "object") {
                    arg += "\n[" + i + "] ";
                    for (key in arguments[0]) {
                      if (hasOwnProp(arguments[0], key)) {
                        arg += key + ": " + arguments[0][key] + ", ";
                      }
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                  } else {
                    arg = arguments[i];
                  }
                  args.push(arg);
                }
                warn(
                  msg +
                    "\nArguments: " +
                    Array.prototype.slice.call(args).join("") +
                    "\n" +
                    new Error().stack
                );
                firstTime = false;
              }
              return fn.apply(this, arguments);
            }, fn);
          }

          var deprecations = {};

          function deprecateSimple(name, msg) {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(name, msg);
            }
            if (!deprecations[name]) {
              warn(msg);
              deprecations[name] = true;
            }
          }

          hooks.suppressDeprecationWarnings = false;
          hooks.deprecationHandler = null;

          function isFunction(input) {
            return (
              (typeof Function !== "undefined" && input instanceof Function) ||
              Object.prototype.toString.call(input) === "[object Function]"
            );
          }

          function set(config) {
            var prop, i;
            for (i in config) {
              if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                  this[i] = prop;
                } else {
                  this["_" + i] = prop;
                }
              }
            }
            this._config = config;
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
            // TODO: Remove "ordinalParse" fallback in next major release.
            this._dayOfMonthOrdinalParseLenient = new RegExp(
              (this._dayOfMonthOrdinalParse.source ||
                this._ordinalParse.source) +
                "|" +
                /\d{1,2}/.source
            );
          }

          function mergeConfigs(parentConfig, childConfig) {
            var res = extend({}, parentConfig),
              prop;
            for (prop in childConfig) {
              if (hasOwnProp(childConfig, prop)) {
                if (
                  isObject(parentConfig[prop]) &&
                  isObject(childConfig[prop])
                ) {
                  res[prop] = {};
                  extend(res[prop], parentConfig[prop]);
                  extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                  res[prop] = childConfig[prop];
                } else {
                  delete res[prop];
                }
              }
            }
            for (prop in parentConfig) {
              if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
              ) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
              }
            }
            return res;
          }

          function Locale(config) {
            if (config != null) {
              this.set(config);
            }
          }

          var keys;

          if (Object.keys) {
            keys = Object.keys;
          } else {
            keys = function (obj) {
              var i,
                res = [];
              for (i in obj) {
                if (hasOwnProp(obj, i)) {
                  res.push(i);
                }
              }
              return res;
            };
          }

          var defaultCalendar = {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L",
          };

          function calendar(key, mom, now) {
            var output = this._calendar[key] || this._calendar["sameElse"];
            return isFunction(output) ? output.call(mom, now) : output;
          }

          function zeroFill(number, targetLength, forceSign) {
            var absNumber = "" + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
            return (
              (sign ? (forceSign ? "+" : "") : "-") +
              Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
              absNumber
            );
          }

          var formattingTokens =
              /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
            localFormattingTokens =
              /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
            formatFunctions = {},
            formatTokenFunctions = {};

          // token:    'M'
          // padded:   ['MM', 2]
          // ordinal:  'Mo'
          // callback: function () { this.month() + 1 }
          function addFormatToken(token, padded, ordinal, callback) {
            var func = callback;
            if (typeof callback === "string") {
              func = function () {
                return this[callback]();
              };
            }
            if (token) {
              formatTokenFunctions[token] = func;
            }
            if (padded) {
              formatTokenFunctions[padded[0]] = function () {
                return zeroFill(
                  func.apply(this, arguments),
                  padded[1],
                  padded[2]
                );
              };
            }
            if (ordinal) {
              formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                  func.apply(this, arguments),
                  token
                );
              };
            }
          }

          function removeFormattingTokens(input) {
            if (input.match(/\[[\s\S]/)) {
              return input.replace(/^\[|\]$/g, "");
            }
            return input.replace(/\\/g, "");
          }

          function makeFormatFunction(format) {
            var array = format.match(formattingTokens),
              i,
              length;

            for (i = 0, length = array.length; i < length; i++) {
              if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
              } else {
                array[i] = removeFormattingTokens(array[i]);
              }
            }

            return function (mom) {
              var output = "",
                i;
              for (i = 0; i < length; i++) {
                output += isFunction(array[i])
                  ? array[i].call(mom, format)
                  : array[i];
              }
              return output;
            };
          }

          // format date using native date object
          function formatMoment(m, format) {
            if (!m.isValid()) {
              return m.localeData().invalidDate();
            }

            format = expandFormat(format, m.localeData());
            formatFunctions[format] =
              formatFunctions[format] || makeFormatFunction(format);

            return formatFunctions[format](m);
          }

          function expandFormat(format, locale) {
            var i = 5;

            function replaceLongDateFormatTokens(input) {
              return locale.longDateFormat(input) || input;
            }

            localFormattingTokens.lastIndex = 0;
            while (i >= 0 && localFormattingTokens.test(format)) {
              format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
              );
              localFormattingTokens.lastIndex = 0;
              i -= 1;
            }

            return format;
          }

          var defaultLongDateFormat = {
            LTS: "h:mm:ss A",
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY h:mm A",
            LLLL: "dddd, MMMM D, YYYY h:mm A",
          };

          function longDateFormat(key) {
            var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

            if (format || !formatUpper) {
              return format;
            }

            this._longDateFormat[key] = formatUpper
              .match(formattingTokens)
              .map(function (tok) {
                if (
                  tok === "MMMM" ||
                  tok === "MM" ||
                  tok === "DD" ||
                  tok === "dddd"
                ) {
                  return tok.slice(1);
                }
                return tok;
              })
              .join("");

            return this._longDateFormat[key];
          }

          var defaultInvalidDate = "Invalid date";

          function invalidDate() {
            return this._invalidDate;
          }

          var defaultOrdinal = "%d",
            defaultDayOfMonthOrdinalParse = /\d{1,2}/;

          function ordinal(number) {
            return this._ordinal.replace("%d", number);
          }

          var defaultRelativeTime = {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            w: "a week",
            ww: "%d weeks",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years",
          };

          function relativeTime(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return isFunction(output)
              ? output(number, withoutSuffix, string, isFuture)
              : output.replace(/%d/i, number);
          }

          function pastFuture(diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"];
            return isFunction(format)
              ? format(output)
              : format.replace(/%s/i, output);
          }

          var aliases = {};

          function addUnitAlias(unit, shorthand) {
            var lowerCase = unit.toLowerCase();
            aliases[lowerCase] =
              aliases[lowerCase + "s"] =
              aliases[shorthand] =
                unit;
          }

          function normalizeUnits(units) {
            return typeof units === "string"
              ? aliases[units] || aliases[units.toLowerCase()]
              : undefined;
          }

          function normalizeObjectUnits(inputObject) {
            var normalizedInput = {},
              normalizedProp,
              prop;

            for (prop in inputObject) {
              if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                  normalizedInput[normalizedProp] = inputObject[prop];
                }
              }
            }

            return normalizedInput;
          }

          var priorities = {};

          function addUnitPriority(unit, priority) {
            priorities[unit] = priority;
          }

          function getPrioritizedUnits(unitsObj) {
            var units = [],
              u;
            for (u in unitsObj) {
              if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
              }
            }
            units.sort(function (a, b) {
              return a.priority - b.priority;
            });
            return units;
          }

          function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
          }

          function absFloor(number) {
            if (number < 0) {
              // -0 -> 0
              return Math.ceil(number) || 0;
            } else {
              return Math.floor(number);
            }
          }

          function toInt(argumentForCoercion) {
            var coercedNumber = +argumentForCoercion,
              value = 0;

            if (coercedNumber !== 0 && isFinite(coercedNumber)) {
              value = absFloor(coercedNumber);
            }

            return value;
          }

          function makeGetSet(unit, keepTime) {
            return function (value) {
              if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
              } else {
                return get(this, unit);
              }
            };
          }

          function get(mom, unit) {
            return mom.isValid()
              ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]()
              : NaN;
          }

          function set$1(mom, unit, value) {
            if (mom.isValid() && !isNaN(value)) {
              if (
                unit === "FullYear" &&
                isLeapYear(mom.year()) &&
                mom.month() === 1 &&
                mom.date() === 29
              ) {
                value = toInt(value);
                mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
                  value,
                  mom.month(),
                  daysInMonth(value, mom.month())
                );
              } else {
                mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
              }
            }
          }

          // MOMENTS

          function stringGet(units) {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
              return this[units]();
            }
            return this;
          }

          function stringSet(units, value) {
            if (typeof units === "object") {
              units = normalizeObjectUnits(units);
              var prioritized = getPrioritizedUnits(units),
                i,
                prioritizedLen = prioritized.length;
              for (i = 0; i < prioritizedLen; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
              }
            } else {
              units = normalizeUnits(units);
              if (isFunction(this[units])) {
                return this[units](value);
              }
            }
            return this;
          }

          var match1 = /\d/, //       0 - 9
            match2 = /\d\d/, //      00 - 99
            match3 = /\d{3}/, //     000 - 999
            match4 = /\d{4}/, //    0000 - 9999
            match6 = /[+-]?\d{6}/, // -999999 - 999999
            match1to2 = /\d\d?/, //       0 - 99
            match3to4 = /\d\d\d\d?/, //     999 - 9999
            match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
            match1to3 = /\d{1,3}/, //       0 - 999
            match1to4 = /\d{1,4}/, //       0 - 9999
            match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
            matchUnsigned = /\d+/, //       0 - inf
            matchSigned = /[+-]?\d+/, //    -inf - inf
            matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
            matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
            matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
            // any word (or two) characters or numbers including two/three word month in arabic.
            // includes scottish gaelic two word and hyphenated months
            matchWord =
              /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
            regexes;

          regexes = {};

          function addRegexToken(token, regex, strictRegex) {
            regexes[token] = isFunction(regex)
              ? regex
              : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
                };
          }

          function getParseRegexForToken(token, config) {
            if (!hasOwnProp(regexes, token)) {
              return new RegExp(unescapeFormat(token));
            }

            return regexes[token](config._strict, config._locale);
          }

          // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
          function unescapeFormat(s) {
            return regexEscape(
              s
                .replace("\\", "")
                .replace(
                  /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                  function (matched, p1, p2, p3, p4) {
                    return p1 || p2 || p3 || p4;
                  }
                )
            );
          }

          function regexEscape(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
          }

          var tokens = {};

          function addParseToken(token, callback) {
            var i,
              func = callback,
              tokenLen;
            if (typeof token === "string") {
              token = [token];
            }
            if (isNumber(callback)) {
              func = function (input, array) {
                array[callback] = toInt(input);
              };
            }
            tokenLen = token.length;
            for (i = 0; i < tokenLen; i++) {
              tokens[token[i]] = func;
            }
          }

          function addWeekParseToken(token, callback) {
            addParseToken(token, function (input, array, config, token) {
              config._w = config._w || {};
              callback(input, config._w, config, token);
            });
          }

          function addTimeToArrayFromToken(token, input, config) {
            if (input != null && hasOwnProp(tokens, token)) {
              tokens[token](input, config._a, config, token);
            }
          }

          var YEAR = 0,
            MONTH = 1,
            DATE = 2,
            HOUR = 3,
            MINUTE = 4,
            SECOND = 5,
            MILLISECOND = 6,
            WEEK = 7,
            WEEKDAY = 8;

          function mod(n, x) {
            return ((n % x) + x) % x;
          }

          var indexOf;

          if (Array.prototype.indexOf) {
            indexOf = Array.prototype.indexOf;
          } else {
            indexOf = function (o) {
              // I know
              var i;
              for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                  return i;
                }
              }
              return -1;
            };
          }

          function daysInMonth(year, month) {
            if (isNaN(year) || isNaN(month)) {
              return NaN;
            }
            var modMonth = mod(month, 12);
            year += (month - modMonth) / 12;
            return modMonth === 1
              ? isLeapYear(year)
                ? 29
                : 28
              : 31 - ((modMonth % 7) % 2);
          }

          // FORMATTING

          addFormatToken("M", ["MM", 2], "Mo", function () {
            return this.month() + 1;
          });

          addFormatToken("MMM", 0, 0, function (format) {
            return this.localeData().monthsShort(this, format);
          });

          addFormatToken("MMMM", 0, 0, function (format) {
            return this.localeData().months(this, format);
          });

          // ALIASES

          addUnitAlias("month", "M");

          // PRIORITY

          addUnitPriority("month", 8);

          // PARSING

          addRegexToken("M", match1to2);
          addRegexToken("MM", match1to2, match2);
          addRegexToken("MMM", function (isStrict, locale) {
            return locale.monthsShortRegex(isStrict);
          });
          addRegexToken("MMMM", function (isStrict, locale) {
            return locale.monthsRegex(isStrict);
          });

          addParseToken(["M", "MM"], function (input, array) {
            array[MONTH] = toInt(input) - 1;
          });

          addParseToken(
            ["MMM", "MMMM"],
            function (input, array, config, token) {
              var month = config._locale.monthsParse(
                input,
                token,
                config._strict
              );
              // if we didn't find a month name, mark the date as invalid.
              if (month != null) {
                array[MONTH] = month;
              } else {
                getParsingFlags(config).invalidMonth = input;
              }
            }
          );

          // LOCALES

          var defaultLocaleMonths =
              "January_February_March_April_May_June_July_August_September_October_November_December".split(
                "_"
              ),
            defaultLocaleMonthsShort =
              "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
            defaultMonthsShortRegex = matchWord,
            defaultMonthsRegex = matchWord;

          function localeMonths(m, format) {
            if (!m) {
              return isArray(this._months)
                ? this._months
                : this._months["standalone"];
            }
            return isArray(this._months)
              ? this._months[m.month()]
              : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                    ? "format"
                    : "standalone"
                ][m.month()];
          }

          function localeMonthsShort(m, format) {
            if (!m) {
              return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort["standalone"];
            }
            return isArray(this._monthsShort)
              ? this._monthsShort[m.month()]
              : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"
                ][m.month()];
          }

          function handleStrictParse(monthName, format, strict) {
            var i,
              ii,
              mom,
              llc = monthName.toLocaleLowerCase();
            if (!this._monthsParse) {
              // this is not used
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
              for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                  mom,
                  ""
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(
                  mom,
                  ""
                ).toLocaleLowerCase();
              }
            }

            if (strict) {
              if (format === "MMM") {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
              } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
              }
            } else {
              if (format === "MMM") {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
              } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
              }
            }
          }

          function localeMonthsParse(monthName, format, strict) {
            var i, mom, regex;

            if (this._monthsParseExact) {
              return handleStrictParse.call(this, monthName, format, strict);
            }

            if (!this._monthsParse) {
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
            }

            // TODO: add sorting
            // Sorting makes sure if one month (or abbr) is a prefix of another
            // see sorting in computeMonthsParse
            for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                  "^" + this.months(mom, "").replace(".", "") + "$",
                  "i"
                );
                this._shortMonthsParse[i] = new RegExp(
                  "^" + this.monthsShort(mom, "").replace(".", "") + "$",
                  "i"
                );
              }
              if (!strict && !this._monthsParse[i]) {
                regex =
                  "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
              }
              // test the regex
              if (
                strict &&
                format === "MMMM" &&
                this._longMonthsParse[i].test(monthName)
              ) {
                return i;
              } else if (
                strict &&
                format === "MMM" &&
                this._shortMonthsParse[i].test(monthName)
              ) {
                return i;
              } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
              }
            }
          }

          // MOMENTS

          function setMonth(mom, value) {
            var dayOfMonth;

            if (!mom.isValid()) {
              // No op
              return mom;
            }

            if (typeof value === "string") {
              if (/^\d+$/.test(value)) {
                value = toInt(value);
              } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                  return mom;
                }
              }
            }

            dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
            mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](
              value,
              dayOfMonth
            );
            return mom;
          }

          function getSetMonth(value) {
            if (value != null) {
              setMonth(this, value);
              hooks.updateOffset(this, true);
              return this;
            } else {
              return get(this, "Month");
            }
          }

          function getDaysInMonth() {
            return daysInMonth(this.year(), this.month());
          }

          function monthsShortRegex(isStrict) {
            if (this._monthsParseExact) {
              if (!hasOwnProp(this, "_monthsRegex")) {
                computeMonthsParse.call(this);
              }
              if (isStrict) {
                return this._monthsShortStrictRegex;
              } else {
                return this._monthsShortRegex;
              }
            } else {
              if (!hasOwnProp(this, "_monthsShortRegex")) {
                this._monthsShortRegex = defaultMonthsShortRegex;
              }
              return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
            }
          }

          function monthsRegex(isStrict) {
            if (this._monthsParseExact) {
              if (!hasOwnProp(this, "_monthsRegex")) {
                computeMonthsParse.call(this);
              }
              if (isStrict) {
                return this._monthsStrictRegex;
              } else {
                return this._monthsRegex;
              }
            } else {
              if (!hasOwnProp(this, "_monthsRegex")) {
                this._monthsRegex = defaultMonthsRegex;
              }
              return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
            }
          }

          function computeMonthsParse() {
            function cmpLenRev(a, b) {
              return b.length - a.length;
            }

            var shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom;
            for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              shortPieces.push(this.monthsShort(mom, ""));
              longPieces.push(this.months(mom, ""));
              mixedPieces.push(this.months(mom, ""));
              mixedPieces.push(this.monthsShort(mom, ""));
            }
            // Sorting makes sure if one month (or abbr) is a prefix of another it
            // will match the longer piece.
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);
            for (i = 0; i < 12; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
            }
            for (i = 0; i < 24; i++) {
              mixedPieces[i] = regexEscape(mixedPieces[i]);
            }

            this._monthsRegex = new RegExp(
              "^(" + mixedPieces.join("|") + ")",
              "i"
            );
            this._monthsShortRegex = this._monthsRegex;
            this._monthsStrictRegex = new RegExp(
              "^(" + longPieces.join("|") + ")",
              "i"
            );
            this._monthsShortStrictRegex = new RegExp(
              "^(" + shortPieces.join("|") + ")",
              "i"
            );
          }

          // FORMATTING

          addFormatToken("Y", 0, 0, function () {
            var y = this.year();
            return y <= 9999 ? zeroFill(y, 4) : "+" + y;
          });

          addFormatToken(0, ["YY", 2], 0, function () {
            return this.year() % 100;
          });

          addFormatToken(0, ["YYYY", 4], 0, "year");
          addFormatToken(0, ["YYYYY", 5], 0, "year");
          addFormatToken(0, ["YYYYYY", 6, true], 0, "year");

          // ALIASES

          addUnitAlias("year", "y");

          // PRIORITIES

          addUnitPriority("year", 1);

          // PARSING

          addRegexToken("Y", matchSigned);
          addRegexToken("YY", match1to2, match2);
          addRegexToken("YYYY", match1to4, match4);
          addRegexToken("YYYYY", match1to6, match6);
          addRegexToken("YYYYYY", match1to6, match6);

          addParseToken(["YYYYY", "YYYYYY"], YEAR);
          addParseToken("YYYY", function (input, array) {
            array[YEAR] =
              input.length === 2
                ? hooks.parseTwoDigitYear(input)
                : toInt(input);
          });
          addParseToken("YY", function (input, array) {
            array[YEAR] = hooks.parseTwoDigitYear(input);
          });
          addParseToken("Y", function (input, array) {
            array[YEAR] = parseInt(input, 10);
          });

          // HELPERS

          function daysInYear(year) {
            return isLeapYear(year) ? 366 : 365;
          }

          // HOOKS

          hooks.parseTwoDigitYear = function (input) {
            return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
          };

          // MOMENTS

          var getSetYear = makeGetSet("FullYear", true);

          function getIsLeapYear() {
            return isLeapYear(this.year());
          }

          function createDate(y, m, d, h, M, s, ms) {
            // can't just apply() to create a date:
            // https://stackoverflow.com/q/181348
            var date;
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              date = new Date(y + 400, m, d, h, M, s, ms);
              if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
              }
            } else {
              date = new Date(y, m, d, h, M, s, ms);
            }

            return date;
          }

          function createUTCDate(y) {
            var date, args;
            // the Date.UTC function remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
              args = Array.prototype.slice.call(arguments);
              // preserve leap years using a full 400 year cycle, then reset
              args[0] = y + 400;
              date = new Date(Date.UTC.apply(null, args));
              if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
              }
            } else {
              date = new Date(Date.UTC.apply(null, arguments));
            }

            return date;
          }

          // start-of-first-week - start-of-year
          function firstWeekOffset(year, dow, doy) {
            var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
              fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
              fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

            return -fwdlw + fwd - 1;
          }

          // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
          function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
            var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear,
              resDayOfYear;

            if (dayOfYear <= 0) {
              resYear = year - 1;
              resDayOfYear = daysInYear(resYear) + dayOfYear;
            } else if (dayOfYear > daysInYear(year)) {
              resYear = year + 1;
              resDayOfYear = dayOfYear - daysInYear(year);
            } else {
              resYear = year;
              resDayOfYear = dayOfYear;
            }

            return {
              year: resYear,
              dayOfYear: resDayOfYear,
            };
          }

          function weekOfYear(mom, dow, doy) {
            var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek,
              resYear;

            if (week < 1) {
              resYear = mom.year() - 1;
              resWeek = week + weeksInYear(resYear, dow, doy);
            } else if (week > weeksInYear(mom.year(), dow, doy)) {
              resWeek = week - weeksInYear(mom.year(), dow, doy);
              resYear = mom.year() + 1;
            } else {
              resYear = mom.year();
              resWeek = week;
            }

            return {
              week: resWeek,
              year: resYear,
            };
          }

          function weeksInYear(year, dow, doy) {
            var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
            return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
          }

          // FORMATTING

          addFormatToken("w", ["ww", 2], "wo", "week");
          addFormatToken("W", ["WW", 2], "Wo", "isoWeek");

          // ALIASES

          addUnitAlias("week", "w");
          addUnitAlias("isoWeek", "W");

          // PRIORITIES

          addUnitPriority("week", 5);
          addUnitPriority("isoWeek", 5);

          // PARSING

          addRegexToken("w", match1to2);
          addRegexToken("ww", match1to2, match2);
          addRegexToken("W", match1to2);
          addRegexToken("WW", match1to2, match2);

          addWeekParseToken(
            ["w", "ww", "W", "WW"],
            function (input, week, config, token) {
              week[token.substr(0, 1)] = toInt(input);
            }
          );

          // HELPERS

          // LOCALES

          function localeWeek(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
          }

          var defaultLocaleWeek = {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
          };

          function localeFirstDayOfWeek() {
            return this._week.dow;
          }

          function localeFirstDayOfYear() {
            return this._week.doy;
          }

          // MOMENTS

          function getSetWeek(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, "d");
          }

          function getSetISOWeek(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, "d");
          }

          // FORMATTING

          addFormatToken("d", 0, "do", "day");

          addFormatToken("dd", 0, 0, function (format) {
            return this.localeData().weekdaysMin(this, format);
          });

          addFormatToken("ddd", 0, 0, function (format) {
            return this.localeData().weekdaysShort(this, format);
          });

          addFormatToken("dddd", 0, 0, function (format) {
            return this.localeData().weekdays(this, format);
          });

          addFormatToken("e", 0, 0, "weekday");
          addFormatToken("E", 0, 0, "isoWeekday");

          // ALIASES

          addUnitAlias("day", "d");
          addUnitAlias("weekday", "e");
          addUnitAlias("isoWeekday", "E");

          // PRIORITY
          addUnitPriority("day", 11);
          addUnitPriority("weekday", 11);
          addUnitPriority("isoWeekday", 11);

          // PARSING

          addRegexToken("d", match1to2);
          addRegexToken("e", match1to2);
          addRegexToken("E", match1to2);
          addRegexToken("dd", function (isStrict, locale) {
            return locale.weekdaysMinRegex(isStrict);
          });
          addRegexToken("ddd", function (isStrict, locale) {
            return locale.weekdaysShortRegex(isStrict);
          });
          addRegexToken("dddd", function (isStrict, locale) {
            return locale.weekdaysRegex(isStrict);
          });

          addWeekParseToken(
            ["dd", "ddd", "dddd"],
            function (input, week, config, token) {
              var weekday = config._locale.weekdaysParse(
                input,
                token,
                config._strict
              );
              // if we didn't get a weekday name, mark the date as invalid
              if (weekday != null) {
                week.d = weekday;
              } else {
                getParsingFlags(config).invalidWeekday = input;
              }
            }
          );

          addWeekParseToken(
            ["d", "e", "E"],
            function (input, week, config, token) {
              week[token] = toInt(input);
            }
          );

          // HELPERS

          function parseWeekday(input, locale) {
            if (typeof input !== "string") {
              return input;
            }

            if (!isNaN(input)) {
              return parseInt(input, 10);
            }

            input = locale.weekdaysParse(input);
            if (typeof input === "number") {
              return input;
            }

            return null;
          }

          function parseIsoWeekday(input, locale) {
            if (typeof input === "string") {
              return locale.weekdaysParse(input) % 7 || 7;
            }
            return isNaN(input) ? null : input;
          }

          // LOCALES
          function shiftWeekdays(ws, n) {
            return ws.slice(n, 7).concat(ws.slice(0, n));
          }

          var defaultLocaleWeekdays =
              "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
                "_"
              ),
            defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split(
              "_"
            ),
            defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            defaultWeekdaysRegex = matchWord,
            defaultWeekdaysShortRegex = matchWord,
            defaultWeekdaysMinRegex = matchWord;

          function localeWeekdays(m, format) {
            var weekdays = isArray(this._weekdays)
              ? this._weekdays
              : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                    ? "format"
                    : "standalone"
                ];
            return m === true
              ? shiftWeekdays(weekdays, this._week.dow)
              : m
              ? weekdays[m.day()]
              : weekdays;
          }

          function localeWeekdaysShort(m) {
            return m === true
              ? shiftWeekdays(this._weekdaysShort, this._week.dow)
              : m
              ? this._weekdaysShort[m.day()]
              : this._weekdaysShort;
          }

          function localeWeekdaysMin(m) {
            return m === true
              ? shiftWeekdays(this._weekdaysMin, this._week.dow)
              : m
              ? this._weekdaysMin[m.day()]
              : this._weekdaysMin;
          }

          function handleStrictParse$1(weekdayName, format, strict) {
            var i,
              ii,
              mom,
              llc = weekdayName.toLocaleLowerCase();
            if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._minWeekdaysParse = [];

              for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                  mom,
                  ""
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                  mom,
                  ""
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(
                  mom,
                  ""
                ).toLocaleLowerCase();
              }
            }

            if (strict) {
              if (format === "dddd") {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
              } else if (format === "ddd") {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
              } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
              }
            } else {
              if (format === "dddd") {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
              } else if (format === "ddd") {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
              } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                  return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
              }
            }
          }

          function localeWeekdaysParse(weekdayName, format, strict) {
            var i, mom, regex;

            if (this._weekdaysParseExact) {
              return handleStrictParse$1.call(
                this,
                weekdayName,
                format,
                strict
              );
            }

            if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._minWeekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._fullWeekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already

              mom = createUTC([2000, 1]).day(i);
              if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                  "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
                  "i"
                );
                this._shortWeekdaysParse[i] = new RegExp(
                  "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
                  "i"
                );
                this._minWeekdaysParse[i] = new RegExp(
                  "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
                  "i"
                );
              }
              if (!this._weekdaysParse[i]) {
                regex =
                  "^" +
                  this.weekdays(mom, "") +
                  "|^" +
                  this.weekdaysShort(mom, "") +
                  "|^" +
                  this.weekdaysMin(mom, "");
                this._weekdaysParse[i] = new RegExp(
                  regex.replace(".", ""),
                  "i"
                );
              }
              // test the regex
              if (
                strict &&
                format === "dddd" &&
                this._fullWeekdaysParse[i].test(weekdayName)
              ) {
                return i;
              } else if (
                strict &&
                format === "ddd" &&
                this._shortWeekdaysParse[i].test(weekdayName)
              ) {
                return i;
              } else if (
                strict &&
                format === "dd" &&
                this._minWeekdaysParse[i].test(weekdayName)
              ) {
                return i;
              } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
              }
            }
          }

          // MOMENTS

          function getSetDayOfWeek(input) {
            if (!this.isValid()) {
              return input != null ? this : NaN;
            }
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
              input = parseWeekday(input, this.localeData());
              return this.add(input - day, "d");
            } else {
              return day;
            }
          }

          function getSetLocaleDayOfWeek(input) {
            if (!this.isValid()) {
              return input != null ? this : NaN;
            }
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, "d");
          }

          function getSetISODayOfWeek(input) {
            if (!this.isValid()) {
              return input != null ? this : NaN;
            }

            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.

            if (input != null) {
              var weekday = parseIsoWeekday(input, this.localeData());
              return this.day(this.day() % 7 ? weekday : weekday - 7);
            } else {
              return this.day() || 7;
            }
          }

          function weekdaysRegex(isStrict) {
            if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, "_weekdaysRegex")) {
                computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                return this._weekdaysStrictRegex;
              } else {
                return this._weekdaysRegex;
              }
            } else {
              if (!hasOwnProp(this, "_weekdaysRegex")) {
                this._weekdaysRegex = defaultWeekdaysRegex;
              }
              return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
            }
          }

          function weekdaysShortRegex(isStrict) {
            if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, "_weekdaysRegex")) {
                computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                return this._weekdaysShortStrictRegex;
              } else {
                return this._weekdaysShortRegex;
              }
            } else {
              if (!hasOwnProp(this, "_weekdaysShortRegex")) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
              }
              return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
            }
          }

          function weekdaysMinRegex(isStrict) {
            if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, "_weekdaysRegex")) {
                computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                return this._weekdaysMinStrictRegex;
              } else {
                return this._weekdaysMinRegex;
              }
            } else {
              if (!hasOwnProp(this, "_weekdaysMinRegex")) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
              }
              return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
            }
          }

          function computeWeekdaysParse() {
            function cmpLenRev(a, b) {
              return b.length - a.length;
            }

            var minPieces = [],
              shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom,
              minp,
              shortp,
              longp;
            for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, 1]).day(i);
              minp = regexEscape(this.weekdaysMin(mom, ""));
              shortp = regexEscape(this.weekdaysShort(mom, ""));
              longp = regexEscape(this.weekdays(mom, ""));
              minPieces.push(minp);
              shortPieces.push(shortp);
              longPieces.push(longp);
              mixedPieces.push(minp);
              mixedPieces.push(shortp);
              mixedPieces.push(longp);
            }
            // Sorting makes sure if one weekday (or abbr) is a prefix of another it
            // will match the longer piece.
            minPieces.sort(cmpLenRev);
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);

            this._weekdaysRegex = new RegExp(
              "^(" + mixedPieces.join("|") + ")",
              "i"
            );
            this._weekdaysShortRegex = this._weekdaysRegex;
            this._weekdaysMinRegex = this._weekdaysRegex;

            this._weekdaysStrictRegex = new RegExp(
              "^(" + longPieces.join("|") + ")",
              "i"
            );
            this._weekdaysShortStrictRegex = new RegExp(
              "^(" + shortPieces.join("|") + ")",
              "i"
            );
            this._weekdaysMinStrictRegex = new RegExp(
              "^(" + minPieces.join("|") + ")",
              "i"
            );
          }

          // FORMATTING

          function hFormat() {
            return this.hours() % 12 || 12;
          }

          function kFormat() {
            return this.hours() || 24;
          }

          addFormatToken("H", ["HH", 2], 0, "hour");
          addFormatToken("h", ["hh", 2], 0, hFormat);
          addFormatToken("k", ["kk", 2], 0, kFormat);

          addFormatToken("hmm", 0, 0, function () {
            return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
          });

          addFormatToken("hmmss", 0, 0, function () {
            return (
              "" +
              hFormat.apply(this) +
              zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2)
            );
          });

          addFormatToken("Hmm", 0, 0, function () {
            return "" + this.hours() + zeroFill(this.minutes(), 2);
          });

          addFormatToken("Hmmss", 0, 0, function () {
            return (
              "" +
              this.hours() +
              zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2)
            );
          });

          function meridiem(token, lowercase) {
            addFormatToken(token, 0, 0, function () {
              return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
              );
            });
          }

          meridiem("a", true);
          meridiem("A", false);

          // ALIASES

          addUnitAlias("hour", "h");

          // PRIORITY
          addUnitPriority("hour", 13);

          // PARSING

          function matchMeridiem(isStrict, locale) {
            return locale._meridiemParse;
          }

          addRegexToken("a", matchMeridiem);
          addRegexToken("A", matchMeridiem);
          addRegexToken("H", match1to2);
          addRegexToken("h", match1to2);
          addRegexToken("k", match1to2);
          addRegexToken("HH", match1to2, match2);
          addRegexToken("hh", match1to2, match2);
          addRegexToken("kk", match1to2, match2);

          addRegexToken("hmm", match3to4);
          addRegexToken("hmmss", match5to6);
          addRegexToken("Hmm", match3to4);
          addRegexToken("Hmmss", match5to6);

          addParseToken(["H", "HH"], HOUR);
          addParseToken(["k", "kk"], function (input, array, config) {
            var kInput = toInt(input);
            array[HOUR] = kInput === 24 ? 0 : kInput;
          });
          addParseToken(["a", "A"], function (input, array, config) {
            config._isPm = config._locale.isPM(input);
            config._meridiem = input;
          });
          addParseToken(["h", "hh"], function (input, array, config) {
            array[HOUR] = toInt(input);
            getParsingFlags(config).bigHour = true;
          });
          addParseToken("hmm", function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
            getParsingFlags(config).bigHour = true;
          });
          addParseToken("hmmss", function (input, array, config) {
            var pos1 = input.length - 4,
              pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
            getParsingFlags(config).bigHour = true;
          });
          addParseToken("Hmm", function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
          });
          addParseToken("Hmmss", function (input, array, config) {
            var pos1 = input.length - 4,
              pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
          });

          // LOCALES

          function localeIsPM(input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return (input + "").toLowerCase().charAt(0) === "p";
          }

          var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
            // Setting the hour should keep the time, because the user explicitly
            // specified which hour they want. So trying to maintain the same hour (in
            // a new timezone) makes sense. Adding/subtracting hours does not follow
            // this rule.
            getSetHour = makeGetSet("Hours", true);

          function localeMeridiem(hours, minutes, isLower) {
            if (hours > 11) {
              return isLower ? "pm" : "PM";
            } else {
              return isLower ? "am" : "AM";
            }
          }

          var baseConfig = {
            calendar: defaultCalendar,
            longDateFormat: defaultLongDateFormat,
            invalidDate: defaultInvalidDate,
            ordinal: defaultOrdinal,
            dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
            relativeTime: defaultRelativeTime,

            months: defaultLocaleMonths,
            monthsShort: defaultLocaleMonthsShort,

            week: defaultLocaleWeek,

            weekdays: defaultLocaleWeekdays,
            weekdaysMin: defaultLocaleWeekdaysMin,
            weekdaysShort: defaultLocaleWeekdaysShort,

            meridiemParse: defaultLocaleMeridiemParse,
          };

          // internal storage for locale config files
          var locales = {},
            localeFamilies = {},
            globalLocale;

          function commonPrefix(arr1, arr2) {
            var i,
              minl = Math.min(arr1.length, arr2.length);
            for (i = 0; i < minl; i += 1) {
              if (arr1[i] !== arr2[i]) {
                return i;
              }
            }
            return minl;
          }

          function normalizeLocale(key) {
            return key ? key.toLowerCase().replace("_", "-") : key;
          }

          // pick the locale from the array
          // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
          // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
          function chooseLocale(names) {
            var i = 0,
              j,
              next,
              locale,
              split;

            while (i < names.length) {
              split = normalizeLocale(names[i]).split("-");
              j = split.length;
              next = normalizeLocale(names[i + 1]);
              next = next ? next.split("-") : null;
              while (j > 0) {
                locale = loadLocale(split.slice(0, j).join("-"));
                if (locale) {
                  return locale;
                }
                if (
                  next &&
                  next.length >= j &&
                  commonPrefix(split, next) >= j - 1
                ) {
                  //the next array item is better than a shallower substring of this one
                  break;
                }
                j--;
              }
              i++;
            }
            return globalLocale;
          }

          function isLocaleNameSane(name) {
            // Prevent names that look like filesystem paths, i.e contain '/' or '\'
            return name.match("^[^/\\\\]*$") != null;
          }

          function loadLocale(name) {
            var oldLocale = null,
              aliasedRequire;
            // TODO: Find a better way to register and load all the locales in Node
            if (
              locales[name] === undefined &&
              typeof module !== "undefined" &&
              module &&
              module.exports &&
              isLocaleNameSane(name)
            ) {
              try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = require;
                aliasedRequire("./locale/" + name);
                getSetGlobalLocale(oldLocale);
              } catch (e) {
                // mark as not found to avoid repeating expensive file require call causing high CPU
                // when trying to find en-US, en_US, en-us for every format call
                locales[name] = null; // null means not found
              }
            }
            return locales[name];
          }

          // This function will load locale and then set the global locale.  If
          // no arguments are passed in, it will simply return the current global
          // locale key.
          function getSetGlobalLocale(key, values) {
            var data;
            if (key) {
              if (isUndefined(values)) {
                data = getLocale(key);
              } else {
                data = defineLocale(key, values);
              }

              if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
              } else {
                if (typeof console !== "undefined" && console.warn) {
                  //warn user if arguments are passed but the locale could not be set
                  console.warn(
                    "Locale " + key + " not found. Did you forget to load it?"
                  );
                }
              }
            }

            return globalLocale._abbr;
          }

          function defineLocale(name, config) {
            if (config !== null) {
              var locale,
                parentConfig = baseConfig;
              config.abbr = name;
              if (locales[name] != null) {
                deprecateSimple(
                  "defineLocaleOverride",
                  "use moment.updateLocale(localeName, config) to change " +
                    "an existing locale. moment.defineLocale(localeName, " +
                    "config) should only be used for creating a new locale " +
                    "See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
                );
                parentConfig = locales[name]._config;
              } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                  parentConfig = locales[config.parentLocale]._config;
                } else {
                  locale = loadLocale(config.parentLocale);
                  if (locale != null) {
                    parentConfig = locale._config;
                  } else {
                    if (!localeFamilies[config.parentLocale]) {
                      localeFamilies[config.parentLocale] = [];
                    }
                    localeFamilies[config.parentLocale].push({
                      name: name,
                      config: config,
                    });
                    return null;
                  }
                }
              }
              locales[name] = new Locale(mergeConfigs(parentConfig, config));

              if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                  defineLocale(x.name, x.config);
                });
              }

              // backwards compat for now: also set the locale
              // make sure we set the locale AFTER all child locales have been
              // created, so we won't end up with the child locale set.
              getSetGlobalLocale(name);

              return locales[name];
            } else {
              // useful for testing
              delete locales[name];
              return null;
            }
          }

          function updateLocale(name, config) {
            if (config != null) {
              var locale,
                tmpLocale,
                parentConfig = baseConfig;

              if (locales[name] != null && locales[name].parentLocale != null) {
                // Update existing child locale in-place to avoid memory-leaks
                locales[name].set(mergeConfigs(locales[name]._config, config));
              } else {
                // MERGE
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                  parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                  // updateLocale is called for creating a new locale
                  // Set abbr so it will have a name (getters return
                  // undefined otherwise).
                  config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
              }

              // backwards compat for now: also set the locale
              getSetGlobalLocale(name);
            } else {
              // pass null for config to unupdate, useful for tests
              if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                  locales[name] = locales[name].parentLocale;
                  if (name === getSetGlobalLocale()) {
                    getSetGlobalLocale(name);
                  }
                } else if (locales[name] != null) {
                  delete locales[name];
                }
              }
            }
            return locales[name];
          }

          // returns locale data
          function getLocale(key) {
            var locale;

            if (key && key._locale && key._locale._abbr) {
              key = key._locale._abbr;
            }

            if (!key) {
              return globalLocale;
            }

            if (!isArray(key)) {
              //short-circuit everything else
              locale = loadLocale(key);
              if (locale) {
                return locale;
              }
              key = [key];
            }

            return chooseLocale(key);
          }

          function listLocales() {
            return keys(locales);
          }

          function checkOverflow(m) {
            var overflow,
              a = m._a;

            if (a && getParsingFlags(m).overflow === -2) {
              overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                  ? MONTH
                  : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                  ? DATE
                  : a[HOUR] < 0 ||
                    a[HOUR] > 24 ||
                    (a[HOUR] === 24 &&
                      (a[MINUTE] !== 0 ||
                        a[SECOND] !== 0 ||
                        a[MILLISECOND] !== 0))
                  ? HOUR
                  : a[MINUTE] < 0 || a[MINUTE] > 59
                  ? MINUTE
                  : a[SECOND] < 0 || a[SECOND] > 59
                  ? SECOND
                  : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                  ? MILLISECOND
                  : -1;

              if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
              ) {
                overflow = DATE;
              }
              if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
              }
              if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
              }

              getParsingFlags(m).overflow = overflow;
            }

            return m;
          }

          // iso 8601 regex
          // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
          var extendedIsoRegex =
              /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            basicIsoRegex =
              /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
            isoDates = [
              ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
              ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
              ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
              ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
              ["YYYY-DDD", /\d{4}-\d{3}/],
              ["YYYY-MM", /\d{4}-\d\d/, false],
              ["YYYYYYMMDD", /[+-]\d{10}/],
              ["YYYYMMDD", /\d{8}/],
              ["GGGG[W]WWE", /\d{4}W\d{3}/],
              ["GGGG[W]WW", /\d{4}W\d{2}/, false],
              ["YYYYDDD", /\d{7}/],
              ["YYYYMM", /\d{6}/, false],
              ["YYYY", /\d{4}/, false],
            ],
            // iso time formats and regexes
            isoTimes = [
              ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
              ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
              ["HH:mm:ss", /\d\d:\d\d:\d\d/],
              ["HH:mm", /\d\d:\d\d/],
              ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
              ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
              ["HHmmss", /\d\d\d\d\d\d/],
              ["HHmm", /\d\d\d\d/],
              ["HH", /\d\d/],
            ],
            aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
            // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
            rfc2822 =
              /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
            obsOffsets = {
              UT: 0,
              GMT: 0,
              EDT: -4 * 60,
              EST: -5 * 60,
              CDT: -5 * 60,
              CST: -6 * 60,
              MDT: -6 * 60,
              MST: -7 * 60,
              PDT: -7 * 60,
              PST: -8 * 60,
            };

          // date from iso format
          function configFromISO(config) {
            var i,
              l,
              string = config._i,
              match =
                extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime,
              dateFormat,
              timeFormat,
              tzFormat,
              isoDatesLen = isoDates.length,
              isoTimesLen = isoTimes.length;

            if (match) {
              getParsingFlags(config).iso = true;
              for (i = 0, l = isoDatesLen; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                  dateFormat = isoDates[i][0];
                  allowTime = isoDates[i][2] !== false;
                  break;
                }
              }
              if (dateFormat == null) {
                config._isValid = false;
                return;
              }
              if (match[3]) {
                for (i = 0, l = isoTimesLen; i < l; i++) {
                  if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || " ") + isoTimes[i][0];
                    break;
                  }
                }
                if (timeFormat == null) {
                  config._isValid = false;
                  return;
                }
              }
              if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
              }
              if (match[4]) {
                if (tzRegex.exec(match[4])) {
                  tzFormat = "Z";
                } else {
                  config._isValid = false;
                  return;
                }
              }
              config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
              configFromStringAndFormat(config);
            } else {
              config._isValid = false;
            }
          }

          function extractFromRFC2822Strings(
            yearStr,
            monthStr,
            dayStr,
            hourStr,
            minuteStr,
            secondStr
          ) {
            var result = [
              untruncateYear(yearStr),
              defaultLocaleMonthsShort.indexOf(monthStr),
              parseInt(dayStr, 10),
              parseInt(hourStr, 10),
              parseInt(minuteStr, 10),
            ];

            if (secondStr) {
              result.push(parseInt(secondStr, 10));
            }

            return result;
          }

          function untruncateYear(yearStr) {
            var year = parseInt(yearStr, 10);
            if (year <= 49) {
              return 2000 + year;
            } else if (year <= 999) {
              return 1900 + year;
            }
            return year;
          }

          function preprocessRFC2822(s) {
            // Remove comments and folding whitespace and replace multiple-spaces with a single space
            return s
              .replace(/\([^()]*\)|[\n\t]/g, " ")
              .replace(/(\s\s+)/g, " ")
              .replace(/^\s\s*/, "")
              .replace(/\s\s*$/, "");
          }

          function checkWeekday(weekdayStr, parsedInput, config) {
            if (weekdayStr) {
              // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
              var weekdayProvided =
                  defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                  parsedInput[0],
                  parsedInput[1],
                  parsedInput[2]
                ).getDay();
              if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
              }
            }
            return true;
          }

          function calculateOffset(obsOffset, militaryOffset, numOffset) {
            if (obsOffset) {
              return obsOffsets[obsOffset];
            } else if (militaryOffset) {
              // the only allowed military tz is Z
              return 0;
            } else {
              var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
              return h * 60 + m;
            }
          }

          // date and time from ref 2822 format
          function configFromRFC2822(config) {
            var match = rfc2822.exec(preprocessRFC2822(config._i)),
              parsedArray;
            if (match) {
              parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
              );
              if (!checkWeekday(match[1], parsedArray, config)) {
                return;
              }

              config._a = parsedArray;
              config._tzm = calculateOffset(match[8], match[9], match[10]);

              config._d = createUTCDate.apply(null, config._a);
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

              getParsingFlags(config).rfc2822 = true;
            } else {
              config._isValid = false;
            }
          }

          // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
          function configFromString(config) {
            var matched = aspNetJsonRegex.exec(config._i);
            if (matched !== null) {
              config._d = new Date(+matched[1]);
              return;
            }

            configFromISO(config);
            if (config._isValid === false) {
              delete config._isValid;
            } else {
              return;
            }

            configFromRFC2822(config);
            if (config._isValid === false) {
              delete config._isValid;
            } else {
              return;
            }

            if (config._strict) {
              config._isValid = false;
            } else {
              // Final attempt, use Input Fallback
              hooks.createFromInputFallback(config);
            }
          }

          hooks.createFromInputFallback = deprecate(
            "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), " +
              "which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are " +
              "discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
            function (config) {
              config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
            }
          );

          // Pick the first defined of two or three arguments.
          function defaults(a, b, c) {
            if (a != null) {
              return a;
            }
            if (b != null) {
              return b;
            }
            return c;
          }

          function currentDateArray(config) {
            // hooks is actually the exported moment object
            var nowValue = new Date(hooks.now());
            if (config._useUTC) {
              return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
              ];
            }
            return [
              nowValue.getFullYear(),
              nowValue.getMonth(),
              nowValue.getDate(),
            ];
          }

          // convert an array to a date.
          // the array should mirror the parameters below
          // note: all values past the year are optional and will default to the lowest possible value.
          // [year, month, day , hour, minute, second, millisecond]
          function configFromArray(config) {
            var i,
              date,
              input = [],
              currentDate,
              expectedWeekday,
              yearToUse;

            if (config._d) {
              return;
            }

            currentDate = currentDateArray(config);

            //compute day of the year from weeks and weekdays
            if (
              config._w &&
              config._a[DATE] == null &&
              config._a[MONTH] == null
            ) {
              dayOfYearFromWeekInfo(config);
            }

            //if the day of the year is set, figure out what it is
            if (config._dayOfYear != null) {
              yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

              if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
              ) {
                getParsingFlags(config)._overflowDayOfYear = true;
              }

              date = createUTCDate(yearToUse, 0, config._dayOfYear);
              config._a[MONTH] = date.getUTCMonth();
              config._a[DATE] = date.getUTCDate();
            }

            // Default to current date.
            // * if no year, month, day of month are given, default to today
            // * if day of month is given, default month and year
            // * if month is given, default only year
            // * if year is given, don't default anything
            for (i = 0; i < 3 && config._a[i] == null; ++i) {
              config._a[i] = input[i] = currentDate[i];
            }

            // Zero out whatever was not defaulted, including time
            for (; i < 7; i++) {
              config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
            }

            // Check for 24:00:00.000
            if (
              config._a[HOUR] === 24 &&
              config._a[MINUTE] === 0 &&
              config._a[SECOND] === 0 &&
              config._a[MILLISECOND] === 0
            ) {
              config._nextDay = true;
              config._a[HOUR] = 0;
            }

            config._d = (config._useUTC ? createUTCDate : createDate).apply(
              null,
              input
            );
            expectedWeekday = config._useUTC
              ? config._d.getUTCDay()
              : config._d.getDay();

            // Apply timezone offset from input. The actual utcOffset can be changed
            // with parseZone.
            if (config._tzm != null) {
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            }

            if (config._nextDay) {
              config._a[HOUR] = 24;
            }

            // check for mismatching day of week
            if (
              config._w &&
              typeof config._w.d !== "undefined" &&
              config._w.d !== expectedWeekday
            ) {
              getParsingFlags(config).weekdayMismatch = true;
            }
          }

          function dayOfYearFromWeekInfo(config) {
            var w,
              weekYear,
              week,
              weekday,
              dow,
              doy,
              temp,
              weekdayOverflow,
              curWeek;

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
              dow = 1;
              doy = 4;

              // TODO: We need to take the current isoWeekYear, but that depends on
              // how we interpret now (local, utc, fixed offset). So create
              // a now version of current config (take local/utc/offset flags, and
              // create now).
              weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
              );
              week = defaults(w.W, 1);
              weekday = defaults(w.E, 1);
              if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
              }
            } else {
              dow = config._locale._week.dow;
              doy = config._locale._week.doy;

              curWeek = weekOfYear(createLocal(), dow, doy);

              weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

              // Default to current week.
              week = defaults(w.w, curWeek.week);

              if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                  weekdayOverflow = true;
                }
              } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                  weekdayOverflow = true;
                }
              } else {
                // default to beginning of week
                weekday = dow;
              }
            }
            if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
              getParsingFlags(config)._overflowWeeks = true;
            } else if (weekdayOverflow != null) {
              getParsingFlags(config)._overflowWeekday = true;
            } else {
              temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
              config._a[YEAR] = temp.year;
              config._dayOfYear = temp.dayOfYear;
            }
          }

          // constant that refers to the ISO standard
          hooks.ISO_8601 = function () {};

          // constant that refers to the RFC 2822 form
          hooks.RFC_2822 = function () {};

          // date from string and format string
          function configFromStringAndFormat(config) {
            // TODO: Move this to another part of the creation flow to prevent circular deps
            if (config._f === hooks.ISO_8601) {
              configFromISO(config);
              return;
            }
            if (config._f === hooks.RFC_2822) {
              configFromRFC2822(config);
              return;
            }
            config._a = [];
            getParsingFlags(config).empty = true;

            // This array is used to make a Date, either with `new Date` or `Date.UTC`
            var string = "" + config._i,
              i,
              parsedInput,
              tokens,
              token,
              skipped,
              stringLength = string.length,
              totalParsedInputLength = 0,
              era,
              tokenLen;

            tokens =
              expandFormat(config._f, config._locale).match(formattingTokens) ||
              [];
            tokenLen = tokens.length;
            for (i = 0; i < tokenLen; i++) {
              token = tokens[i];
              parsedInput = (string.match(
                getParseRegexForToken(token, config)
              ) || [])[0];
              if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                  getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                  string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
              }
              // don't parse if it's not a known token
              if (formatTokenFunctions[token]) {
                if (parsedInput) {
                  getParsingFlags(config).empty = false;
                } else {
                  getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
              } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
              }
            }

            // add remaining unparsed input length to the string
            getParsingFlags(config).charsLeftOver =
              stringLength - totalParsedInputLength;
            if (string.length > 0) {
              getParsingFlags(config).unusedInput.push(string);
            }

            // clear _12h flag if hour is <= 12
            if (
              config._a[HOUR] <= 12 &&
              getParsingFlags(config).bigHour === true &&
              config._a[HOUR] > 0
            ) {
              getParsingFlags(config).bigHour = undefined;
            }

            getParsingFlags(config).parsedDateParts = config._a.slice(0);
            getParsingFlags(config).meridiem = config._meridiem;
            // handle meridiem
            config._a[HOUR] = meridiemFixWrap(
              config._locale,
              config._a[HOUR],
              config._meridiem
            );

            // handle era
            era = getParsingFlags(config).era;
            if (era !== null) {
              config._a[YEAR] = config._locale.erasConvertYear(
                era,
                config._a[YEAR]
              );
            }

            configFromArray(config);
            checkOverflow(config);
          }

          function meridiemFixWrap(locale, hour, meridiem) {
            var isPm;

            if (meridiem == null) {
              // nothing to do
              return hour;
            }
            if (locale.meridiemHour != null) {
              return locale.meridiemHour(hour, meridiem);
            } else if (locale.isPM != null) {
              // Fallback
              isPm = locale.isPM(meridiem);
              if (isPm && hour < 12) {
                hour += 12;
              }
              if (!isPm && hour === 12) {
                hour = 0;
              }
              return hour;
            } else {
              // this is not supposed to happen
              return hour;
            }
          }

          // date from string and array of format strings
          function configFromStringAndArray(config) {
            var tempConfig,
              bestMoment,
              scoreToBeat,
              i,
              currentScore,
              validFormatFound,
              bestFormatIsValid = false,
              configfLen = config._f.length;

            if (configfLen === 0) {
              getParsingFlags(config).invalidFormat = true;
              config._d = new Date(NaN);
              return;
            }

            for (i = 0; i < configfLen; i++) {
              currentScore = 0;
              validFormatFound = false;
              tempConfig = copyConfig({}, config);
              if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
              }
              tempConfig._f = config._f[i];
              configFromStringAndFormat(tempConfig);

              if (isValid(tempConfig)) {
                validFormatFound = true;
              }

              // if there is any input that was not parsed add a penalty for that format
              currentScore += getParsingFlags(tempConfig).charsLeftOver;

              //or tokens
              currentScore +=
                getParsingFlags(tempConfig).unusedTokens.length * 10;

              getParsingFlags(tempConfig).score = currentScore;

              if (!bestFormatIsValid) {
                if (
                  scoreToBeat == null ||
                  currentScore < scoreToBeat ||
                  validFormatFound
                ) {
                  scoreToBeat = currentScore;
                  bestMoment = tempConfig;
                  if (validFormatFound) {
                    bestFormatIsValid = true;
                  }
                }
              } else {
                if (currentScore < scoreToBeat) {
                  scoreToBeat = currentScore;
                  bestMoment = tempConfig;
                }
              }
            }

            extend(config, bestMoment || tempConfig);
          }

          function configFromObject(config) {
            if (config._d) {
              return;
            }

            var i = normalizeObjectUnits(config._i),
              dayOrDate = i.day === undefined ? i.date : i.day;
            config._a = map(
              [
                i.year,
                i.month,
                dayOrDate,
                i.hour,
                i.minute,
                i.second,
                i.millisecond,
              ],
              function (obj) {
                return obj && parseInt(obj, 10);
              }
            );

            configFromArray(config);
          }

          function createFromConfig(config) {
            var res = new Moment(checkOverflow(prepareConfig(config)));
            if (res._nextDay) {
              // Adding is smart enough around DST
              res.add(1, "d");
              res._nextDay = undefined;
            }

            return res;
          }

          function prepareConfig(config) {
            var input = config._i,
              format = config._f;

            config._locale = config._locale || getLocale(config._l);

            if (input === null || (format === undefined && input === "")) {
              return createInvalid({ nullInput: true });
            }

            if (typeof input === "string") {
              config._i = input = config._locale.preparse(input);
            }

            if (isMoment(input)) {
              return new Moment(checkOverflow(input));
            } else if (isDate(input)) {
              config._d = input;
            } else if (isArray(format)) {
              configFromStringAndArray(config);
            } else if (format) {
              configFromStringAndFormat(config);
            } else {
              configFromInput(config);
            }

            if (!isValid(config)) {
              config._d = null;
            }

            return config;
          }

          function configFromInput(config) {
            var input = config._i;
            if (isUndefined(input)) {
              config._d = new Date(hooks.now());
            } else if (isDate(input)) {
              config._d = new Date(input.valueOf());
            } else if (typeof input === "string") {
              configFromString(config);
            } else if (isArray(input)) {
              config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
              });
              configFromArray(config);
            } else if (isObject(input)) {
              configFromObject(config);
            } else if (isNumber(input)) {
              // from milliseconds
              config._d = new Date(input);
            } else {
              hooks.createFromInputFallback(config);
            }
          }

          function createLocalOrUTC(input, format, locale, strict, isUTC) {
            var c = {};

            if (format === true || format === false) {
              strict = format;
              format = undefined;
            }

            if (locale === true || locale === false) {
              strict = locale;
              locale = undefined;
            }

            if (
              (isObject(input) && isObjectEmpty(input)) ||
              (isArray(input) && input.length === 0)
            ) {
              input = undefined;
            }
            // object construction must be done this way.
            // https://github.com/moment/moment/issues/1423
            c._isAMomentObject = true;
            c._useUTC = c._isUTC = isUTC;
            c._l = locale;
            c._i = input;
            c._f = format;
            c._strict = strict;

            return createFromConfig(c);
          }

          function createLocal(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, false);
          }

          var prototypeMin = deprecate(
              "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
              function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                  return other < this ? this : other;
                } else {
                  return createInvalid();
                }
              }
            ),
            prototypeMax = deprecate(
              "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
              function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                  return other > this ? this : other;
                } else {
                  return createInvalid();
                }
              }
            );

          // Pick a moment m from moments so that m[fn](other) is true for all
          // other. This relies on the function fn to be transitive.
          //
          // moments should either be an array of moment objects or an array, whose
          // first element is an array of moment objects.
          function pickBy(fn, moments) {
            var res, i;
            if (moments.length === 1 && isArray(moments[0])) {
              moments = moments[0];
            }
            if (!moments.length) {
              return createLocal();
            }
            res = moments[0];
            for (i = 1; i < moments.length; ++i) {
              if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
              }
            }
            return res;
          }

          // TODO: Use [].sort instead?
          function min() {
            var args = [].slice.call(arguments, 0);

            return pickBy("isBefore", args);
          }

          function max() {
            var args = [].slice.call(arguments, 0);

            return pickBy("isAfter", args);
          }

          var now = function () {
            return Date.now ? Date.now() : +new Date();
          };

          var ordering = [
            "year",
            "quarter",
            "month",
            "week",
            "day",
            "hour",
            "minute",
            "second",
            "millisecond",
          ];

          function isDurationValid(m) {
            var key,
              unitHasDecimal = false,
              i,
              orderLen = ordering.length;
            for (key in m) {
              if (
                hasOwnProp(m, key) &&
                !(
                  indexOf.call(ordering, key) !== -1 &&
                  (m[key] == null || !isNaN(m[key]))
                )
              ) {
                return false;
              }
            }

            for (i = 0; i < orderLen; ++i) {
              if (m[ordering[i]]) {
                if (unitHasDecimal) {
                  return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                  unitHasDecimal = true;
                }
              }
            }

            return true;
          }

          function isValid$1() {
            return this._isValid;
          }

          function createInvalid$1() {
            return createDuration(NaN);
          }

          function Duration(duration) {
            var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;

            this._isValid = isDurationValid(normalizedInput);

            // representation for dateAddRemove
            this._milliseconds =
              +milliseconds +
              seconds * 1e3 + // 1000
              minutes * 6e4 + // 1000 * 60
              hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
            // Because of dateAddRemove treats 24 hours as different from a
            // day when working around DST, we need to store them separately
            this._days = +days + weeks * 7;
            // It is impossible to translate months into days without knowing
            // which months you are are talking about, so we have to store
            // it separately.
            this._months = +months + quarters * 3 + years * 12;

            this._data = {};

            this._locale = getLocale();

            this._bubble();
          }

          function isDuration(obj) {
            return obj instanceof Duration;
          }

          function absRound(number) {
            if (number < 0) {
              return Math.round(-1 * number) * -1;
            } else {
              return Math.round(number);
            }
          }

          // compare two arrays, return the number of differences
          function compareArrays(array1, array2, dontConvert) {
            var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;
            for (i = 0; i < len; i++) {
              if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
              ) {
                diffs++;
              }
            }
            return diffs + lengthDiff;
          }

          // FORMATTING

          function offset(token, separator) {
            addFormatToken(token, 0, 0, function () {
              var offset = this.utcOffset(),
                sign = "+";
              if (offset < 0) {
                offset = -offset;
                sign = "-";
              }
              return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
              );
            });
          }

          offset("Z", ":");
          offset("ZZ", "");

          // PARSING

          addRegexToken("Z", matchShortOffset);
          addRegexToken("ZZ", matchShortOffset);
          addParseToken(["Z", "ZZ"], function (input, array, config) {
            config._useUTC = true;
            config._tzm = offsetFromString(matchShortOffset, input);
          });

          // HELPERS

          // timezone chunker
          // '+10:00' > ['10',  '00']
          // '-1530'  > ['-15', '30']
          var chunkOffset = /([\+\-]|\d\d)/gi;

          function offsetFromString(matcher, string) {
            var matches = (string || "").match(matcher),
              chunk,
              parts,
              minutes;

            if (matches === null) {
              return null;
            }

            chunk = matches[matches.length - 1] || [];
            parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
            minutes = +(parts[1] * 60) + toInt(parts[2]);

            return minutes === 0 ? 0 : parts[0] === "+" ? minutes : -minutes;
          }

          // Return a moment from input, that is local/utc/zone equivalent to model.
          function cloneWithOffset(input, model) {
            var res, diff;
            if (model._isUTC) {
              res = model.clone();
              diff =
                (isMoment(input) || isDate(input)
                  ? input.valueOf()
                  : createLocal(input).valueOf()) - res.valueOf();
              // Use low-level api, because this fn is low-level api.
              res._d.setTime(res._d.valueOf() + diff);
              hooks.updateOffset(res, false);
              return res;
            } else {
              return createLocal(input).local();
            }
          }

          function getDateOffset(m) {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return -Math.round(m._d.getTimezoneOffset());
          }

          // HOOKS

          // This function will be called whenever a moment is mutated.
          // It is intended to keep the offset in sync with the timezone.
          hooks.updateOffset = function () {};

          // MOMENTS

          // keepLocalTime = true means only change the timezone, without
          // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
          // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
          // +0200, so we adjust the time as needed, to be valid.
          //
          // Keeping the time actually adds/subtracts (one hour)
          // from the actual represented time. That is why we call updateOffset
          // a second time. In case it wants us to change the offset again
          // _changeInProgress == true case, then we have to adjust, because
          // there is no such time in the given timezone.
          function getSetOffset(input, keepLocalTime, keepMinutes) {
            var offset = this._offset || 0,
              localAdjust;
            if (!this.isValid()) {
              return input != null ? this : NaN;
            }
            if (input != null) {
              if (typeof input === "string") {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                  return this;
                }
              } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
              }
              if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
              }
              this._offset = input;
              this._isUTC = true;
              if (localAdjust != null) {
                this.add(localAdjust, "m");
              }
              if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                  addSubtract(
                    this,
                    createDuration(input - offset, "m"),
                    1,
                    false
                  );
                } else if (!this._changeInProgress) {
                  this._changeInProgress = true;
                  hooks.updateOffset(this, true);
                  this._changeInProgress = null;
                }
              }
              return this;
            } else {
              return this._isUTC ? offset : getDateOffset(this);
            }
          }

          function getSetZone(input, keepLocalTime) {
            if (input != null) {
              if (typeof input !== "string") {
                input = -input;
              }

              this.utcOffset(input, keepLocalTime);

              return this;
            } else {
              return -this.utcOffset();
            }
          }

          function setOffsetToUTC(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
          }

          function setOffsetToLocal(keepLocalTime) {
            if (this._isUTC) {
              this.utcOffset(0, keepLocalTime);
              this._isUTC = false;

              if (keepLocalTime) {
                this.subtract(getDateOffset(this), "m");
              }
            }
            return this;
          }

          function setOffsetToParsedOffset() {
            if (this._tzm != null) {
              this.utcOffset(this._tzm, false, true);
            } else if (typeof this._i === "string") {
              var tZone = offsetFromString(matchOffset, this._i);
              if (tZone != null) {
                this.utcOffset(tZone);
              } else {
                this.utcOffset(0, true);
              }
            }
            return this;
          }

          function hasAlignedHourOffset(input) {
            if (!this.isValid()) {
              return false;
            }
            input = input ? createLocal(input).utcOffset() : 0;

            return (this.utcOffset() - input) % 60 === 0;
          }

          function isDaylightSavingTime() {
            return (
              this.utcOffset() > this.clone().month(0).utcOffset() ||
              this.utcOffset() > this.clone().month(5).utcOffset()
            );
          }

          function isDaylightSavingTimeShifted() {
            if (!isUndefined(this._isDSTShifted)) {
              return this._isDSTShifted;
            }

            var c = {},
              other;

            copyConfig(c, this);
            c = prepareConfig(c);

            if (c._a) {
              other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
              this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
            } else {
              this._isDSTShifted = false;
            }

            return this._isDSTShifted;
          }

          function isLocal() {
            return this.isValid() ? !this._isUTC : false;
          }

          function isUtcOffset() {
            return this.isValid() ? this._isUTC : false;
          }

          function isUtc() {
            return this.isValid() ? this._isUTC && this._offset === 0 : false;
          }

          // ASP.NET json date format regex
          var aspNetRegex =
              /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
            // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
            // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
            // and further modified to allow for strings containing both week and day
            isoRegex =
              /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

          function createDuration(input, key) {
            var duration = input,
              // matching against regexp is expensive, do it on demand
              match = null,
              sign,
              ret,
              diffRes;

            if (isDuration(input)) {
              duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
              };
            } else if (isNumber(input) || !isNaN(+input)) {
              duration = {};
              if (key) {
                duration[key] = +input;
              } else {
                duration.milliseconds = +input;
              }
            } else if ((match = aspNetRegex.exec(input))) {
              sign = match[1] === "-" ? -1 : 1;
              duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
              };
            } else if ((match = isoRegex.exec(input))) {
              sign = match[1] === "-" ? -1 : 1;
              duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
              };
            } else if (duration == null) {
              // checks for null or undefined
              duration = {};
            } else if (
              typeof duration === "object" &&
              ("from" in duration || "to" in duration)
            ) {
              diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
              );

              duration = {};
              duration.ms = diffRes.milliseconds;
              duration.M = diffRes.months;
            }

            ret = new Duration(duration);

            if (isDuration(input) && hasOwnProp(input, "_locale")) {
              ret._locale = input._locale;
            }

            if (isDuration(input) && hasOwnProp(input, "_isValid")) {
              ret._isValid = input._isValid;
            }

            return ret;
          }

          createDuration.fn = Duration.prototype;
          createDuration.invalid = createInvalid$1;

          function parseIso(inp, sign) {
            // We'd normally use ~~inp for this, but unfortunately it also
            // converts floats to ints.
            // inp may be undefined, so careful calling replace on it.
            var res = inp && parseFloat(inp.replace(",", "."));
            // apply sign while we're at it
            return (isNaN(res) ? 0 : res) * sign;
          }

          function positiveMomentsDifference(base, other) {
            var res = {};

            res.months =
              other.month() - base.month() + (other.year() - base.year()) * 12;
            if (base.clone().add(res.months, "M").isAfter(other)) {
              --res.months;
            }

            res.milliseconds = +other - +base.clone().add(res.months, "M");

            return res;
          }

          function momentsDifference(base, other) {
            var res;
            if (!(base.isValid() && other.isValid())) {
              return { milliseconds: 0, months: 0 };
            }

            other = cloneWithOffset(other, base);
            if (base.isBefore(other)) {
              res = positiveMomentsDifference(base, other);
            } else {
              res = positiveMomentsDifference(other, base);
              res.milliseconds = -res.milliseconds;
              res.months = -res.months;
            }

            return res;
          }

          // TODO: remove 'name' arg after deprecation is removed
          function createAdder(direction, name) {
            return function (val, period) {
              var dur, tmp;
              //invert the arguments, but complain about it
              if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                  name,
                  "moment()." +
                    name +
                    "(period, number) is deprecated. Please use moment()." +
                    name +
                    "(number, period). " +
                    "See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
                );
                tmp = val;
                val = period;
                period = tmp;
              }

              dur = createDuration(val, period);
              addSubtract(this, dur, direction);
              return this;
            };
          }

          function addSubtract(mom, duration, isAdding, updateOffset) {
            var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

            if (!mom.isValid()) {
              // No op
              return;
            }

            updateOffset = updateOffset == null ? true : updateOffset;

            if (months) {
              setMonth(mom, get(mom, "Month") + months * isAdding);
            }
            if (days) {
              set$1(mom, "Date", get(mom, "Date") + days * isAdding);
            }
            if (milliseconds) {
              mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
            }
            if (updateOffset) {
              hooks.updateOffset(mom, days || months);
            }
          }

          var add = createAdder(1, "add"),
            subtract = createAdder(-1, "subtract");

          function isString(input) {
            return typeof input === "string" || input instanceof String;
          }

          // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
          function isMomentInput(input) {
            return (
              isMoment(input) ||
              isDate(input) ||
              isString(input) ||
              isNumber(input) ||
              isNumberOrStringArray(input) ||
              isMomentInputObject(input) ||
              input === null ||
              input === undefined
            );
          }

          function isMomentInputObject(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
              propertyTest = false,
              properties = [
                "years",
                "year",
                "y",
                "months",
                "month",
                "M",
                "days",
                "day",
                "d",
                "dates",
                "date",
                "D",
                "hours",
                "hour",
                "h",
                "minutes",
                "minute",
                "m",
                "seconds",
                "second",
                "s",
                "milliseconds",
                "millisecond",
                "ms",
              ],
              i,
              property,
              propertyLen = properties.length;

            for (i = 0; i < propertyLen; i += 1) {
              property = properties[i];
              propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
          }

          function isNumberOrStringArray(input) {
            var arrayTest = isArray(input),
              dataTypeTest = false;
            if (arrayTest) {
              dataTypeTest =
                input.filter(function (item) {
                  return !isNumber(item) && isString(input);
                }).length === 0;
            }
            return arrayTest && dataTypeTest;
          }

          function isCalendarSpec(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
              propertyTest = false,
              properties = [
                "sameDay",
                "nextDay",
                "lastDay",
                "nextWeek",
                "lastWeek",
                "sameElse",
              ],
              i,
              property;

            for (i = 0; i < properties.length; i += 1) {
              property = properties[i];
              propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
          }

          function getCalendarFormat(myMoment, now) {
            var diff = myMoment.diff(now, "days", true);
            return diff < -6
              ? "sameElse"
              : diff < -1
              ? "lastWeek"
              : diff < 0
              ? "lastDay"
              : diff < 1
              ? "sameDay"
              : diff < 2
              ? "nextDay"
              : diff < 7
              ? "nextWeek"
              : "sameElse";
          }

          function calendar$1(time, formats) {
            // Support for single parameter, formats only overload to the calendar function
            if (arguments.length === 1) {
              if (!arguments[0]) {
                time = undefined;
                formats = undefined;
              } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
              } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
              }
            }
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're local/utc/offset or not.
            var now = time || createLocal(),
              sod = cloneWithOffset(now, this).startOf("day"),
              format = hooks.calendarFormat(this, sod) || "sameElse",
              output =
                formats &&
                (isFunction(formats[format])
                  ? formats[format].call(this, now)
                  : formats[format]);

            return this.format(
              output ||
                this.localeData().calendar(format, this, createLocal(now))
            );
          }

          function clone() {
            return new Moment(this);
          }

          function isAfter(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
              return false;
            }
            units = normalizeUnits(units) || "millisecond";
            if (units === "millisecond") {
              return this.valueOf() > localInput.valueOf();
            } else {
              return (
                localInput.valueOf() < this.clone().startOf(units).valueOf()
              );
            }
          }

          function isBefore(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
              return false;
            }
            units = normalizeUnits(units) || "millisecond";
            if (units === "millisecond") {
              return this.valueOf() < localInput.valueOf();
            } else {
              return this.clone().endOf(units).valueOf() < localInput.valueOf();
            }
          }

          function isBetween(from, to, units, inclusivity) {
            var localFrom = isMoment(from) ? from : createLocal(from),
              localTo = isMoment(to) ? to : createLocal(to);
            if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
              return false;
            }
            inclusivity = inclusivity || "()";
            return (
              (inclusivity[0] === "("
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
              (inclusivity[1] === ")"
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
            );
          }

          function isSame(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input),
              inputMs;
            if (!(this.isValid() && localInput.isValid())) {
              return false;
            }
            units = normalizeUnits(units) || "millisecond";
            if (units === "millisecond") {
              return this.valueOf() === localInput.valueOf();
            } else {
              inputMs = localInput.valueOf();
              return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
              );
            }
          }

          function isSameOrAfter(input, units) {
            return this.isSame(input, units) || this.isAfter(input, units);
          }

          function isSameOrBefore(input, units) {
            return this.isSame(input, units) || this.isBefore(input, units);
          }

          function diff(input, units, asFloat) {
            var that, zoneDelta, output;

            if (!this.isValid()) {
              return NaN;
            }

            that = cloneWithOffset(input, this);

            if (!that.isValid()) {
              return NaN;
            }

            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

            units = normalizeUnits(units);

            switch (units) {
              case "year":
                output = monthDiff(this, that) / 12;
                break;
              case "month":
                output = monthDiff(this, that);
                break;
              case "quarter":
                output = monthDiff(this, that) / 3;
                break;
              case "second":
                output = (this - that) / 1e3;
                break; // 1000
              case "minute":
                output = (this - that) / 6e4;
                break; // 1000 * 60
              case "hour":
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
              case "day":
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
              case "week":
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
              default:
                output = this - that;
            }

            return asFloat ? output : absFloor(output);
          }

          function monthDiff(a, b) {
            if (a.date() < b.date()) {
              // end-of-month calculations work correct when the start month has more
              // days than the end month.
              return -monthDiff(b, a);
            }
            // difference in months
            var wholeMonthDiff =
                (b.year() - a.year()) * 12 + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
              anchor = a.clone().add(wholeMonthDiff, "months"),
              anchor2,
              adjust;

            if (b - anchor < 0) {
              anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
              // linear across the month
              adjust = (b - anchor) / (anchor - anchor2);
            } else {
              anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
              // linear across the month
              adjust = (b - anchor) / (anchor2 - anchor);
            }

            //check for negative zero, return zero if negative zero
            return -(wholeMonthDiff + adjust) || 0;
          }

          hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
          hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";

          function toString() {
            return this.clone()
              .locale("en")
              .format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
          }

          function toISOString(keepOffset) {
            if (!this.isValid()) {
              return null;
            }
            var utc = keepOffset !== true,
              m = utc ? this.clone().utc() : this;
            if (m.year() < 0 || m.year() > 9999) {
              return formatMoment(
                m,
                utc
                  ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]"
                  : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
              );
            }
            if (isFunction(Date.prototype.toISOString)) {
              // native implementation is ~50x faster, use it when we can
              if (utc) {
                return this.toDate().toISOString();
              } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                  .toISOString()
                  .replace("Z", formatMoment(m, "Z"));
              }
            }
            return formatMoment(
              m,
              utc
                ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"
                : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
            );
          }

          /**
           * Return a human readable representation of a moment that can
           * also be evaluated to get a new moment which is the same
           *
           * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
           */
          function inspect() {
            if (!this.isValid()) {
              return "moment.invalid(/* " + this._i + " */)";
            }
            var func = "moment",
              zone = "",
              prefix,
              year,
              datetime,
              suffix;
            if (!this.isLocal()) {
              func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
              zone = "Z";
            }
            prefix = "[" + func + '("]';
            year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
            datetime = "-MM-DD[T]HH:mm:ss.SSS";
            suffix = zone + '[")]';

            return this.format(prefix + year + datetime + suffix);
          }

          function format(inputString) {
            if (!inputString) {
              inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
            }
            var output = formatMoment(this, inputString);
            return this.localeData().postformat(output);
          }

          function from(time, withoutSuffix) {
            if (
              this.isValid() &&
              ((isMoment(time) && time.isValid()) ||
                createLocal(time).isValid())
            ) {
              return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
            } else {
              return this.localeData().invalidDate();
            }
          }

          function fromNow(withoutSuffix) {
            return this.from(createLocal(), withoutSuffix);
          }

          function to(time, withoutSuffix) {
            if (
              this.isValid() &&
              ((isMoment(time) && time.isValid()) ||
                createLocal(time).isValid())
            ) {
              return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
            } else {
              return this.localeData().invalidDate();
            }
          }

          function toNow(withoutSuffix) {
            return this.to(createLocal(), withoutSuffix);
          }

          // If passed a locale key, it will set the locale for this
          // instance.  Otherwise, it will return the locale configuration
          // variables for this instance.
          function locale(key) {
            var newLocaleData;

            if (key === undefined) {
              return this._locale._abbr;
            } else {
              newLocaleData = getLocale(key);
              if (newLocaleData != null) {
                this._locale = newLocaleData;
              }
              return this;
            }
          }

          var lang = deprecate(
            "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
            function (key) {
              if (key === undefined) {
                return this.localeData();
              } else {
                return this.locale(key);
              }
            }
          );

          function localeData() {
            return this._locale;
          }

          var MS_PER_SECOND = 1000,
            MS_PER_MINUTE = 60 * MS_PER_SECOND,
            MS_PER_HOUR = 60 * MS_PER_MINUTE,
            MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

          // actual modulo - handles negative numbers (for dates before 1970):
          function mod$1(dividend, divisor) {
            return ((dividend % divisor) + divisor) % divisor;
          }

          function localStartOfDate(y, m, d) {
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return new Date(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
              return new Date(y, m, d).valueOf();
            }
          }

          function utcStartOfDate(y, m, d) {
            // Date.UTC remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
              return Date.UTC(y, m, d);
            }
          }

          function startOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (
              units === undefined ||
              units === "millisecond" ||
              !this.isValid()
            ) {
              return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
              case "year":
                time = startOfDate(this.year(), 0, 1);
                break;
              case "quarter":
                time = startOfDate(
                  this.year(),
                  this.month() - (this.month() % 3),
                  1
                );
                break;
              case "month":
                time = startOfDate(this.year(), this.month(), 1);
                break;
              case "week":
                time = startOfDate(
                  this.year(),
                  this.month(),
                  this.date() - this.weekday()
                );
                break;
              case "isoWeek":
                time = startOfDate(
                  this.year(),
                  this.month(),
                  this.date() - (this.isoWeekday() - 1)
                );
                break;
              case "day":
              case "date":
                time = startOfDate(this.year(), this.month(), this.date());
                break;
              case "hour":
                time = this._d.valueOf();
                time -= mod$1(
                  time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                  MS_PER_HOUR
                );
                break;
              case "minute":
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
              case "second":
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
          }

          function endOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (
              units === undefined ||
              units === "millisecond" ||
              !this.isValid()
            ) {
              return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
              case "year":
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
              case "quarter":
                time =
                  startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3) + 3,
                    1
                  ) - 1;
                break;
              case "month":
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
              case "week":
                time =
                  startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday() + 7
                  ) - 1;
                break;
              case "isoWeek":
                time =
                  startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1) + 7
                  ) - 1;
                break;
              case "day":
              case "date":
                time =
                  startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
              case "hour":
                time = this._d.valueOf();
                time +=
                  MS_PER_HOUR -
                  mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                  ) -
                  1;
                break;
              case "minute":
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
              case "second":
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
          }

          function valueOf() {
            return this._d.valueOf() - (this._offset || 0) * 60000;
          }

          function unix() {
            return Math.floor(this.valueOf() / 1000);
          }

          function toDate() {
            return new Date(this.valueOf());
          }

          function toArray() {
            var m = this;
            return [
              m.year(),
              m.month(),
              m.date(),
              m.hour(),
              m.minute(),
              m.second(),
              m.millisecond(),
            ];
          }

          function toObject() {
            var m = this;
            return {
              years: m.year(),
              months: m.month(),
              date: m.date(),
              hours: m.hours(),
              minutes: m.minutes(),
              seconds: m.seconds(),
              milliseconds: m.milliseconds(),
            };
          }

          function toJSON() {
            // new Date(NaN).toJSON() === null
            return this.isValid() ? this.toISOString() : null;
          }

          function isValid$2() {
            return isValid(this);
          }

          function parsingFlags() {
            return extend({}, getParsingFlags(this));
          }

          function invalidAt() {
            return getParsingFlags(this).overflow;
          }

          function creationData() {
            return {
              input: this._i,
              format: this._f,
              locale: this._locale,
              isUTC: this._isUTC,
              strict: this._strict,
            };
          }

          addFormatToken("N", 0, 0, "eraAbbr");
          addFormatToken("NN", 0, 0, "eraAbbr");
          addFormatToken("NNN", 0, 0, "eraAbbr");
          addFormatToken("NNNN", 0, 0, "eraName");
          addFormatToken("NNNNN", 0, 0, "eraNarrow");

          addFormatToken("y", ["y", 1], "yo", "eraYear");
          addFormatToken("y", ["yy", 2], 0, "eraYear");
          addFormatToken("y", ["yyy", 3], 0, "eraYear");
          addFormatToken("y", ["yyyy", 4], 0, "eraYear");

          addRegexToken("N", matchEraAbbr);
          addRegexToken("NN", matchEraAbbr);
          addRegexToken("NNN", matchEraAbbr);
          addRegexToken("NNNN", matchEraName);
          addRegexToken("NNNNN", matchEraNarrow);

          addParseToken(
            ["N", "NN", "NNN", "NNNN", "NNNNN"],
            function (input, array, config, token) {
              var era = config._locale.erasParse(input, token, config._strict);
              if (era) {
                getParsingFlags(config).era = era;
              } else {
                getParsingFlags(config).invalidEra = input;
              }
            }
          );

          addRegexToken("y", matchUnsigned);
          addRegexToken("yy", matchUnsigned);
          addRegexToken("yyy", matchUnsigned);
          addRegexToken("yyyy", matchUnsigned);
          addRegexToken("yo", matchEraYearOrdinal);

          addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
          addParseToken(["yo"], function (input, array, config, token) {
            var match;
            if (config._locale._eraYearOrdinalRegex) {
              match = input.match(config._locale._eraYearOrdinalRegex);
            }

            if (config._locale.eraYearOrdinalParse) {
              array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
            } else {
              array[YEAR] = parseInt(input, 10);
            }
          });

          function localeEras(m, format) {
            var i,
              l,
              date,
              eras = this._eras || getLocale("en")._eras;
            for (i = 0, l = eras.length; i < l; ++i) {
              switch (typeof eras[i].since) {
                case "string":
                  // truncate time
                  date = hooks(eras[i].since).startOf("day");
                  eras[i].since = date.valueOf();
                  break;
              }

              switch (typeof eras[i].until) {
                case "undefined":
                  eras[i].until = +Infinity;
                  break;
                case "string":
                  // truncate time
                  date = hooks(eras[i].until).startOf("day").valueOf();
                  eras[i].until = date.valueOf();
                  break;
              }
            }
            return eras;
          }

          function localeErasParse(eraName, format, strict) {
            var i,
              l,
              eras = this.eras(),
              name,
              abbr,
              narrow;
            eraName = eraName.toUpperCase();

            for (i = 0, l = eras.length; i < l; ++i) {
              name = eras[i].name.toUpperCase();
              abbr = eras[i].abbr.toUpperCase();
              narrow = eras[i].narrow.toUpperCase();

              if (strict) {
                switch (format) {
                  case "N":
                  case "NN":
                  case "NNN":
                    if (abbr === eraName) {
                      return eras[i];
                    }
                    break;

                  case "NNNN":
                    if (name === eraName) {
                      return eras[i];
                    }
                    break;

                  case "NNNNN":
                    if (narrow === eraName) {
                      return eras[i];
                    }
                    break;
                }
              } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
              }
            }
          }

          function localeErasConvertYear(era, year) {
            var dir = era.since <= era.until ? +1 : -1;
            if (year === undefined) {
              return hooks(era.since).year();
            } else {
              return hooks(era.since).year() + (year - era.offset) * dir;
            }
          }

          function getEraName() {
            var i,
              l,
              val,
              eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.clone().startOf("day").valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
              }
            }

            return "";
          }

          function getEraNarrow() {
            var i,
              l,
              val,
              eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.clone().startOf("day").valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
              }
            }

            return "";
          }

          function getEraAbbr() {
            var i,
              l,
              val,
              eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.clone().startOf("day").valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
              }
            }

            return "";
          }

          function getEraYear() {
            var i,
              l,
              dir,
              val,
              eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
              dir = eras[i].since <= eras[i].until ? +1 : -1;

              // truncate time
              val = this.clone().startOf("day").valueOf();

              if (
                (eras[i].since <= val && val <= eras[i].until) ||
                (eras[i].until <= val && val <= eras[i].since)
              ) {
                return (
                  (this.year() - hooks(eras[i].since).year()) * dir +
                  eras[i].offset
                );
              }
            }

            return this.year();
          }

          function erasNameRegex(isStrict) {
            if (!hasOwnProp(this, "_erasNameRegex")) {
              computeErasParse.call(this);
            }
            return isStrict ? this._erasNameRegex : this._erasRegex;
          }

          function erasAbbrRegex(isStrict) {
            if (!hasOwnProp(this, "_erasAbbrRegex")) {
              computeErasParse.call(this);
            }
            return isStrict ? this._erasAbbrRegex : this._erasRegex;
          }

          function erasNarrowRegex(isStrict) {
            if (!hasOwnProp(this, "_erasNarrowRegex")) {
              computeErasParse.call(this);
            }
            return isStrict ? this._erasNarrowRegex : this._erasRegex;
          }

          function matchEraAbbr(isStrict, locale) {
            return locale.erasAbbrRegex(isStrict);
          }

          function matchEraName(isStrict, locale) {
            return locale.erasNameRegex(isStrict);
          }

          function matchEraNarrow(isStrict, locale) {
            return locale.erasNarrowRegex(isStrict);
          }

          function matchEraYearOrdinal(isStrict, locale) {
            return locale._eraYearOrdinalRegex || matchUnsigned;
          }

          function computeErasParse() {
            var abbrPieces = [],
              namePieces = [],
              narrowPieces = [],
              mixedPieces = [],
              i,
              l,
              eras = this.eras();

            for (i = 0, l = eras.length; i < l; ++i) {
              namePieces.push(regexEscape(eras[i].name));
              abbrPieces.push(regexEscape(eras[i].abbr));
              narrowPieces.push(regexEscape(eras[i].narrow));

              mixedPieces.push(regexEscape(eras[i].name));
              mixedPieces.push(regexEscape(eras[i].abbr));
              mixedPieces.push(regexEscape(eras[i].narrow));
            }

            this._erasRegex = new RegExp(
              "^(" + mixedPieces.join("|") + ")",
              "i"
            );
            this._erasNameRegex = new RegExp(
              "^(" + namePieces.join("|") + ")",
              "i"
            );
            this._erasAbbrRegex = new RegExp(
              "^(" + abbrPieces.join("|") + ")",
              "i"
            );
            this._erasNarrowRegex = new RegExp(
              "^(" + narrowPieces.join("|") + ")",
              "i"
            );
          }

          // FORMATTING

          addFormatToken(0, ["gg", 2], 0, function () {
            return this.weekYear() % 100;
          });

          addFormatToken(0, ["GG", 2], 0, function () {
            return this.isoWeekYear() % 100;
          });

          function addWeekYearFormatToken(token, getter) {
            addFormatToken(0, [token, token.length], 0, getter);
          }

          addWeekYearFormatToken("gggg", "weekYear");
          addWeekYearFormatToken("ggggg", "weekYear");
          addWeekYearFormatToken("GGGG", "isoWeekYear");
          addWeekYearFormatToken("GGGGG", "isoWeekYear");

          // ALIASES

          addUnitAlias("weekYear", "gg");
          addUnitAlias("isoWeekYear", "GG");

          // PRIORITY

          addUnitPriority("weekYear", 1);
          addUnitPriority("isoWeekYear", 1);

          // PARSING

          addRegexToken("G", matchSigned);
          addRegexToken("g", matchSigned);
          addRegexToken("GG", match1to2, match2);
          addRegexToken("gg", match1to2, match2);
          addRegexToken("GGGG", match1to4, match4);
          addRegexToken("gggg", match1to4, match4);
          addRegexToken("GGGGG", match1to6, match6);
          addRegexToken("ggggg", match1to6, match6);

          addWeekParseToken(
            ["gggg", "ggggg", "GGGG", "GGGGG"],
            function (input, week, config, token) {
              week[token.substr(0, 2)] = toInt(input);
            }
          );

          addWeekParseToken(
            ["gg", "GG"],
            function (input, week, config, token) {
              week[token] = hooks.parseTwoDigitYear(input);
            }
          );

          // MOMENTS

          function getSetWeekYear(input) {
            return getSetWeekYearHelper.call(
              this,
              input,
              this.week(),
              this.weekday(),
              this.localeData()._week.dow,
              this.localeData()._week.doy
            );
          }

          function getSetISOWeekYear(input) {
            return getSetWeekYearHelper.call(
              this,
              input,
              this.isoWeek(),
              this.isoWeekday(),
              1,
              4
            );
          }

          function getISOWeeksInYear() {
            return weeksInYear(this.year(), 1, 4);
          }

          function getISOWeeksInISOWeekYear() {
            return weeksInYear(this.isoWeekYear(), 1, 4);
          }

          function getWeeksInYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
          }

          function getWeeksInWeekYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
          }

          function getSetWeekYearHelper(input, week, weekday, dow, doy) {
            var weeksTarget;
            if (input == null) {
              return weekOfYear(this, dow, doy).year;
            } else {
              weeksTarget = weeksInYear(input, dow, doy);
              if (week > weeksTarget) {
                week = weeksTarget;
              }
              return setWeekAll.call(this, input, week, weekday, dow, doy);
            }
          }

          function setWeekAll(weekYear, week, weekday, dow, doy) {
            var dayOfYearData = dayOfYearFromWeeks(
                weekYear,
                week,
                weekday,
                dow,
                doy
              ),
              date = createUTCDate(
                dayOfYearData.year,
                0,
                dayOfYearData.dayOfYear
              );

            this.year(date.getUTCFullYear());
            this.month(date.getUTCMonth());
            this.date(date.getUTCDate());
            return this;
          }

          // FORMATTING

          addFormatToken("Q", 0, "Qo", "quarter");

          // ALIASES

          addUnitAlias("quarter", "Q");

          // PRIORITY

          addUnitPriority("quarter", 7);

          // PARSING

          addRegexToken("Q", match1);
          addParseToken("Q", function (input, array) {
            array[MONTH] = (toInt(input) - 1) * 3;
          });

          // MOMENTS

          function getSetQuarter(input) {
            return input == null
              ? Math.ceil((this.month() + 1) / 3)
              : this.month((input - 1) * 3 + (this.month() % 3));
          }

          // FORMATTING

          addFormatToken("D", ["DD", 2], "Do", "date");

          // ALIASES

          addUnitAlias("date", "D");

          // PRIORITY
          addUnitPriority("date", 9);

          // PARSING

          addRegexToken("D", match1to2);
          addRegexToken("DD", match1to2, match2);
          addRegexToken("Do", function (isStrict, locale) {
            // TODO: Remove "ordinalParse" fallback in next major release.
            return isStrict
              ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
              : locale._dayOfMonthOrdinalParseLenient;
          });

          addParseToken(["D", "DD"], DATE);
          addParseToken("Do", function (input, array) {
            array[DATE] = toInt(input.match(match1to2)[0]);
          });

          // MOMENTS

          var getSetDayOfMonth = makeGetSet("Date", true);

          // FORMATTING

          addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");

          // ALIASES

          addUnitAlias("dayOfYear", "DDD");

          // PRIORITY
          addUnitPriority("dayOfYear", 4);

          // PARSING

          addRegexToken("DDD", match1to3);
          addRegexToken("DDDD", match3);
          addParseToken(["DDD", "DDDD"], function (input, array, config) {
            config._dayOfYear = toInt(input);
          });

          // HELPERS

          // MOMENTS

          function getSetDayOfYear(input) {
            var dayOfYear =
              Math.round(
                (this.clone().startOf("day") - this.clone().startOf("year")) /
                  864e5
              ) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
          }

          // FORMATTING

          addFormatToken("m", ["mm", 2], 0, "minute");

          // ALIASES

          addUnitAlias("minute", "m");

          // PRIORITY

          addUnitPriority("minute", 14);

          // PARSING

          addRegexToken("m", match1to2);
          addRegexToken("mm", match1to2, match2);
          addParseToken(["m", "mm"], MINUTE);

          // MOMENTS

          var getSetMinute = makeGetSet("Minutes", false);

          // FORMATTING

          addFormatToken("s", ["ss", 2], 0, "second");

          // ALIASES

          addUnitAlias("second", "s");

          // PRIORITY

          addUnitPriority("second", 15);

          // PARSING

          addRegexToken("s", match1to2);
          addRegexToken("ss", match1to2, match2);
          addParseToken(["s", "ss"], SECOND);

          // MOMENTS

          var getSetSecond = makeGetSet("Seconds", false);

          // FORMATTING

          addFormatToken("S", 0, 0, function () {
            return ~~(this.millisecond() / 100);
          });

          addFormatToken(0, ["SS", 2], 0, function () {
            return ~~(this.millisecond() / 10);
          });

          addFormatToken(0, ["SSS", 3], 0, "millisecond");
          addFormatToken(0, ["SSSS", 4], 0, function () {
            return this.millisecond() * 10;
          });
          addFormatToken(0, ["SSSSS", 5], 0, function () {
            return this.millisecond() * 100;
          });
          addFormatToken(0, ["SSSSSS", 6], 0, function () {
            return this.millisecond() * 1000;
          });
          addFormatToken(0, ["SSSSSSS", 7], 0, function () {
            return this.millisecond() * 10000;
          });
          addFormatToken(0, ["SSSSSSSS", 8], 0, function () {
            return this.millisecond() * 100000;
          });
          addFormatToken(0, ["SSSSSSSSS", 9], 0, function () {
            return this.millisecond() * 1000000;
          });

          // ALIASES

          addUnitAlias("millisecond", "ms");

          // PRIORITY

          addUnitPriority("millisecond", 16);

          // PARSING

          addRegexToken("S", match1to3, match1);
          addRegexToken("SS", match1to3, match2);
          addRegexToken("SSS", match1to3, match3);

          var token, getSetMillisecond;
          for (token = "SSSS"; token.length <= 9; token += "S") {
            addRegexToken(token, matchUnsigned);
          }

          function parseMs(input, array) {
            array[MILLISECOND] = toInt(("0." + input) * 1000);
          }

          for (token = "S"; token.length <= 9; token += "S") {
            addParseToken(token, parseMs);
          }

          getSetMillisecond = makeGetSet("Milliseconds", false);

          // FORMATTING

          addFormatToken("z", 0, 0, "zoneAbbr");
          addFormatToken("zz", 0, 0, "zoneName");

          // MOMENTS

          function getZoneAbbr() {
            return this._isUTC ? "UTC" : "";
          }

          function getZoneName() {
            return this._isUTC ? "Coordinated Universal Time" : "";
          }

          var proto = Moment.prototype;

          proto.add = add;
          proto.calendar = calendar$1;
          proto.clone = clone;
          proto.diff = diff;
          proto.endOf = endOf;
          proto.format = format;
          proto.from = from;
          proto.fromNow = fromNow;
          proto.to = to;
          proto.toNow = toNow;
          proto.get = stringGet;
          proto.invalidAt = invalidAt;
          proto.isAfter = isAfter;
          proto.isBefore = isBefore;
          proto.isBetween = isBetween;
          proto.isSame = isSame;
          proto.isSameOrAfter = isSameOrAfter;
          proto.isSameOrBefore = isSameOrBefore;
          proto.isValid = isValid$2;
          proto.lang = lang;
          proto.locale = locale;
          proto.localeData = localeData;
          proto.max = prototypeMax;
          proto.min = prototypeMin;
          proto.parsingFlags = parsingFlags;
          proto.set = stringSet;
          proto.startOf = startOf;
          proto.subtract = subtract;
          proto.toArray = toArray;
          proto.toObject = toObject;
          proto.toDate = toDate;
          proto.toISOString = toISOString;
          proto.inspect = inspect;
          if (typeof Symbol !== "undefined" && Symbol.for != null) {
            proto[Symbol.for("nodejs.util.inspect.custom")] = function () {
              return "Moment<" + this.format() + ">";
            };
          }
          proto.toJSON = toJSON;
          proto.toString = toString;
          proto.unix = unix;
          proto.valueOf = valueOf;
          proto.creationData = creationData;
          proto.eraName = getEraName;
          proto.eraNarrow = getEraNarrow;
          proto.eraAbbr = getEraAbbr;
          proto.eraYear = getEraYear;
          proto.year = getSetYear;
          proto.isLeapYear = getIsLeapYear;
          proto.weekYear = getSetWeekYear;
          proto.isoWeekYear = getSetISOWeekYear;
          proto.quarter = proto.quarters = getSetQuarter;
          proto.month = getSetMonth;
          proto.daysInMonth = getDaysInMonth;
          proto.week = proto.weeks = getSetWeek;
          proto.isoWeek = proto.isoWeeks = getSetISOWeek;
          proto.weeksInYear = getWeeksInYear;
          proto.weeksInWeekYear = getWeeksInWeekYear;
          proto.isoWeeksInYear = getISOWeeksInYear;
          proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
          proto.date = getSetDayOfMonth;
          proto.day = proto.days = getSetDayOfWeek;
          proto.weekday = getSetLocaleDayOfWeek;
          proto.isoWeekday = getSetISODayOfWeek;
          proto.dayOfYear = getSetDayOfYear;
          proto.hour = proto.hours = getSetHour;
          proto.minute = proto.minutes = getSetMinute;
          proto.second = proto.seconds = getSetSecond;
          proto.millisecond = proto.milliseconds = getSetMillisecond;
          proto.utcOffset = getSetOffset;
          proto.utc = setOffsetToUTC;
          proto.local = setOffsetToLocal;
          proto.parseZone = setOffsetToParsedOffset;
          proto.hasAlignedHourOffset = hasAlignedHourOffset;
          proto.isDST = isDaylightSavingTime;
          proto.isLocal = isLocal;
          proto.isUtcOffset = isUtcOffset;
          proto.isUtc = isUtc;
          proto.isUTC = isUtc;
          proto.zoneAbbr = getZoneAbbr;
          proto.zoneName = getZoneName;
          proto.dates = deprecate(
            "dates accessor is deprecated. Use date instead.",
            getSetDayOfMonth
          );
          proto.months = deprecate(
            "months accessor is deprecated. Use month instead",
            getSetMonth
          );
          proto.years = deprecate(
            "years accessor is deprecated. Use year instead",
            getSetYear
          );
          proto.zone = deprecate(
            "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
            getSetZone
          );
          proto.isDSTShifted = deprecate(
            "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
            isDaylightSavingTimeShifted
          );

          function createUnix(input) {
            return createLocal(input * 1000);
          }

          function createInZone() {
            return createLocal.apply(null, arguments).parseZone();
          }

          function preParsePostFormat(string) {
            return string;
          }

          var proto$1 = Locale.prototype;

          proto$1.calendar = calendar;
          proto$1.longDateFormat = longDateFormat;
          proto$1.invalidDate = invalidDate;
          proto$1.ordinal = ordinal;
          proto$1.preparse = preParsePostFormat;
          proto$1.postformat = preParsePostFormat;
          proto$1.relativeTime = relativeTime;
          proto$1.pastFuture = pastFuture;
          proto$1.set = set;
          proto$1.eras = localeEras;
          proto$1.erasParse = localeErasParse;
          proto$1.erasConvertYear = localeErasConvertYear;
          proto$1.erasAbbrRegex = erasAbbrRegex;
          proto$1.erasNameRegex = erasNameRegex;
          proto$1.erasNarrowRegex = erasNarrowRegex;

          proto$1.months = localeMonths;
          proto$1.monthsShort = localeMonthsShort;
          proto$1.monthsParse = localeMonthsParse;
          proto$1.monthsRegex = monthsRegex;
          proto$1.monthsShortRegex = monthsShortRegex;
          proto$1.week = localeWeek;
          proto$1.firstDayOfYear = localeFirstDayOfYear;
          proto$1.firstDayOfWeek = localeFirstDayOfWeek;

          proto$1.weekdays = localeWeekdays;
          proto$1.weekdaysMin = localeWeekdaysMin;
          proto$1.weekdaysShort = localeWeekdaysShort;
          proto$1.weekdaysParse = localeWeekdaysParse;

          proto$1.weekdaysRegex = weekdaysRegex;
          proto$1.weekdaysShortRegex = weekdaysShortRegex;
          proto$1.weekdaysMinRegex = weekdaysMinRegex;

          proto$1.isPM = localeIsPM;
          proto$1.meridiem = localeMeridiem;

          function get$1(format, index, field, setter) {
            var locale = getLocale(),
              utc = createUTC().set(setter, index);
            return locale[field](utc, format);
          }

          function listMonthsImpl(format, index, field) {
            if (isNumber(format)) {
              index = format;
              format = undefined;
            }

            format = format || "";

            if (index != null) {
              return get$1(format, index, field, "month");
            }

            var i,
              out = [];
            for (i = 0; i < 12; i++) {
              out[i] = get$1(format, i, field, "month");
            }
            return out;
          }

          // ()
          // (5)
          // (fmt, 5)
          // (fmt)
          // (true)
          // (true, 5)
          // (true, fmt, 5)
          // (true, fmt)
          function listWeekdaysImpl(localeSorted, format, index, field) {
            if (typeof localeSorted === "boolean") {
              if (isNumber(format)) {
                index = format;
                format = undefined;
              }

              format = format || "";
            } else {
              format = localeSorted;
              index = format;
              localeSorted = false;

              if (isNumber(format)) {
                index = format;
                format = undefined;
              }

              format = format || "";
            }

            var locale = getLocale(),
              shift = localeSorted ? locale._week.dow : 0,
              i,
              out = [];

            if (index != null) {
              return get$1(format, (index + shift) % 7, field, "day");
            }

            for (i = 0; i < 7; i++) {
              out[i] = get$1(format, (i + shift) % 7, field, "day");
            }
            return out;
          }

          function listMonths(format, index) {
            return listMonthsImpl(format, index, "months");
          }

          function listMonthsShort(format, index) {
            return listMonthsImpl(format, index, "monthsShort");
          }

          function listWeekdays(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, "weekdays");
          }

          function listWeekdaysShort(localeSorted, format, index) {
            return listWeekdaysImpl(
              localeSorted,
              format,
              index,
              "weekdaysShort"
            );
          }

          function listWeekdaysMin(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
          }

          getSetGlobalLocale("en", {
            eras: [
              {
                since: "0001-01-01",
                until: +Infinity,
                offset: 1,
                name: "Anno Domini",
                narrow: "AD",
                abbr: "AD",
              },
              {
                since: "0000-12-31",
                until: -Infinity,
                offset: 1,
                name: "Before Christ",
                narrow: "BC",
                abbr: "BC",
              },
            ],
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function (number) {
              var b = number % 10,
                output =
                  toInt((number % 100) / 10) === 1
                    ? "th"
                    : b === 1
                    ? "st"
                    : b === 2
                    ? "nd"
                    : b === 3
                    ? "rd"
                    : "th";
              return number + output;
            },
          });

          // Side effect imports

          hooks.lang = deprecate(
            "moment.lang is deprecated. Use moment.locale instead.",
            getSetGlobalLocale
          );
          hooks.langData = deprecate(
            "moment.langData is deprecated. Use moment.localeData instead.",
            getLocale
          );

          var mathAbs = Math.abs;

          function abs() {
            var data = this._data;

            this._milliseconds = mathAbs(this._milliseconds);
            this._days = mathAbs(this._days);
            this._months = mathAbs(this._months);

            data.milliseconds = mathAbs(data.milliseconds);
            data.seconds = mathAbs(data.seconds);
            data.minutes = mathAbs(data.minutes);
            data.hours = mathAbs(data.hours);
            data.months = mathAbs(data.months);
            data.years = mathAbs(data.years);

            return this;
          }

          function addSubtract$1(duration, input, value, direction) {
            var other = createDuration(input, value);

            duration._milliseconds += direction * other._milliseconds;
            duration._days += direction * other._days;
            duration._months += direction * other._months;

            return duration._bubble();
          }

          // supports only 2.0-style add(1, 's') or add(duration)
          function add$1(input, value) {
            return addSubtract$1(this, input, value, 1);
          }

          // supports only 2.0-style subtract(1, 's') or subtract(duration)
          function subtract$1(input, value) {
            return addSubtract$1(this, input, value, -1);
          }

          function absCeil(number) {
            if (number < 0) {
              return Math.floor(number);
            } else {
              return Math.ceil(number);
            }
          }

          function bubble() {
            var milliseconds = this._milliseconds,
              days = this._days,
              months = this._months,
              data = this._data,
              seconds,
              minutes,
              hours,
              years,
              monthsFromDays;

            // if we have a mix of positive and negative values, bubble down first
            // check: https://github.com/moment/moment/issues/2166
            if (
              !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
              )
            ) {
              milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
              days = 0;
              months = 0;
            }

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absFloor(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absFloor(seconds / 60);
            data.minutes = minutes % 60;

            hours = absFloor(minutes / 60);
            data.hours = hours % 24;

            days += absFloor(hours / 24);

            // convert days to months
            monthsFromDays = absFloor(daysToMonths(days));
            months += monthsFromDays;
            days -= absCeil(monthsToDays(monthsFromDays));

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;

            return this;
          }

          function daysToMonths(days) {
            // 400 years have 146097 days (taking into account leap year rules)
            // 400 years have 12 months === 4800
            return (days * 4800) / 146097;
          }

          function monthsToDays(months) {
            // the reverse of daysToMonths
            return (months * 146097) / 4800;
          }

          function as(units) {
            if (!this.isValid()) {
              return NaN;
            }
            var days,
              months,
              milliseconds = this._milliseconds;

            units = normalizeUnits(units);

            if (units === "month" || units === "quarter" || units === "year") {
              days = this._days + milliseconds / 864e5;
              months = this._months + daysToMonths(days);
              switch (units) {
                case "month":
                  return months;
                case "quarter":
                  return months / 3;
                case "year":
                  return months / 12;
              }
            } else {
              // handle milliseconds separately because of floating point math errors (issue #1867)
              days = this._days + Math.round(monthsToDays(this._months));
              switch (units) {
                case "week":
                  return days / 7 + milliseconds / 6048e5;
                case "day":
                  return days + milliseconds / 864e5;
                case "hour":
                  return days * 24 + milliseconds / 36e5;
                case "minute":
                  return days * 1440 + milliseconds / 6e4;
                case "second":
                  return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case "millisecond":
                  return Math.floor(days * 864e5) + milliseconds;
                default:
                  throw new Error("Unknown unit " + units);
              }
            }
          }

          // TODO: Use this.as('ms')?
          function valueOf$1() {
            if (!this.isValid()) {
              return NaN;
            }
            return (
              this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6
            );
          }

          function makeAs(alias) {
            return function () {
              return this.as(alias);
            };
          }

          var asMilliseconds = makeAs("ms"),
            asSeconds = makeAs("s"),
            asMinutes = makeAs("m"),
            asHours = makeAs("h"),
            asDays = makeAs("d"),
            asWeeks = makeAs("w"),
            asMonths = makeAs("M"),
            asQuarters = makeAs("Q"),
            asYears = makeAs("y");

          function clone$1() {
            return createDuration(this);
          }

          function get$2(units) {
            units = normalizeUnits(units);
            return this.isValid() ? this[units + "s"]() : NaN;
          }

          function makeGetter(name) {
            return function () {
              return this.isValid() ? this._data[name] : NaN;
            };
          }

          var milliseconds = makeGetter("milliseconds"),
            seconds = makeGetter("seconds"),
            minutes = makeGetter("minutes"),
            hours = makeGetter("hours"),
            days = makeGetter("days"),
            months = makeGetter("months"),
            years = makeGetter("years");

          function weeks() {
            return absFloor(this.days() / 7);
          }

          var round = Math.round,
            thresholds = {
              ss: 44, // a few seconds to seconds
              s: 45, // seconds to minute
              m: 45, // minutes to hour
              h: 22, // hours to day
              d: 26, // days to month/week
              w: null, // weeks to month
              M: 11, // months to year
            };

          // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
          function substituteTimeAgo(
            string,
            number,
            withoutSuffix,
            isFuture,
            locale
          ) {
            return locale.relativeTime(
              number || 1,
              !!withoutSuffix,
              string,
              isFuture
            );
          }

          function relativeTime$1(
            posNegDuration,
            withoutSuffix,
            thresholds,
            locale
          ) {
            var duration = createDuration(posNegDuration).abs(),
              seconds = round(duration.as("s")),
              minutes = round(duration.as("m")),
              hours = round(duration.as("h")),
              days = round(duration.as("d")),
              months = round(duration.as("M")),
              weeks = round(duration.as("w")),
              years = round(duration.as("y")),
              a =
                (seconds <= thresholds.ss && ["s", seconds]) ||
                (seconds < thresholds.s && ["ss", seconds]) ||
                (minutes <= 1 && ["m"]) ||
                (minutes < thresholds.m && ["mm", minutes]) ||
                (hours <= 1 && ["h"]) ||
                (hours < thresholds.h && ["hh", hours]) ||
                (days <= 1 && ["d"]) ||
                (days < thresholds.d && ["dd", days]);

            if (thresholds.w != null) {
              a =
                a ||
                (weeks <= 1 && ["w"]) ||
                (weeks < thresholds.w && ["ww", weeks]);
            }
            a = a ||
              (months <= 1 && ["M"]) ||
              (months < thresholds.M && ["MM", months]) ||
              (years <= 1 && ["y"]) || ["yy", years];

            a[2] = withoutSuffix;
            a[3] = +posNegDuration > 0;
            a[4] = locale;
            return substituteTimeAgo.apply(null, a);
          }

          // This function allows you to set the rounding function for relative time strings
          function getSetRelativeTimeRounding(roundingFunction) {
            if (roundingFunction === undefined) {
              return round;
            }
            if (typeof roundingFunction === "function") {
              round = roundingFunction;
              return true;
            }
            return false;
          }

          // This function allows you to set a threshold for relative time strings
          function getSetRelativeTimeThreshold(threshold, limit) {
            if (thresholds[threshold] === undefined) {
              return false;
            }
            if (limit === undefined) {
              return thresholds[threshold];
            }
            thresholds[threshold] = limit;
            if (threshold === "s") {
              thresholds.ss = limit - 1;
            }
            return true;
          }

          function humanize(argWithSuffix, argThresholds) {
            if (!this.isValid()) {
              return this.localeData().invalidDate();
            }

            var withSuffix = false,
              th = thresholds,
              locale,
              output;

            if (typeof argWithSuffix === "object") {
              argThresholds = argWithSuffix;
              argWithSuffix = false;
            }
            if (typeof argWithSuffix === "boolean") {
              withSuffix = argWithSuffix;
            }
            if (typeof argThresholds === "object") {
              th = Object.assign({}, thresholds, argThresholds);
              if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
              }
            }

            locale = this.localeData();
            output = relativeTime$1(this, !withSuffix, th, locale);

            if (withSuffix) {
              output = locale.pastFuture(+this, output);
            }

            return locale.postformat(output);
          }

          var abs$1 = Math.abs;

          function sign(x) {
            return (x > 0) - (x < 0) || +x;
          }

          function toISOString$1() {
            // for ISO strings we do not use the normal bubbling rules:
            //  * milliseconds bubble up until they become hours
            //  * days do not bubble at all
            //  * months bubble up until they become years
            // This is because there is no context-free conversion between hours and days
            // (think of clock changes)
            // and also not between days and months (28-31 days per month)
            if (!this.isValid()) {
              return this.localeData().invalidDate();
            }

            var seconds = abs$1(this._milliseconds) / 1000,
              days = abs$1(this._days),
              months = abs$1(this._months),
              minutes,
              hours,
              years,
              s,
              total = this.asSeconds(),
              totalSign,
              ymSign,
              daysSign,
              hmsSign;

            if (!total) {
              // this is the same as C#'s (Noda) and python (isodate)...
              // but not other JS (goog.date)
              return "P0D";
            }

            // 3600 seconds -> 60 minutes -> 1 hour
            minutes = absFloor(seconds / 60);
            hours = absFloor(minutes / 60);
            seconds %= 60;
            minutes %= 60;

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "";

            totalSign = total < 0 ? "-" : "";
            ymSign = sign(this._months) !== sign(total) ? "-" : "";
            daysSign = sign(this._days) !== sign(total) ? "-" : "";
            hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";

            return (
              totalSign +
              "P" +
              (years ? ymSign + years + "Y" : "") +
              (months ? ymSign + months + "M" : "") +
              (days ? daysSign + days + "D" : "") +
              (hours || minutes || seconds ? "T" : "") +
              (hours ? hmsSign + hours + "H" : "") +
              (minutes ? hmsSign + minutes + "M" : "") +
              (seconds ? hmsSign + s + "S" : "")
            );
          }

          var proto$2 = Duration.prototype;

          proto$2.isValid = isValid$1;
          proto$2.abs = abs;
          proto$2.add = add$1;
          proto$2.subtract = subtract$1;
          proto$2.as = as;
          proto$2.asMilliseconds = asMilliseconds;
          proto$2.asSeconds = asSeconds;
          proto$2.asMinutes = asMinutes;
          proto$2.asHours = asHours;
          proto$2.asDays = asDays;
          proto$2.asWeeks = asWeeks;
          proto$2.asMonths = asMonths;
          proto$2.asQuarters = asQuarters;
          proto$2.asYears = asYears;
          proto$2.valueOf = valueOf$1;
          proto$2._bubble = bubble;
          proto$2.clone = clone$1;
          proto$2.get = get$2;
          proto$2.milliseconds = milliseconds;
          proto$2.seconds = seconds;
          proto$2.minutes = minutes;
          proto$2.hours = hours;
          proto$2.days = days;
          proto$2.weeks = weeks;
          proto$2.months = months;
          proto$2.years = years;
          proto$2.humanize = humanize;
          proto$2.toISOString = toISOString$1;
          proto$2.toString = toISOString$1;
          proto$2.toJSON = toISOString$1;
          proto$2.locale = locale;
          proto$2.localeData = localeData;

          proto$2.toIsoString = deprecate(
            "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
            toISOString$1
          );
          proto$2.lang = lang;

          // FORMATTING

          addFormatToken("X", 0, 0, "unix");
          addFormatToken("x", 0, 0, "valueOf");

          // PARSING

          addRegexToken("x", matchSigned);
          addRegexToken("X", matchTimestamp);
          addParseToken("X", function (input, array, config) {
            config._d = new Date(parseFloat(input) * 1000);
          });
          addParseToken("x", function (input, array, config) {
            config._d = new Date(toInt(input));
          });

          //! moment.js

          hooks.version = "2.29.4";

          setHookCallback(createLocal);

          hooks.fn = proto;
          hooks.min = min;
          hooks.max = max;
          hooks.now = now;
          hooks.utc = createUTC;
          hooks.unix = createUnix;
          hooks.months = listMonths;
          hooks.isDate = isDate;
          hooks.locale = getSetGlobalLocale;
          hooks.invalid = createInvalid;
          hooks.duration = createDuration;
          hooks.isMoment = isMoment;
          hooks.weekdays = listWeekdays;
          hooks.parseZone = createInZone;
          hooks.localeData = getLocale;
          hooks.isDuration = isDuration;
          hooks.monthsShort = listMonthsShort;
          hooks.weekdaysMin = listWeekdaysMin;
          hooks.defineLocale = defineLocale;
          hooks.updateLocale = updateLocale;
          hooks.locales = listLocales;
          hooks.weekdaysShort = listWeekdaysShort;
          hooks.normalizeUnits = normalizeUnits;
          hooks.relativeTimeRounding = getSetRelativeTimeRounding;
          hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
          hooks.calendarFormat = getCalendarFormat;
          hooks.prototype = proto;

          // currently HTML5 input type only supports 24-hour formats
          hooks.HTML5_FMT = {
            DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", // <input type="datetime-local" />
            DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", // <input type="datetime-local" step="1" />
            DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", // <input type="datetime-local" step="0.001" />
            DATE: "YYYY-MM-DD", // <input type="date" />
            TIME: "HH:mm", // <input type="time" />
            TIME_SECONDS: "HH:mm:ss", // <input type="time" step="1" />
            TIME_MS: "HH:mm:ss.SSS", // <input type="time" step="0.001" />
            WEEK: "GGGG-[W]WW", // <input type="week" />
            MONTH: "YYYY-MM", // <input type="month" />
          };

          return hooks;
        });
      },
      {},
    ],
    158: [
      function (require, module, exports) {
        /**
         * Helpers.
         */

        var s = 1000;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var y = d * 365.25;

        /**
         * Parse or format the given `val`.
         *
         * Options:
         *
         *  - `long` verbose formatting [false]
         *
         * @param {String|Number} val
         * @param {Object} [options]
         * @throws {Error} throw an error if val is not a non-empty string or a number
         * @return {String|Number}
         * @api public
         */

        module.exports = function (val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse(val);
          } else if (type === "number" && isNaN(val) === false) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" +
              JSON.stringify(val)
          );
        };

        /**
         * Parse the given `str` and return milliseconds.
         *
         * @param {String} str
         * @return {Number}
         * @api private
         */

        function parse(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match =
            /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
              str
            );
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return undefined;
          }
        }

        /**
         * Short format for `ms`.
         *
         * @param {Number} ms
         * @return {String}
         * @api private
         */

        function fmtShort(ms) {
          if (ms >= d) {
            return Math.round(ms / d) + "d";
          }
          if (ms >= h) {
            return Math.round(ms / h) + "h";
          }
          if (ms >= m) {
            return Math.round(ms / m) + "m";
          }
          if (ms >= s) {
            return Math.round(ms / s) + "s";
          }
          return ms + "ms";
        }

        /**
         * Long format for `ms`.
         *
         * @param {Number} ms
         * @return {String}
         * @api private
         */

        function fmtLong(ms) {
          return (
            plural(ms, d, "day") ||
            plural(ms, h, "hour") ||
            plural(ms, m, "minute") ||
            plural(ms, s, "second") ||
            ms + " ms"
          );
        }

        /**
         * Pluralization helper.
         */

        function plural(ms, n, name) {
          if (ms < n) {
            return;
          }
          if (ms < n * 1.5) {
            return Math.floor(ms / n) + " " + name;
          }
          return Math.ceil(ms / n) + " " + name + "s";
        }
      },
      {},
    ],
    159: [
      function (require, module, exports) {
        "use strict";

        /**
         * Module dependencies
         */

        var util = require("util");
        var toRegex = require("to-regex");
        var extend = require("extend-shallow");

        /**
         * Local dependencies
         */

        var compilers = require("./lib/compilers");
        var parsers = require("./lib/parsers");
        var cache = require("./lib/cache");
        var utils = require("./lib/utils");
        var MAX_LENGTH = 1024 * 64;

        /**
         * The main function takes a list of strings and one or more
         * glob patterns to use for matching.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm(list, patterns[, options]);
         *
         * console.log(nm(['a.js', 'a.txt'], ['*.js']));
         * //=> [ 'a.js' ]
         * ```
         * @param {Array} `list` A list of strings to match
         * @param {String|Array} `patterns` One or more glob patterns to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Array} Returns an array of matches
         * @summary false
         * @api public
         */

        function nanomatch(list, patterns, options) {
          patterns = utils.arrayify(patterns);
          list = utils.arrayify(list);

          var len = patterns.length;
          if (list.length === 0 || len === 0) {
            return [];
          }

          if (len === 1) {
            return nanomatch.match(list, patterns[0], options);
          }

          var negated = false;
          var omit = [];
          var keep = [];
          var idx = -1;

          while (++idx < len) {
            var pattern = patterns[idx];

            if (
              typeof pattern === "string" &&
              pattern.charCodeAt(0) === 33 /* ! */
            ) {
              omit.push.apply(
                omit,
                nanomatch.match(list, pattern.slice(1), options)
              );
              negated = true;
            } else {
              keep.push.apply(keep, nanomatch.match(list, pattern, options));
            }
          }

          // minimatch.match parity
          if (negated && keep.length === 0) {
            if (options && options.unixify === false) {
              keep = list.slice();
            } else {
              var unixify = utils.unixify(options);
              for (var i = 0; i < list.length; i++) {
                keep.push(unixify(list[i]));
              }
            }
          }

          var matches = utils.diff(keep, omit);
          if (!options || options.nodupes !== false) {
            return utils.unique(matches);
          }

          return matches;
        }

        /**
         * Similar to the main function, but `pattern` must be a string.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.match(list, pattern[, options]);
         *
         * console.log(nm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
         * //=> ['a.a', 'a.aa']
         * ```
         * @param {Array} `list` Array of strings to match
         * @param {String} `pattern` Glob pattern to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Array} Returns an array of matches
         * @api public
         */

        nanomatch.match = function (list, pattern, options) {
          if (Array.isArray(pattern)) {
            throw new TypeError("expected pattern to be a string");
          }

          var unixify = utils.unixify(options);
          var isMatch = memoize("match", pattern, options, nanomatch.matcher);
          var matches = [];

          list = utils.arrayify(list);
          var len = list.length;
          var idx = -1;

          while (++idx < len) {
            var ele = list[idx];
            if (ele === pattern || isMatch(ele)) {
              matches.push(utils.value(ele, unixify, options));
            }
          }

          // if no options were passed, uniquify results and return
          if (typeof options === "undefined") {
            return utils.unique(matches);
          }

          if (matches.length === 0) {
            if (options.failglob === true) {
              throw new Error('no matches found for "' + pattern + '"');
            }
            if (options.nonull === true || options.nullglob === true) {
              return [options.unescape ? utils.unescape(pattern) : pattern];
            }
          }

          // if `opts.ignore` was defined, diff ignored list
          if (options.ignore) {
            matches = nanomatch.not(matches, options.ignore, options);
          }

          return options.nodupes !== false ? utils.unique(matches) : matches;
        };

        /**
         * Returns true if the specified `string` matches the given glob `pattern`.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.isMatch(string, pattern[, options]);
         *
         * console.log(nm.isMatch('a.a', '*.a'));
         * //=> true
         * console.log(nm.isMatch('a.b', '*.a'));
         * //=> false
         * ```
         * @param {String} `string` String to match
         * @param {String} `pattern` Glob pattern to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns true if the string matches the glob pattern.
         * @api public
         */

        nanomatch.isMatch = function (str, pattern, options) {
          if (typeof str !== "string") {
            throw new TypeError(
              'expected a string: "' + util.inspect(str) + '"'
            );
          }

          if (utils.isEmptyString(str) || utils.isEmptyString(pattern)) {
            return false;
          }

          var equals = utils.equalsPattern(options);
          if (equals(str)) {
            return true;
          }

          var isMatch = memoize("isMatch", pattern, options, nanomatch.matcher);
          return isMatch(str);
        };

        /**
         * Returns true if some of the elements in the given `list` match any of the
         * given glob `patterns`.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.some(list, patterns[, options]);
         *
         * console.log(nm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
         * // true
         * console.log(nm.some(['foo.js'], ['*.js', '!foo.js']));
         * // false
         * ```
         * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
         * @param {String|Array} `patterns` One or more glob patterns to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns true if any patterns match `str`
         * @api public
         */

        nanomatch.some = function (list, patterns, options) {
          if (typeof list === "string") {
            list = [list];
          }

          for (var i = 0; i < list.length; i++) {
            if (nanomatch(list[i], patterns, options).length === 1) {
              return true;
            }
          }

          return false;
        };

        /**
         * Returns true if every element in the given `list` matches
         * at least one of the given glob `patterns`.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.every(list, patterns[, options]);
         *
         * console.log(nm.every('foo.js', ['foo.js']));
         * // true
         * console.log(nm.every(['foo.js', 'bar.js'], ['*.js']));
         * // true
         * console.log(nm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
         * // false
         * console.log(nm.every(['foo.js'], ['*.js', '!foo.js']));
         * // false
         * ```
         * @param  {String|Array} `list` The string or array of strings to test.
         * @param {String|Array} `patterns` One or more glob patterns to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns true if any patterns match `str`
         * @api public
         */

        nanomatch.every = function (list, patterns, options) {
          if (typeof list === "string") {
            list = [list];
          }

          for (var i = 0; i < list.length; i++) {
            if (nanomatch(list[i], patterns, options).length !== 1) {
              return false;
            }
          }

          return true;
        };

        /**
         * Returns true if **any** of the given glob `patterns`
         * match the specified `string`.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.any(string, patterns[, options]);
         *
         * console.log(nm.any('a.a', ['b.*', '*.a']));
         * //=> true
         * console.log(nm.any('a.a', 'b.*'));
         * //=> false
         * ```
         * @param  {String|Array} `str` The string to test.
         * @param {String|Array} `patterns` One or more glob patterns to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns true if any patterns match `str`
         * @api public
         */

        nanomatch.any = function (str, patterns, options) {
          if (typeof str !== "string") {
            throw new TypeError(
              'expected a string: "' + util.inspect(str) + '"'
            );
          }

          if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
            return false;
          }

          if (typeof patterns === "string") {
            patterns = [patterns];
          }

          for (var i = 0; i < patterns.length; i++) {
            if (nanomatch.isMatch(str, patterns[i], options)) {
              return true;
            }
          }
          return false;
        };

        /**
         * Returns true if **all** of the given `patterns`
         * match the specified string.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.all(string, patterns[, options]);
         *
         * console.log(nm.all('foo.js', ['foo.js']));
         * // true
         *
         * console.log(nm.all('foo.js', ['*.js', '!foo.js']));
         * // false
         *
         * console.log(nm.all('foo.js', ['*.js', 'foo.js']));
         * // true
         *
         * console.log(nm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
         * // true
         * ```
         * @param  {String|Array} `str` The string to test.
         * @param {String|Array} `patterns` One or more glob patterns to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns true if any patterns match `str`
         * @api public
         */

        nanomatch.all = function (str, patterns, options) {
          if (typeof str !== "string") {
            throw new TypeError(
              'expected a string: "' + util.inspect(str) + '"'
            );
          }

          if (typeof patterns === "string") {
            patterns = [patterns];
          }

          for (var i = 0; i < patterns.length; i++) {
            if (!nanomatch.isMatch(str, patterns[i], options)) {
              return false;
            }
          }
          return true;
        };

        /**
         * Returns a list of strings that _**do not match any**_ of the given `patterns`.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.not(list, patterns[, options]);
         *
         * console.log(nm.not(['a.a', 'b.b', 'c.c'], '*.a'));
         * //=> ['b.b', 'c.c']
         * ```
         * @param {Array} `list` Array of strings to match.
         * @param {String|Array} `patterns` One or more glob pattern to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Array} Returns an array of strings that **do not match** the given patterns.
         * @api public
         */

        nanomatch.not = function (list, patterns, options) {
          var opts = extend({}, options);
          var ignore = opts.ignore;
          delete opts.ignore;

          list = utils.arrayify(list);

          var matches = utils.diff(list, nanomatch(list, patterns, opts));
          if (ignore) {
            matches = utils.diff(matches, nanomatch(list, ignore));
          }

          return opts.nodupes !== false ? utils.unique(matches) : matches;
        };

        /**
         * Returns true if the given `string` contains the given pattern. Similar
         * to [.isMatch](#isMatch) but the pattern can match any part of the string.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.contains(string, pattern[, options]);
         *
         * console.log(nm.contains('aa/bb/cc', '*b'));
         * //=> true
         * console.log(nm.contains('aa/bb/cc', '*d'));
         * //=> false
         * ```
         * @param {String} `str` The string to match.
         * @param {String|Array} `patterns` Glob pattern to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns true if the patter matches any part of `str`.
         * @api public
         */

        nanomatch.contains = function (str, patterns, options) {
          if (typeof str !== "string") {
            throw new TypeError(
              'expected a string: "' + util.inspect(str) + '"'
            );
          }

          if (typeof patterns === "string") {
            if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
              return false;
            }

            var equals = utils.equalsPattern(patterns, options);
            if (equals(str)) {
              return true;
            }
            var contains = utils.containsPattern(patterns, options);
            if (contains(str)) {
              return true;
            }
          }

          var opts = extend({}, options, { contains: true });
          return nanomatch.any(str, patterns, opts);
        };

        /**
         * Returns true if the given pattern and options should enable
         * the `matchBase` option.
         * @return {Boolean}
         * @api private
         */

        nanomatch.matchBase = function (pattern, options) {
          if ((pattern && pattern.indexOf("/") !== -1) || !options)
            return false;
          return options.basename === true || options.matchBase === true;
        };

        /**
         * Filter the keys of the given object with the given `glob` pattern
         * and `options`. Does not attempt to match nested keys. If you need this feature,
         * use [glob-object][] instead.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.matchKeys(object, patterns[, options]);
         *
         * var obj = { aa: 'a', ab: 'b', ac: 'c' };
         * console.log(nm.matchKeys(obj, '*b'));
         * //=> { ab: 'b' }
         * ```
         * @param {Object} `object` The object with keys to filter.
         * @param {String|Array} `patterns` One or more glob patterns to use for matching.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Object} Returns an object with only keys that match the given patterns.
         * @api public
         */

        nanomatch.matchKeys = function (obj, patterns, options) {
          if (!utils.isObject(obj)) {
            throw new TypeError("expected the first argument to be an object");
          }
          var keys = nanomatch(Object.keys(obj), patterns, options);
          return utils.pick(obj, keys);
        };

        /**
         * Returns a memoized matcher function from the given glob `pattern` and `options`.
         * The returned function takes a string to match as its only argument and returns
         * true if the string is a match.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.matcher(pattern[, options]);
         *
         * var isMatch = nm.matcher('*.!(*a)');
         * console.log(isMatch('a.a'));
         * //=> false
         * console.log(isMatch('a.b'));
         * //=> true
         * ```
         * @param {String} `pattern` Glob pattern
         * @param {Object} `options` See available [options](#options) for changing how matches are performed.
         * @return {Function} Returns a matcher function.
         * @api public
         */

        nanomatch.matcher = function matcher(pattern, options) {
          if (utils.isEmptyString(pattern)) {
            return function () {
              return false;
            };
          }

          if (Array.isArray(pattern)) {
            return compose(pattern, options, matcher);
          }

          // if pattern is a regex
          if (pattern instanceof RegExp) {
            return test(pattern);
          }

          // if pattern is invalid
          if (!utils.isString(pattern)) {
            throw new TypeError(
              "expected pattern to be an array, string or regex"
            );
          }

          // if pattern is a non-glob string
          if (!utils.hasSpecialChars(pattern)) {
            if (options && options.nocase === true) {
              pattern = pattern.toLowerCase();
            }
            return utils.matchPath(pattern, options);
          }

          // if pattern is a glob string
          var re = nanomatch.makeRe(pattern, options);

          // if `options.matchBase` or `options.basename` is defined
          if (nanomatch.matchBase(pattern, options)) {
            return utils.matchBasename(re, options);
          }

          function test(regex) {
            var equals = utils.equalsPattern(options);
            var unixify = utils.unixify(options);

            return function (str) {
              if (equals(str)) {
                return true;
              }

              if (regex.test(unixify(str))) {
                return true;
              }
              return false;
            };
          }

          // create matcher function
          var matcherFn = test(re);
          // set result object from compiler on matcher function,
          // as a non-enumerable property. useful for debugging
          utils.define(matcherFn, "result", re.result);
          return matcherFn;
        };

        /**
         * Returns an array of matches captured by `pattern` in `string, or
         * `null` if the pattern did not match.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.capture(pattern, string[, options]);
         *
         * console.log(nm.capture('test/*.js', 'test/foo.js'));
         * //=> ['foo']
         * console.log(nm.capture('test/*.js', 'foo/bar.css'));
         * //=> null
         * ```
         * @param {String} `pattern` Glob pattern to use for matching.
         * @param {String} `string` String to match
         * @param {Object} `options` See available [options](#options) for changing how matches are performed
         * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
         * @api public
         */

        nanomatch.capture = function (pattern, str, options) {
          var re = nanomatch.makeRe(
            pattern,
            extend({ capture: true }, options)
          );
          var unixify = utils.unixify(options);

          function match() {
            return function (string) {
              var match = re.exec(unixify(string));
              if (!match) {
                return null;
              }

              return match.slice(1);
            };
          }

          var capture = memoize("capture", pattern, options, match);
          return capture(str);
        };

        /**
         * Create a regular expression from the given glob `pattern`.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.makeRe(pattern[, options]);
         *
         * console.log(nm.makeRe('*.js'));
         * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
         * ```
         * @param {String} `pattern` A glob pattern to convert to regex.
         * @param {Object} `options` See available [options](#options) for changing how matches are performed.
         * @return {RegExp} Returns a regex created from the given pattern.
         * @api public
         */

        nanomatch.makeRe = function (pattern, options) {
          if (pattern instanceof RegExp) {
            return pattern;
          }

          if (typeof pattern !== "string") {
            throw new TypeError("expected pattern to be a string");
          }

          if (pattern.length > MAX_LENGTH) {
            throw new Error(
              "expected pattern to be less than " + MAX_LENGTH + " characters"
            );
          }

          function makeRe() {
            var opts = utils.extend({ wrap: false }, options);
            var result = nanomatch.create(pattern, opts);
            var regex = toRegex(result.output, opts);
            utils.define(regex, "result", result);
            return regex;
          }

          return memoize("makeRe", pattern, options, makeRe);
        };

        /**
         * Parses the given glob `pattern` and returns an object with the compiled `output`
         * and optional source `map`.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.create(pattern[, options]);
         *
         * console.log(nm.create('abc/*.js'));
         * // { options: { source: 'string', sourcemap: true },
         * //   state: {},
         * //   compilers:
         * //    { ... },
         * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
         * //   ast:
         * //    { type: 'root',
         * //      errors: [],
         * //      nodes:
         * //       [ ... ],
         * //      dot: false,
         * //      input: 'abc/*.js' },
         * //   parsingErrors: [],
         * //   map:
         * //    { version: 3,
         * //      sources: [ 'string' ],
         * //      names: [],
         * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
         * //      sourcesContent: [ 'abc/*.js' ] },
         * //   position: { line: 1, column: 28 },
         * //   content: {},
         * //   files: {},
         * //   idx: 6 }
         * ```
         * @param {String} `pattern` Glob pattern to parse and compile.
         * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.
         * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.
         * @api public
         */

        nanomatch.create = function (pattern, options) {
          if (typeof pattern !== "string") {
            throw new TypeError("expected a string");
          }
          function create() {
            return nanomatch.compile(
              nanomatch.parse(pattern, options),
              options
            );
          }
          return memoize("create", pattern, options, create);
        };

        /**
         * Parse the given `str` with the given `options`.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.parse(pattern[, options]);
         *
         * var ast = nm.parse('a/{b,c}/d');
         * console.log(ast);
         * // { type: 'root',
         * //   errors: [],
         * //   input: 'a/{b,c}/d',
         * //   nodes:
         * //    [ { type: 'bos', val: '' },
         * //      { type: 'text', val: 'a/' },
         * //      { type: 'brace',
         * //        nodes:
         * //         [ { type: 'brace.open', val: '{' },
         * //           { type: 'text', val: 'b,c' },
         * //           { type: 'brace.close', val: '}' } ] },
         * //      { type: 'text', val: '/d' },
         * //      { type: 'eos', val: '' } ] }
         * ```
         * @param {String} `str`
         * @param {Object} `options`
         * @return {Object} Returns an AST
         * @api public
         */

        nanomatch.parse = function (pattern, options) {
          if (typeof pattern !== "string") {
            throw new TypeError("expected a string");
          }

          function parse() {
            var snapdragon = utils.instantiate(null, options);
            parsers(snapdragon, options);

            var ast = snapdragon.parse(pattern, options);
            utils.define(ast, "snapdragon", snapdragon);
            ast.input = pattern;
            return ast;
          }

          return memoize("parse", pattern, options, parse);
        };

        /**
         * Compile the given `ast` or string with the given `options`.
         *
         * ```js
         * var nm = require('nanomatch');
         * nm.compile(ast[, options]);
         *
         * var ast = nm.parse('a/{b,c}/d');
         * console.log(nm.compile(ast));
         * // { options: { source: 'string' },
         * //   state: {},
         * //   compilers:
         * //    { eos: [Function],
         * //      noop: [Function],
         * //      bos: [Function],
         * //      brace: [Function],
         * //      'brace.open': [Function],
         * //      text: [Function],
         * //      'brace.close': [Function] },
         * //   output: [ 'a/(b|c)/d' ],
         * //   ast:
         * //    { ... },
         * //   parsingErrors: [] }
         * ```
         * @param {Object|String} `ast`
         * @param {Object} `options`
         * @return {Object} Returns an object that has an `output` property with the compiled string.
         * @api public
         */

        nanomatch.compile = function (ast, options) {
          if (typeof ast === "string") {
            ast = nanomatch.parse(ast, options);
          }

          function compile() {
            var snapdragon = utils.instantiate(ast, options);
            compilers(snapdragon, options);
            return snapdragon.compile(ast, options);
          }

          return memoize("compile", ast.input, options, compile);
        };

        /**
         * Clear the regex cache.
         *
         * ```js
         * nm.clearCache();
         * ```
         * @api public
         */

        nanomatch.clearCache = function () {
          nanomatch.cache.__data__ = {};
        };

        /**
         * Compose a matcher function with the given patterns.
         * This allows matcher functions to be compiled once and
         * called multiple times.
         */

        function compose(patterns, options, matcher) {
          var matchers;

          return memoize("compose", String(patterns), options, function () {
            return function (file) {
              // delay composition until it's invoked the first time,
              // after that it won't be called again
              if (!matchers) {
                matchers = [];
                for (var i = 0; i < patterns.length; i++) {
                  matchers.push(matcher(patterns[i], options));
                }
              }

              var len = matchers.length;
              while (len--) {
                if (matchers[len](file) === true) {
                  return true;
                }
              }
              return false;
            };
          });
        }

        /**
         * Memoize a generated regex or function. A unique key is generated
         * from the `type` (usually method name), the `pattern`, and
         * user-defined options.
         */

        function memoize(type, pattern, options, fn) {
          var key = utils.createKey(type + "=" + pattern, options);

          if (options && options.cache === false) {
            return fn(pattern, options);
          }

          if (cache.has(type, key)) {
            return cache.get(type, key);
          }

          var val = fn(pattern, options);
          cache.set(type, key, val);
          return val;
        }

        /**
         * Expose compiler, parser and cache on `nanomatch`
         */

        nanomatch.compilers = compilers;
        nanomatch.parsers = parsers;
        nanomatch.cache = cache;

        /**
         * Expose `nanomatch`
         * @type {Function}
         */

        module.exports = nanomatch;
      },
      {
        "./lib/cache": 160,
        "./lib/compilers": 161,
        "./lib/parsers": 162,
        "./lib/utils": 163,
        "extend-shallow": 165,
        "to-regex": 248,
        util: 264,
      },
    ],
    160: [
      function (require, module, exports) {
        arguments[4][137][0].apply(exports, arguments);
      },
      { dup: 137, "fragment-cache": 72 },
    ],
    161: [
      function (require, module, exports) {
        "use strict";

        /**
         * Nanomatch compilers
         */

        module.exports = function (nanomatch, options) {
          function slash() {
            if (options && typeof options.slash === "string") {
              return options.slash;
            }
            if (options && typeof options.slash === "function") {
              return options.slash.call(nanomatch);
            }
            return "\\\\/";
          }

          function star() {
            if (options && typeof options.star === "string") {
              return options.star;
            }
            if (options && typeof options.star === "function") {
              return options.star.call(nanomatch);
            }
            return "[^" + slash() + "]*?";
          }

          var ast = (nanomatch.ast = nanomatch.parser.ast);
          ast.state = nanomatch.parser.state;
          nanomatch.compiler.state = ast.state;
          nanomatch.compiler

            /**
             * Negation / escaping
             */

            .set("not", function (node) {
              var prev = this.prev();
              if (this.options.nonegate === true || prev.type !== "bos") {
                return this.emit("\\" + node.val, node);
              }
              return this.emit(node.val, node);
            })
            .set("escape", function (node) {
              if (this.options.unescape && /^[-\w_.]/.test(node.val)) {
                return this.emit(node.val, node);
              }
              return this.emit("\\" + node.val, node);
            })
            .set("quoted", function (node) {
              return this.emit(node.val, node);
            })

            /**
             * Regex
             */

            .set("dollar", function (node) {
              if (node.parent.type === "bracket") {
                return this.emit(node.val, node);
              }
              return this.emit("\\" + node.val, node);
            })

            /**
             * Dot: "."
             */

            .set("dot", function (node) {
              if (node.dotfiles === true) this.dotfiles = true;
              return this.emit("\\" + node.val, node);
            })

            /**
             * Slashes: "/" and "\"
             */

            .set("backslash", function (node) {
              return this.emit(node.val, node);
            })
            .set("slash", function (node, nodes, i) {
              var val = "[" + slash() + "]";
              var parent = node.parent;
              var prev = this.prev();

              // set "node.hasSlash" to true on all ancestor parens nodes
              while (parent.type === "paren" && !parent.hasSlash) {
                parent.hasSlash = true;
                parent = parent.parent;
              }

              if (prev.addQmark) {
                val += "?";
              }

              // word boundary
              if (node.rest.slice(0, 2) === "\\b") {
                return this.emit(val, node);
              }

              // globstars
              if (node.parsed === "**" || node.parsed === "./**") {
                this.output = "(?:" + this.output;
                return this.emit(val + ")?", node);
              }

              // negation
              if (node.parsed === "!**" && this.options.nonegate !== true) {
                return this.emit(val + "?\\b", node);
              }
              return this.emit(val, node);
            })

            /**
             * Square brackets
             */

            .set("bracket", function (node) {
              var close = node.close;
              var open = !node.escaped ? "[" : "\\[";
              var negated = node.negated;
              var inner = node.inner;
              var val = node.val;

              if (node.escaped === true) {
                inner = inner.replace(/\\?(\W)/g, "\\$1");
                negated = "";
              }

              if (inner === "]-") {
                inner = "\\]\\-";
              }

              if (negated && inner.indexOf(".") === -1) {
                inner += ".";
              }
              if (negated && inner.indexOf("/") === -1) {
                inner += "/";
              }

              val = open + negated + inner + close;
              return this.emit(val, node);
            })

            /**
             * Square: "[.]" (only matches a single character in brackets)
             */

            .set("square", function (node) {
              var val = (/^\W/.test(node.val) ? "\\" : "") + node.val;
              return this.emit(val, node);
            })

            /**
             * Question mark: "?"
             */

            .set("qmark", function (node) {
              var prev = this.prev();
              // don't use "slash" variable so that we always avoid
              // matching backslashes and slashes with a qmark
              var val = "[^.\\\\/]";
              if (
                this.options.dot ||
                (prev.type !== "bos" && prev.type !== "slash")
              ) {
                val = "[^\\\\/]";
              }

              if (node.parsed.slice(-1) === "(") {
                var ch = node.rest.charAt(0);
                if (ch === "!" || ch === "=" || ch === ":") {
                  return this.emit(node.val, node);
                }
              }

              if (node.val.length > 1) {
                val += "{" + node.val.length + "}";
              }
              return this.emit(val, node);
            })

            /**
             * Plus
             */

            .set("plus", function (node) {
              var prev = node.parsed.slice(-1);
              if (prev === "]" || prev === ")") {
                return this.emit(node.val, node);
              }
              if (
                !this.output ||
                (/[?*+]/.test(ch) && node.parent.type !== "bracket")
              ) {
                return this.emit("\\+", node);
              }
              var ch = this.output.slice(-1);
              if (/\w/.test(ch) && !node.inside) {
                return this.emit("+\\+?", node);
              }
              return this.emit("+", node);
            })

            /**
             * globstar: '**'
             */

            .set("globstar", function (node, nodes, i) {
              if (!this.output) {
                this.state.leadingGlobstar = true;
              }

              var prev = this.prev();
              var before = this.prev(2);
              var next = this.next();
              var after = this.next(2);
              var type = prev.type;
              var val = node.val;

              if (prev.type === "slash" && next.type === "slash") {
                if (before.type === "text") {
                  this.output += "?";

                  if (after.type !== "text") {
                    this.output += "\\b";
                  }
                }
              }

              var parsed = node.parsed;
              if (parsed.charAt(0) === "!") {
                parsed = parsed.slice(1);
              }

              var isInside = node.isInside.paren || node.isInside.brace;
              if (parsed && type !== "slash" && type !== "bos" && !isInside) {
                val = star();
              } else {
                val =
                  this.options.dot !== true
                    ? "(?:(?!(?:[" + slash() + "]|^)\\.).)*?"
                    : "(?:(?!(?:[" +
                      slash() +
                      "]|^)(?:\\.{1,2})($|[" +
                      slash() +
                      "]))(?!\\.{2}).)*?";
              }

              if (
                (type === "slash" || type === "bos") &&
                this.options.dot !== true
              ) {
                val = "(?!\\.)" + val;
              }

              if (
                prev.type === "slash" &&
                next.type === "slash" &&
                before.type !== "text"
              ) {
                if (after.type === "text" || after.type === "star") {
                  node.addQmark = true;
                }
              }

              if (this.options.capture) {
                val = "(" + val + ")";
              }

              return this.emit(val, node);
            })

            /**
             * Star: "*"
             */

            .set("star", function (node, nodes, i) {
              var prior = nodes[i - 2] || {};
              var prev = this.prev();
              var next = this.next();
              var type = prev.type;

              function isStart(n) {
                return n.type === "bos" || n.type === "slash";
              }

              if (this.output === "" && this.options.contains !== true) {
                this.output = "(?![" + slash() + "])";
              }

              if (type === "bracket" && this.options.bash === false) {
                var str = next && next.type === "bracket" ? star() : "*?";
                if (!prev.nodes || prev.nodes[1].type !== "posix") {
                  return this.emit(str, node);
                }
              }

              var prefix =
                !this.dotfiles && type !== "text" && type !== "escape"
                  ? this.options.dot
                    ? "(?!(?:^|[" +
                      slash() +
                      "])\\.{1,2}(?:$|[" +
                      slash() +
                      "]))"
                    : "(?!\\.)"
                  : "";

              if (isStart(prev) || (isStart(prior) && type === "not")) {
                if (prefix !== "(?!\\.)") {
                  prefix += "(?!(\\.{2}|\\.[" + slash() + "]))(?=.)";
                } else {
                  prefix += "(?=.)";
                }
              } else if (prefix === "(?!\\.)") {
                prefix = "";
              }

              if (
                prev.type === "not" &&
                prior.type === "bos" &&
                this.options.dot === true
              ) {
                this.output = "(?!\\.)" + this.output;
              }

              var output = prefix + star();
              if (this.options.capture) {
                output = "(" + output + ")";
              }

              return this.emit(output, node);
            })

            /**
             * Text
             */

            .set("text", function (node) {
              return this.emit(node.val, node);
            })

            /**
             * End-of-string
             */

            .set("eos", function (node) {
              var prev = this.prev();
              var val = node.val;

              this.output = "(?:\\.[" + slash() + "](?=.))?" + this.output;
              if (
                this.state.metachar &&
                prev.type !== "qmark" &&
                prev.type !== "slash"
              ) {
                val += this.options.contains
                  ? "[" + slash() + "]?"
                  : "(?:[" + slash() + "]|$)";
              }

              return this.emit(val, node);
            });

          /**
           * Allow custom compilers to be passed on options
           */

          if (options && typeof options.compilers === "function") {
            options.compilers(nanomatch.compiler);
          }
        };
      },
      {},
    ],
    162: [
      function (require, module, exports) {
        "use strict";

        var regexNot = require("regex-not");
        var toRegex = require("to-regex");

        /**
         * Characters to use in negation regex (we want to "not" match
         * characters that are matched by other parsers)
         */

        var cached;
        var NOT_REGEX = "[\\[!*+?$^\"'.\\\\/]+";
        var not = createTextRegex(NOT_REGEX);

        /**
         * Nanomatch parsers
         */

        module.exports = function (nanomatch, options) {
          var parser = nanomatch.parser;
          var opts = parser.options;

          parser.state = {
            slashes: 0,
            paths: [],
          };

          parser.ast.state = parser.state;
          parser

            /**
             * Beginning-of-string
             */

            .capture("prefix", function () {
              if (this.parsed) return;
              var m = this.match(/^\.[\\/]/);
              if (!m) return;
              this.state.strictOpen = !!this.options.strictOpen;
              this.state.addPrefix = true;
            })

            /**
             * Escape: "\\."
             */

            .capture("escape", function () {
              if (this.isInside("bracket")) return;
              var pos = this.position();
              var m = this.match(/^(?:\\(.)|([$^]))/);
              if (!m) return;

              return pos({
                type: "escape",
                val: m[2] || m[1],
              });
            })

            /**
             * Quoted strings
             */

            .capture("quoted", function () {
              var pos = this.position();
              var m = this.match(/^["']/);
              if (!m) return;

              var quote = m[0];
              if (this.input.indexOf(quote) === -1) {
                return pos({
                  type: "escape",
                  val: quote,
                });
              }

              var tok = advanceTo(this.input, quote);
              this.consume(tok.len);

              return pos({
                type: "quoted",
                val: tok.esc,
              });
            })

            /**
             * Negations: "!"
             */

            .capture("not", function () {
              var parsed = this.parsed;
              var pos = this.position();
              var m = this.match(this.notRegex || /^!+/);
              if (!m) return;
              var val = m[0];

              var isNegated = val.length % 2 === 1;
              if (parsed === "" && !isNegated) {
                val = "";
              }

              // if nothing has been parsed, we know `!` is at the start,
              // so we need to wrap the result in a negation regex
              if (
                parsed === "" &&
                isNegated &&
                this.options.nonegate !== true
              ) {
                this.bos.val = "(?!^(?:";
                this.append = ")$).*";
                val = "";
              }
              return pos({
                type: "not",
                val: val,
              });
            })

            /**
             * Dot: "."
             */

            .capture("dot", function () {
              var parsed = this.parsed;
              var pos = this.position();
              var m = this.match(/^\.+/);
              if (!m) return;

              var val = m[0];
              this.state.dot =
                val === "." && (parsed === "" || parsed.slice(-1) === "/");

              return pos({
                type: "dot",
                dotfiles: this.state.dot,
                val: val,
              });
            })

            /**
             * Plus: "+"
             */

            .capture("plus", /^\+(?!\()/)

            /**
             * Question mark: "?"
             */

            .capture("qmark", function () {
              var parsed = this.parsed;
              var pos = this.position();
              var m = this.match(/^\?+(?!\()/);
              if (!m) return;

              this.state.metachar = true;
              this.state.qmark = true;

              return pos({
                type: "qmark",
                parsed: parsed,
                val: m[0],
              });
            })

            /**
             * Globstar: "**"
             */

            .capture("globstar", function () {
              var parsed = this.parsed;
              var pos = this.position();
              var m = this.match(/^\*{2}(?![*(])(?=[,)/]|$)/);
              if (!m) return;

              var type = opts.noglobstar !== true ? "globstar" : "star";
              var node = pos({ type: type, parsed: parsed });
              this.state.metachar = true;

              while (this.input.slice(0, 4) === "/**/") {
                this.input = this.input.slice(3);
              }

              node.isInside = {
                brace: this.isInside("brace"),
                paren: this.isInside("paren"),
              };

              if (type === "globstar") {
                this.state.globstar = true;
                node.val = "**";
              } else {
                this.state.star = true;
                node.val = "*";
              }

              return node;
            })

            /**
             * Star: "*"
             */

            .capture("star", function () {
              var pos = this.position();
              var starRe =
                /^(?:\*(?![*(])|[*]{3,}(?!\()|[*]{2}(?![(/]|$)|\*(?=\*\())/;
              var m = this.match(starRe);
              if (!m) return;

              this.state.metachar = true;
              this.state.star = true;
              return pos({
                type: "star",
                val: m[0],
              });
            })

            /**
             * Slash: "/"
             */

            .capture("slash", function () {
              var pos = this.position();
              var m = this.match(/^\//);
              if (!m) return;

              this.state.slashes++;
              return pos({
                type: "slash",
                val: m[0],
              });
            })

            /**
             * Backslash: "\\"
             */

            .capture("backslash", function () {
              var pos = this.position();
              var m = this.match(/^\\(?![*+?(){}[\]'"])/);
              if (!m) return;

              var val = m[0];

              if (this.isInside("bracket")) {
                val = "\\";
              } else if (val.length > 1) {
                val = "\\\\";
              }

              return pos({
                type: "backslash",
                val: val,
              });
            })

            /**
             * Square: "[.]"
             */

            .capture("square", function () {
              if (this.isInside("bracket")) return;
              var pos = this.position();
              var m = this.match(/^\[([^!^\\])\]/);
              if (!m) return;

              return pos({
                type: "square",
                val: m[1],
              });
            })

            /**
             * Brackets: "[...]" (basic, this can be overridden by other parsers)
             */

            .capture("bracket", function () {
              var pos = this.position();
              var m = this.match(/^(?:\[([!^]?)([^\]]+|\]-)(\]|[^*+?]+)|\[)/);
              if (!m) return;

              var val = m[0];
              var negated = m[1] ? "^" : "";
              var inner = (m[2] || "").replace(/\\\\+/, "\\\\");
              var close = m[3] || "";

              if (m[2] && inner.length < m[2].length) {
                val = val.replace(/\\\\+/, "\\\\");
              }

              var esc = this.input.slice(0, 2);
              if (inner === "" && esc === "\\]") {
                inner += esc;
                this.consume(2);

                var str = this.input;
                var idx = -1;
                var ch;

                while ((ch = str[++idx])) {
                  this.consume(1);
                  if (ch === "]") {
                    close = ch;
                    break;
                  }
                  inner += ch;
                }
              }

              return pos({
                type: "bracket",
                val: val,
                escaped: close !== "]",
                negated: negated,
                inner: inner,
                close: close,
              });
            })

            /**
             * Text
             */

            .capture("text", function () {
              if (this.isInside("bracket")) return;
              var pos = this.position();
              var m = this.match(not);
              if (!m || !m[0]) return;

              return pos({
                type: "text",
                val: m[0],
              });
            });

          /**
           * Allow custom parsers to be passed on options
           */

          if (options && typeof options.parsers === "function") {
            options.parsers(nanomatch.parser);
          }
        };

        /**
         * Advance to the next non-escaped character
         */

        function advanceTo(input, endChar) {
          var ch = input.charAt(0);
          var tok = { len: 1, val: "", esc: "" };
          var idx = 0;

          function advance() {
            if (ch !== "\\") {
              tok.esc += "\\" + ch;
              tok.val += ch;
            }

            ch = input.charAt(++idx);
            tok.len++;

            if (ch === "\\") {
              advance();
              advance();
            }
          }

          while (ch && ch !== endChar) {
            advance();
          }
          return tok;
        }

        /**
         * Create text regex
         */

        function createTextRegex(pattern) {
          if (cached) return cached;
          var opts = { contains: true, strictClose: false };
          var not = regexNot.create(pattern, opts);
          var re = toRegex("^(?:[*]\\((?=.)|" + not + ")", opts);
          return (cached = re);
        }

        /**
         * Expose negation string
         */

        module.exports.not = NOT_REGEX;
      },
      { "regex-not": 184, "to-regex": 248 },
    ],
    163: [
      function (require, module, exports) {
        "use strict";

        var utils = module.exports;
        var path = require("path");

        /**
         * Module dependencies
         */

        var isWindows = require("is-windows")();
        var Snapdragon = require("snapdragon");
        utils.define = require("define-property");
        utils.diff = require("arr-diff");
        utils.extend = require("extend-shallow");
        utils.pick = require("object.pick");
        utils.typeOf = require("kind-of");
        utils.unique = require("array-unique");

        /**
         * Returns true if the given value is effectively an empty string
         */

        utils.isEmptyString = function (val) {
          return String(val) === "" || String(val) === "./";
        };

        /**
         * Returns true if the platform is windows, or `path.sep` is `\\`.
         * This is defined as a function to allow `path.sep` to be set in unit tests,
         * or by the user, if there is a reason to do so.
         * @return {Boolean}
         */

        utils.isWindows = function () {
          return path.sep === "\\" || isWindows === true;
        };

        /**
         * Return the last element from an array
         */

        utils.last = function (arr, n) {
          return arr[arr.length - (n || 1)];
        };

        /**
         * Get the `Snapdragon` instance to use
         */

        utils.instantiate = function (ast, options) {
          var snapdragon;
          // if an instance was created by `.parse`, use that instance
          if (utils.typeOf(ast) === "object" && ast.snapdragon) {
            snapdragon = ast.snapdragon;
            // if the user supplies an instance on options, use that instance
          } else if (utils.typeOf(options) === "object" && options.snapdragon) {
            snapdragon = options.snapdragon;
            // create a new instance
          } else {
            snapdragon = new Snapdragon(options);
          }

          utils.define(snapdragon, "parse", function (str, options) {
            var parsed = Snapdragon.prototype.parse.call(this, str, options);
            parsed.input = str;

            // escape unmatched brace/bracket/parens
            var last = this.parser.stack.pop();
            if (last && this.options.strictErrors !== true) {
              var open = last.nodes[0];
              var inner = last.nodes[1];
              if (last.type === "bracket") {
                if (inner.val.charAt(0) === "[") {
                  inner.val = "\\" + inner.val;
                }
              } else {
                open.val = "\\" + open.val;
                var sibling = open.parent.nodes[1];
                if (sibling.type === "star") {
                  sibling.loose = true;
                }
              }
            }

            // add non-enumerable parser reference
            utils.define(parsed, "parser", this.parser);
            return parsed;
          });

          return snapdragon;
        };

        /**
         * Create the key to use for memoization. The key is generated
         * by iterating over the options and concatenating key-value pairs
         * to the pattern string.
         */

        utils.createKey = function (pattern, options) {
          if (typeof options === "undefined") {
            return pattern;
          }
          var key = pattern;
          for (var prop in options) {
            if (options.hasOwnProperty(prop)) {
              key += ";" + prop + "=" + String(options[prop]);
            }
          }
          return key;
        };

        /**
         * Cast `val` to an array
         * @return {Array}
         */

        utils.arrayify = function (val) {
          if (typeof val === "string") return [val];
          return val ? (Array.isArray(val) ? val : [val]) : [];
        };

        /**
         * Return true if `val` is a non-empty string
         */

        utils.isString = function (val) {
          return typeof val === "string";
        };

        /**
         * Return true if `val` is a non-empty string
         */

        utils.isRegex = function (val) {
          return utils.typeOf(val) === "regexp";
        };

        /**
         * Return true if `val` is a non-empty string
         */

        utils.isObject = function (val) {
          return utils.typeOf(val) === "object";
        };

        /**
         * Escape regex characters in the given string
         */

        utils.escapeRegex = function (str) {
          return str.replace(/[-[\]{}()^$|*+?.\\/\s]/g, "\\$&");
        };

        /**
         * Combines duplicate characters in the provided `input` string.
         * @param {String} `input`
         * @returns {String}
         */

        utils.combineDupes = function (input, patterns) {
          patterns = utils.arrayify(patterns).join("|").split("|");
          patterns = patterns.map(function (s) {
            return s.replace(/\\?([+*\\/])/g, "\\$1");
          });
          var substr = patterns.join("|");
          var regex = new RegExp("(" + substr + ")(?=\\1)", "g");
          return input.replace(regex, "");
        };

        /**
         * Returns true if the given `str` has special characters
         */

        utils.hasSpecialChars = function (str) {
          return /(?:(?:(^|\/)[!.])|[*?+()|[\]{}]|[+@]\()/.test(str);
        };

        /**
         * Normalize slashes in the given filepath.
         *
         * @param {String} `filepath`
         * @return {String}
         */

        utils.toPosixPath = function (str) {
          return str.replace(/\\+/g, "/");
        };

        /**
         * Strip backslashes before special characters in a string.
         *
         * @param {String} `str`
         * @return {String}
         */

        utils.unescape = function (str) {
          return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ""));
        };

        /**
         * Strip the drive letter from a windows filepath
         * @param {String} `fp`
         * @return {String}
         */

        utils.stripDrive = function (fp) {
          return utils.isWindows() ? fp.replace(/^[a-z]:[\\/]+?/i, "/") : fp;
        };

        /**
         * Strip the prefix from a filepath
         * @param {String} `fp`
         * @return {String}
         */

        utils.stripPrefix = function (str) {
          if (
            str.charAt(0) === "." &&
            (str.charAt(1) === "/" || str.charAt(1) === "\\")
          ) {
            return str.slice(2);
          }
          return str;
        };

        /**
         * Returns true if `str` is a common character that doesn't need
         * to be processed to be used for matching.
         * @param {String} `str`
         * @return {Boolean}
         */

        utils.isSimpleChar = function (str) {
          return str.trim() === "" || str === ".";
        };

        /**
         * Returns true if the given str is an escaped or
         * unescaped path character
         */

        utils.isSlash = function (str) {
          return str === "/" || str === "\\/" || str === "\\" || str === "\\\\";
        };

        /**
         * Returns a function that returns true if the given
         * pattern matches or contains a `filepath`
         *
         * @param {String} `pattern`
         * @return {Function}
         */

        utils.matchPath = function (pattern, options) {
          return options && options.contains
            ? utils.containsPattern(pattern, options)
            : utils.equalsPattern(pattern, options);
        };

        /**
         * Returns true if the given (original) filepath or unixified path are equal
         * to the given pattern.
         */

        utils._equals = function (filepath, unixPath, pattern) {
          return pattern === filepath || pattern === unixPath;
        };

        /**
         * Returns true if the given (original) filepath or unixified path contain
         * the given pattern.
         */

        utils._contains = function (filepath, unixPath, pattern) {
          return (
            filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1
          );
        };

        /**
         * Returns a function that returns true if the given
         * pattern is the same as a given `filepath`
         *
         * @param {String} `pattern`
         * @return {Function}
         */

        utils.equalsPattern = function (pattern, options) {
          var unixify = utils.unixify(options);
          options = options || {};

          return function fn(filepath) {
            var equal = utils._equals(filepath, unixify(filepath), pattern);
            if (equal === true || options.nocase !== true) {
              return equal;
            }
            var lower = filepath.toLowerCase();
            return utils._equals(lower, unixify(lower), pattern);
          };
        };

        /**
         * Returns a function that returns true if the given
         * pattern contains a `filepath`
         *
         * @param {String} `pattern`
         * @return {Function}
         */

        utils.containsPattern = function (pattern, options) {
          var unixify = utils.unixify(options);
          options = options || {};

          return function (filepath) {
            var contains = utils._contains(
              filepath,
              unixify(filepath),
              pattern
            );
            if (contains === true || options.nocase !== true) {
              return contains;
            }
            var lower = filepath.toLowerCase();
            return utils._contains(lower, unixify(lower), pattern);
          };
        };

        /**
         * Returns a function that returns true if the given
         * regex matches the `filename` of a file path.
         *
         * @param {RegExp} `re` Matching regex
         * @return {Function}
         */

        utils.matchBasename = function (re) {
          return function (filepath) {
            return re.test(filepath) || re.test(path.basename(filepath));
          };
        };

        /**
         * Returns the given value unchanced.
         * @return {any}
         */

        utils.identity = function (val) {
          return val;
        };

        /**
         * Determines the filepath to return based on the provided options.
         * @return {any}
         */

        utils.value = function (str, unixify, options) {
          if (options && options.unixify === false) {
            return str;
          }
          if (options && typeof options.unixify === "function") {
            return options.unixify(str);
          }
          return unixify(str);
        };

        /**
         * Returns a function that normalizes slashes in a string to forward
         * slashes, strips `./` from beginning of paths, and optionally unescapes
         * special characters.
         * @return {Function}
         */

        utils.unixify = function (options) {
          var opts = options || {};
          return function (filepath) {
            if (opts.stripPrefix !== false) {
              filepath = utils.stripPrefix(filepath);
            }
            if (opts.unescape === true) {
              filepath = utils.unescape(filepath);
            }
            if (opts.unixify === true || utils.isWindows()) {
              filepath = utils.toPosixPath(filepath);
            }
            return filepath;
          };
        };
      },
      {
        "arr-diff": 1,
        "array-unique": 6,
        "define-property": 164,
        "extend-shallow": 165,
        "is-windows": 129,
        "kind-of": 132,
        "object.pick": 175,
        path: 177,
        snapdragon: 204,
      },
    ],
    164: [
      function (require, module, exports) {
        arguments[4][147][0].apply(exports, arguments);
      },
      { dup: 147, "is-descriptor": 117, isobject: 131 },
    ],
    165: [
      function (require, module, exports) {
        arguments[4][148][0].apply(exports, arguments);
      },
      { "assign-symbols": 7, dup: 148, "is-extendable": 166 },
    ],
    166: [
      function (require, module, exports) {
        arguments[4][149][0].apply(exports, arguments);
      },
      { dup: 149, "is-plain-object": 126 },
    ],
    167: [
      function (require, module, exports) {
        "use strict";

        var typeOf = require("kind-of");
        var copyDescriptor = require("copy-descriptor");
        var define = require("define-property");

        /**
         * Copy static properties, prototype properties, and descriptors from one object to another.
         *
         * ```js
         * function App() {}
         * var proto = App.prototype;
         * App.prototype.set = function() {};
         * App.prototype.get = function() {};
         *
         * var obj = {};
         * copy(obj, proto);
         * ```
         * @param {Object} `receiver`
         * @param {Object} `provider`
         * @param {String|Array} `omit` One or more properties to omit
         * @return {Object}
         * @api public
         */

        function copy(receiver, provider, omit) {
          if (!isObject(receiver)) {
            throw new TypeError("expected receiving object to be an object.");
          }
          if (!isObject(provider)) {
            throw new TypeError("expected providing object to be an object.");
          }

          var props = nativeKeys(provider);
          var keys = Object.keys(provider);
          var len = props.length;
          omit = arrayify(omit);

          while (len--) {
            var key = props[len];

            if (has(keys, key)) {
              define(receiver, key, provider[key]);
            } else if (!(key in receiver) && !has(omit, key)) {
              copyDescriptor(receiver, provider, key);
            }
          }
        }

        /**
         * Return true if the given value is an object or function
         */

        function isObject(val) {
          return typeOf(val) === "object" || typeof val === "function";
        }

        /**
         * Returns true if an array has any of the given elements, or an
         * object has any of the give keys.
         *
         * ```js
         * has(['a', 'b', 'c'], 'c');
         * //=> true
         *
         * has(['a', 'b', 'c'], ['c', 'z']);
         * //=> true
         *
         * has({a: 'b', c: 'd'}, ['c', 'z']);
         * //=> true
         * ```
         * @param {Object} `obj`
         * @param {String|Array} `val`
         * @return {Boolean}
         */

        function has(obj, val) {
          val = arrayify(val);
          var len = val.length;

          if (isObject(obj)) {
            for (var key in obj) {
              if (val.indexOf(key) > -1) {
                return true;
              }
            }

            var keys = nativeKeys(obj);
            return has(keys, val);
          }

          if (Array.isArray(obj)) {
            var arr = obj;
            while (len--) {
              if (arr.indexOf(val[len]) > -1) {
                return true;
              }
            }
            return false;
          }

          throw new TypeError("expected an array or object.");
        }

        /**
         * Cast the given value to an array.
         *
         * ```js
         * arrayify('foo');
         * //=> ['foo']
         *
         * arrayify(['foo']);
         * //=> ['foo']
         * ```
         *
         * @param {String|Array} `val`
         * @return {Array}
         */

        function arrayify(val) {
          return val ? (Array.isArray(val) ? val : [val]) : [];
        }

        /**
         * Returns true if a value has a `contructor`
         *
         * ```js
         * hasConstructor({});
         * //=> true
         *
         * hasConstructor(Object.create(null));
         * //=> false
         * ```
         * @param  {Object} `value`
         * @return {Boolean}
         */

        function hasConstructor(val) {
          return isObject(val) && typeof val.constructor !== "undefined";
        }

        /**
         * Get the native `ownPropertyNames` from the constructor of the
         * given `object`. An empty array is returned if the object does
         * not have a constructor.
         *
         * ```js
         * nativeKeys({a: 'b', b: 'c', c: 'd'})
         * //=> ['a', 'b', 'c']
         *
         * nativeKeys(function(){})
         * //=> ['length', 'caller']
         * ```
         *
         * @param  {Object} `obj` Object that has a `constructor`.
         * @return {Array} Array of keys.
         */

        function nativeKeys(val) {
          if (!hasConstructor(val)) return [];
          return Object.getOwnPropertyNames(val);
        }

        /**
         * Expose `copy`
         */

        module.exports = copy;

        /**
         * Expose `copy.has` for tests
         */

        module.exports.has = has;
      },
      { "copy-descriptor": 24, "define-property": 168, "kind-of": 173 },
    ],
    168: [
      function (require, module, exports) {
        arguments[4][15][0].apply(exports, arguments);
      },
      { dup: 15, "is-descriptor": 171 },
    ],
    169: [
      function (require, module, exports) {
        arguments[4][16][0].apply(exports, arguments);
      },
      { dup: 16, "kind-of": 173 },
    ],
    170: [
      function (require, module, exports) {
        arguments[4][18][0].apply(exports, arguments);
      },
      { dup: 18, "kind-of": 173 },
    ],
    171: [
      function (require, module, exports) {
        arguments[4][20][0].apply(exports, arguments);
      },
      {
        dup: 20,
        "is-accessor-descriptor": 169,
        "is-data-descriptor": 170,
        "kind-of": 172,
      },
    ],
    172: [
      function (require, module, exports) {
        arguments[4][5][0].apply(exports, arguments);
      },
      { dup: 5 },
    ],
    173: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    174: [
      function (require, module, exports) {
        /*!
         * object-visit <https://github.com/jonschlinkert/object-visit>
         *
         * Copyright (c) 2015, 2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var isObject = require("isobject");

        module.exports = function visit(thisArg, method, target, val) {
          if (!isObject(thisArg) && typeof thisArg !== "function") {
            throw new Error("object-visit expects `thisArg` to be an object.");
          }

          if (typeof method !== "string") {
            throw new Error(
              "object-visit expects `method` name to be a string"
            );
          }

          if (typeof thisArg[method] !== "function") {
            return thisArg;
          }

          var args = [].slice.call(arguments, 3);
          target = target || {};

          for (var key in target) {
            var arr = [key, target[key]].concat(args);
            thisArg[method].apply(thisArg, arr);
          }
          return thisArg;
        };
      },
      { isobject: 131 },
    ],
    175: [
      function (require, module, exports) {
        /*!
         * object.pick <https://github.com/jonschlinkert/object.pick>
         *
         * Copyright (c) 2014-2015 Jon Schlinkert, contributors.
         * Licensed under the MIT License
         */

        "use strict";

        var isObject = require("isobject");

        module.exports = function pick(obj, keys) {
          if (!isObject(obj) && typeof obj !== "function") {
            return {};
          }

          var res = {};
          if (typeof keys === "string") {
            if (keys in obj) {
              res[keys] = obj[keys];
            }
            return res;
          }

          var len = keys.length;
          var idx = -1;

          while (++idx < len) {
            var key = keys[idx];
            if (key in obj) {
              res[key] = obj[key];
            }
          }
          return res;
        };
      },
      { isobject: 131 },
    ],
    176: [
      function (require, module, exports) {
        /*!
         * pascalcase <https://github.com/jonschlinkert/pascalcase>
         *
         * Copyright (c) 2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        function pascalcase(str) {
          if (typeof str !== "string") {
            throw new TypeError("expected a string.");
          }
          str = str.replace(/([A-Z])/g, " $1");
          if (str.length === 1) {
            return str.toUpperCase();
          }
          str = str.replace(/^[\W_]+|[\W_]+$/g, "").toLowerCase();
          str = str.charAt(0).toUpperCase() + str.slice(1);
          return str.replace(/[\W_]+(\w|$)/g, function (_, ch) {
            return ch.toUpperCase();
          });
        }

        module.exports = pascalcase;
      },
      {},
    ],
    177: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            // 'path' module extracted from Node.js v8.11.1 (only the posix part)
            // transplited with Babel

            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            "use strict";

            function assertPath(path) {
              if (typeof path !== "string") {
                throw new TypeError(
                  "Path must be a string. Received " + JSON.stringify(path)
                );
              }
            }

            // Resolves . and .. elements in a path with directory names
            function normalizeStringPosix(path, allowAboveRoot) {
              var res = "";
              var lastSegmentLength = 0;
              var lastSlash = -1;
              var dots = 0;
              var code;
              for (var i = 0; i <= path.length; ++i) {
                if (i < path.length) code = path.charCodeAt(i);
                else if (code === 47 /*/*/) break;
                else code = 47 /*/*/;
                if (code === 47 /*/*/) {
                  if (lastSlash === i - 1 || dots === 1) {
                    // NOOP
                  } else if (lastSlash !== i - 1 && dots === 2) {
                    if (
                      res.length < 2 ||
                      lastSegmentLength !== 2 ||
                      res.charCodeAt(res.length - 1) !== 46 /*.*/ ||
                      res.charCodeAt(res.length - 2) !== 46 /*.*/
                    ) {
                      if (res.length > 2) {
                        var lastSlashIndex = res.lastIndexOf("/");
                        if (lastSlashIndex !== res.length - 1) {
                          if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                          } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength =
                              res.length - 1 - res.lastIndexOf("/");
                          }
                          lastSlash = i;
                          dots = 0;
                          continue;
                        }
                      } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                      }
                    }
                    if (allowAboveRoot) {
                      if (res.length > 0) res += "/..";
                      else res = "..";
                      lastSegmentLength = 2;
                    }
                  } else {
                    if (res.length > 0)
                      res += "/" + path.slice(lastSlash + 1, i);
                    else res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                  }
                  lastSlash = i;
                  dots = 0;
                } else if (code === 46 /*.*/ && dots !== -1) {
                  ++dots;
                } else {
                  dots = -1;
                }
              }
              return res;
            }

            function _format(sep, pathObject) {
              var dir = pathObject.dir || pathObject.root;
              var base =
                pathObject.base ||
                (pathObject.name || "") + (pathObject.ext || "");
              if (!dir) {
                return base;
              }
              if (dir === pathObject.root) {
                return dir + base;
              }
              return dir + sep + base;
            }

            var posix = {
              // path.resolve([from ...], to)
              resolve: function resolve() {
                var resolvedPath = "";
                var resolvedAbsolute = false;
                var cwd;

                for (
                  var i = arguments.length - 1;
                  i >= -1 && !resolvedAbsolute;
                  i--
                ) {
                  var path;
                  if (i >= 0) path = arguments[i];
                  else {
                    if (cwd === undefined) cwd = process.cwd();
                    path = cwd;
                  }

                  assertPath(path);

                  // Skip empty entries
                  if (path.length === 0) {
                    continue;
                  }

                  resolvedPath = path + "/" + resolvedPath;
                  resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
                }

                // At this point the path should be resolved to a full absolute path, but
                // handle relative paths to be safe (might happen when process.cwd() fails)

                // Normalize the path
                resolvedPath = normalizeStringPosix(
                  resolvedPath,
                  !resolvedAbsolute
                );

                if (resolvedAbsolute) {
                  if (resolvedPath.length > 0) return "/" + resolvedPath;
                  else return "/";
                } else if (resolvedPath.length > 0) {
                  return resolvedPath;
                } else {
                  return ".";
                }
              },

              normalize: function normalize(path) {
                assertPath(path);

                if (path.length === 0) return ".";

                var isAbsolute = path.charCodeAt(0) === 47; /*/*/
                var trailingSeparator =
                  path.charCodeAt(path.length - 1) === 47; /*/*/

                // Normalize the path
                path = normalizeStringPosix(path, !isAbsolute);

                if (path.length === 0 && !isAbsolute) path = ".";
                if (path.length > 0 && trailingSeparator) path += "/";

                if (isAbsolute) return "/" + path;
                return path;
              },

              isAbsolute: function isAbsolute(path) {
                assertPath(path);
                return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
              },

              join: function join() {
                if (arguments.length === 0) return ".";
                var joined;
                for (var i = 0; i < arguments.length; ++i) {
                  var arg = arguments[i];
                  assertPath(arg);
                  if (arg.length > 0) {
                    if (joined === undefined) joined = arg;
                    else joined += "/" + arg;
                  }
                }
                if (joined === undefined) return ".";
                return posix.normalize(joined);
              },

              relative: function relative(from, to) {
                assertPath(from);
                assertPath(to);

                if (from === to) return "";

                from = posix.resolve(from);
                to = posix.resolve(to);

                if (from === to) return "";

                // Trim any leading backslashes
                var fromStart = 1;
                for (; fromStart < from.length; ++fromStart) {
                  if (from.charCodeAt(fromStart) !== 47 /*/*/) break;
                }
                var fromEnd = from.length;
                var fromLen = fromEnd - fromStart;

                // Trim any leading backslashes
                var toStart = 1;
                for (; toStart < to.length; ++toStart) {
                  if (to.charCodeAt(toStart) !== 47 /*/*/) break;
                }
                var toEnd = to.length;
                var toLen = toEnd - toStart;

                // Compare paths to find the longest common path from root
                var length = fromLen < toLen ? fromLen : toLen;
                var lastCommonSep = -1;
                var i = 0;
                for (; i <= length; ++i) {
                  if (i === length) {
                    if (toLen > length) {
                      if (to.charCodeAt(toStart + i) === 47 /*/*/) {
                        // We get here if `from` is the exact base path for `to`.
                        // For example: from='/foo/bar'; to='/foo/bar/baz'
                        return to.slice(toStart + i + 1);
                      } else if (i === 0) {
                        // We get here if `from` is the root
                        // For example: from='/'; to='/foo'
                        return to.slice(toStart + i);
                      }
                    } else if (fromLen > length) {
                      if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
                        // We get here if `to` is the exact base path for `from`.
                        // For example: from='/foo/bar/baz'; to='/foo/bar'
                        lastCommonSep = i;
                      } else if (i === 0) {
                        // We get here if `to` is the root.
                        // For example: from='/foo'; to='/'
                        lastCommonSep = 0;
                      }
                    }
                    break;
                  }
                  var fromCode = from.charCodeAt(fromStart + i);
                  var toCode = to.charCodeAt(toStart + i);
                  if (fromCode !== toCode) break;
                  else if (fromCode === 47 /*/*/) lastCommonSep = i;
                }

                var out = "";
                // Generate the relative path based on the path difference between `to`
                // and `from`
                for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
                  if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
                    if (out.length === 0) out += "..";
                    else out += "/..";
                  }
                }

                // Lastly, append the rest of the destination (`to`) path that comes after
                // the common path parts
                if (out.length > 0)
                  return out + to.slice(toStart + lastCommonSep);
                else {
                  toStart += lastCommonSep;
                  if (to.charCodeAt(toStart) === 47 /*/*/) ++toStart;
                  return to.slice(toStart);
                }
              },

              _makeLong: function _makeLong(path) {
                return path;
              },

              dirname: function dirname(path) {
                assertPath(path);
                if (path.length === 0) return ".";
                var code = path.charCodeAt(0);
                var hasRoot = code === 47; /*/*/
                var end = -1;
                var matchedSlash = true;
                for (var i = path.length - 1; i >= 1; --i) {
                  code = path.charCodeAt(i);
                  if (code === 47 /*/*/) {
                    if (!matchedSlash) {
                      end = i;
                      break;
                    }
                  } else {
                    // We saw the first non-path separator
                    matchedSlash = false;
                  }
                }

                if (end === -1) return hasRoot ? "/" : ".";
                if (hasRoot && end === 1) return "//";
                return path.slice(0, end);
              },

              basename: function basename(path, ext) {
                if (ext !== undefined && typeof ext !== "string")
                  throw new TypeError('"ext" argument must be a string');
                assertPath(path);

                var start = 0;
                var end = -1;
                var matchedSlash = true;
                var i;

                if (
                  ext !== undefined &&
                  ext.length > 0 &&
                  ext.length <= path.length
                ) {
                  if (ext.length === path.length && ext === path) return "";
                  var extIdx = ext.length - 1;
                  var firstNonSlashEnd = -1;
                  for (i = path.length - 1; i >= 0; --i) {
                    var code = path.charCodeAt(i);
                    if (code === 47 /*/*/) {
                      // If we reached a path separator that was not part of a set of path
                      // separators at the end of the string, stop now
                      if (!matchedSlash) {
                        start = i + 1;
                        break;
                      }
                    } else {
                      if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                      }
                      if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                          if (--extIdx === -1) {
                            // We matched the extension, so mark this as the end of our path
                            // component
                            end = i;
                          }
                        } else {
                          // Extension does not match, so our result is the entire path
                          // component
                          extIdx = -1;
                          end = firstNonSlashEnd;
                        }
                      }
                    }
                  }

                  if (start === end) end = firstNonSlashEnd;
                  else if (end === -1) end = path.length;
                  return path.slice(start, end);
                } else {
                  for (i = path.length - 1; i >= 0; --i) {
                    if (path.charCodeAt(i) === 47 /*/*/) {
                      // If we reached a path separator that was not part of a set of path
                      // separators at the end of the string, stop now
                      if (!matchedSlash) {
                        start = i + 1;
                        break;
                      }
                    } else if (end === -1) {
                      // We saw the first non-path separator, mark this as the end of our
                      // path component
                      matchedSlash = false;
                      end = i + 1;
                    }
                  }

                  if (end === -1) return "";
                  return path.slice(start, end);
                }
              },

              extname: function extname(path) {
                assertPath(path);
                var startDot = -1;
                var startPart = 0;
                var end = -1;
                var matchedSlash = true;
                // Track the state of characters (if any) we see before our first dot and
                // after any path separator we find
                var preDotState = 0;
                for (var i = path.length - 1; i >= 0; --i) {
                  var code = path.charCodeAt(i);
                  if (code === 47 /*/*/) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                      startPart = i + 1;
                      break;
                    }
                    continue;
                  }
                  if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // extension
                    matchedSlash = false;
                    end = i + 1;
                  }
                  if (code === 46 /*.*/) {
                    // If this is our first dot, mark it as the start of our extension
                    if (startDot === -1) startDot = i;
                    else if (preDotState !== 1) preDotState = 1;
                  } else if (startDot !== -1) {
                    // We saw a non-dot and non-path separator before our dot, so we should
                    // have a good chance at having a non-empty extension
                    preDotState = -1;
                  }
                }

                if (
                  startDot === -1 ||
                  end === -1 ||
                  // We saw a non-dot character immediately before the dot
                  preDotState === 0 ||
                  // The (right-most) trimmed path component is exactly '..'
                  (preDotState === 1 &&
                    startDot === end - 1 &&
                    startDot === startPart + 1)
                ) {
                  return "";
                }
                return path.slice(startDot, end);
              },

              format: function format(pathObject) {
                if (pathObject === null || typeof pathObject !== "object") {
                  throw new TypeError(
                    'The "pathObject" argument must be of type Object. Received type ' +
                      typeof pathObject
                  );
                }
                return _format("/", pathObject);
              },

              parse: function parse(path) {
                assertPath(path);

                var ret = { root: "", dir: "", base: "", ext: "", name: "" };
                if (path.length === 0) return ret;
                var code = path.charCodeAt(0);
                var isAbsolute = code === 47; /*/*/
                var start;
                if (isAbsolute) {
                  ret.root = "/";
                  start = 1;
                } else {
                  start = 0;
                }
                var startDot = -1;
                var startPart = 0;
                var end = -1;
                var matchedSlash = true;
                var i = path.length - 1;

                // Track the state of characters (if any) we see before our first dot and
                // after any path separator we find
                var preDotState = 0;

                // Get non-dir info
                for (; i >= start; --i) {
                  code = path.charCodeAt(i);
                  if (code === 47 /*/*/) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                      startPart = i + 1;
                      break;
                    }
                    continue;
                  }
                  if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // extension
                    matchedSlash = false;
                    end = i + 1;
                  }
                  if (code === 46 /*.*/) {
                    // If this is our first dot, mark it as the start of our extension
                    if (startDot === -1) startDot = i;
                    else if (preDotState !== 1) preDotState = 1;
                  } else if (startDot !== -1) {
                    // We saw a non-dot and non-path separator before our dot, so we should
                    // have a good chance at having a non-empty extension
                    preDotState = -1;
                  }
                }

                if (
                  startDot === -1 ||
                  end === -1 ||
                  // We saw a non-dot character immediately before the dot
                  preDotState === 0 ||
                  // The (right-most) trimmed path component is exactly '..'
                  (preDotState === 1 &&
                    startDot === end - 1 &&
                    startDot === startPart + 1)
                ) {
                  if (end !== -1) {
                    if (startPart === 0 && isAbsolute)
                      ret.base = ret.name = path.slice(1, end);
                    else ret.base = ret.name = path.slice(startPart, end);
                  }
                } else {
                  if (startPart === 0 && isAbsolute) {
                    ret.name = path.slice(1, startDot);
                    ret.base = path.slice(1, end);
                  } else {
                    ret.name = path.slice(startPart, startDot);
                    ret.base = path.slice(startPart, end);
                  }
                  ret.ext = path.slice(startDot, end);
                }

                if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
                else if (isAbsolute) ret.dir = "/";

                return ret;
              },

              sep: "/",
              delimiter: ":",
              win32: null,
              posix: null,
            };

            posix.posix = posix;

            module.exports = posix;
          }.call(this));
        }.call(this, require("_process")));
      },
      { _process: 179 },
    ],
    178: [
      function (require, module, exports) {
        "use strict";

        /**
         * POSIX character classes
         */

        module.exports = {
          alnum: "a-zA-Z0-9",
          alpha: "a-zA-Z",
          ascii: "\\x00-\\x7F",
          blank: " \\t",
          cntrl: "\\x00-\\x1F\\x7F",
          digit: "0-9",
          graph: "\\x21-\\x7E",
          lower: "a-z",
          print: "\\x20-\\x7E ",
          punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
          space: " \\t\\r\\n\\v\\f",
          upper: "A-Z",
          word: "A-Za-z0-9_",
          xdigit: "A-Fa-f0-9",
        };
      },
      {},
    ],
    179: [
      function (require, module, exports) {
        // shim for using process in browser
        var process = (module.exports = {});

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function () {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
          }
          // if setTimeout wasn't available but was latter defined
          if (
            (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
            setTimeout
          ) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
          }
          // if clearTimeout wasn't available but was latter defined
          if (
            (cachedClearTimeout === defaultClearTimeout ||
              !cachedClearTimeout) &&
            clearTimeout
          ) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }

        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;

          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }

        process.nextTick = function (fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };

        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function () {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ""; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function (name) {
          return [];
        };

        process.binding = function (name) {
          throw new Error("process.binding is not supported");
        };

        process.cwd = function () {
          return "/";
        };
        process.chdir = function (dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function () {
          return 0;
        };
      },
      {},
    ],
    180: [
      function (require, module, exports) {
        (function (global) {
          (function () {
            /*! https://mths.be/punycode v1.3.2 by @mathias */
            (function (root) {
              /** Detect free variables */
              var freeExports =
                typeof exports == "object" &&
                exports &&
                !exports.nodeType &&
                exports;
              var freeModule =
                typeof module == "object" &&
                module &&
                !module.nodeType &&
                module;
              var freeGlobal = typeof global == "object" && global;
              if (
                freeGlobal.global === freeGlobal ||
                freeGlobal.window === freeGlobal ||
                freeGlobal.self === freeGlobal
              ) {
                root = freeGlobal;
              }

              /**
               * The `punycode` object.
               * @name punycode
               * @type Object
               */
              var punycode,
                /** Highest positive signed 32-bit float value */
                maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
                /** Bootstring parameters */
                base = 36,
                tMin = 1,
                tMax = 26,
                skew = 38,
                damp = 700,
                initialBias = 72,
                initialN = 128, // 0x80
                delimiter = "-", // '\x2D'
                /** Regular expressions */
                regexPunycode = /^xn--/,
                regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
                regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
                /** Error messages */
                errors = {
                  overflow: "Overflow: input needs wider integers to process",
                  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                  "invalid-input": "Invalid input",
                },
                /** Convenience shortcuts */
                baseMinusTMin = base - tMin,
                floor = Math.floor,
                stringFromCharCode = String.fromCharCode,
                /** Temporary variable */
                key;

              /*--------------------------------------------------------------------------*/

              /**
               * A generic error utility function.
               * @private
               * @param {String} type The error type.
               * @returns {Error} Throws a `RangeError` with the applicable error message.
               */
              function error(type) {
                throw RangeError(errors[type]);
              }

              /**
               * A generic `Array#map` utility function.
               * @private
               * @param {Array} array The array to iterate over.
               * @param {Function} callback The function that gets called for every array
               * item.
               * @returns {Array} A new array of values returned by the callback function.
               */
              function map(array, fn) {
                var length = array.length;
                var result = [];
                while (length--) {
                  result[length] = fn(array[length]);
                }
                return result;
              }

              /**
               * A simple `Array#map`-like wrapper to work with domain name strings or email
               * addresses.
               * @private
               * @param {String} domain The domain name or email address.
               * @param {Function} callback The function that gets called for every
               * character.
               * @returns {Array} A new string of characters returned by the callback
               * function.
               */
              function mapDomain(string, fn) {
                var parts = string.split("@");
                var result = "";
                if (parts.length > 1) {
                  // In email addresses, only the domain name should be punycoded. Leave
                  // the local part (i.e. everything up to `@`) intact.
                  result = parts[0] + "@";
                  string = parts[1];
                }
                // Avoid `split(regex)` for IE8 compatibility. See #17.
                string = string.replace(regexSeparators, "\x2E");
                var labels = string.split(".");
                var encoded = map(labels, fn).join(".");
                return result + encoded;
              }

              /**
               * Creates an array containing the numeric code points of each Unicode
               * character in the string. While JavaScript uses UCS-2 internally,
               * this function will convert a pair of surrogate halves (each of which
               * UCS-2 exposes as separate characters) into a single code point,
               * matching UTF-16.
               * @see `punycode.ucs2.encode`
               * @see <https://mathiasbynens.be/notes/javascript-encoding>
               * @memberOf punycode.ucs2
               * @name decode
               * @param {String} string The Unicode input string (UCS-2).
               * @returns {Array} The new array of code points.
               */
              function ucs2decode(string) {
                var output = [],
                  counter = 0,
                  length = string.length,
                  value,
                  extra;
                while (counter < length) {
                  value = string.charCodeAt(counter++);
                  if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                    // high surrogate, and there is a next character
                    extra = string.charCodeAt(counter++);
                    if ((extra & 0xfc00) == 0xdc00) {
                      // low surrogate
                      output.push(
                        ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000
                      );
                    } else {
                      // unmatched surrogate; only append this code unit, in case the next
                      // code unit is the high surrogate of a surrogate pair
                      output.push(value);
                      counter--;
                    }
                  } else {
                    output.push(value);
                  }
                }
                return output;
              }

              /**
               * Creates a string based on an array of numeric code points.
               * @see `punycode.ucs2.decode`
               * @memberOf punycode.ucs2
               * @name encode
               * @param {Array} codePoints The array of numeric code points.
               * @returns {String} The new Unicode string (UCS-2).
               */
              function ucs2encode(array) {
                return map(array, function (value) {
                  var output = "";
                  if (value > 0xffff) {
                    value -= 0x10000;
                    output += stringFromCharCode(
                      ((value >>> 10) & 0x3ff) | 0xd800
                    );
                    value = 0xdc00 | (value & 0x3ff);
                  }
                  output += stringFromCharCode(value);
                  return output;
                }).join("");
              }

              /**
               * Converts a basic code point into a digit/integer.
               * @see `digitToBasic()`
               * @private
               * @param {Number} codePoint The basic numeric code point value.
               * @returns {Number} The numeric value of a basic code point (for use in
               * representing integers) in the range `0` to `base - 1`, or `base` if
               * the code point does not represent a value.
               */
              function basicToDigit(codePoint) {
                if (codePoint - 48 < 10) {
                  return codePoint - 22;
                }
                if (codePoint - 65 < 26) {
                  return codePoint - 65;
                }
                if (codePoint - 97 < 26) {
                  return codePoint - 97;
                }
                return base;
              }

              /**
               * Converts a digit/integer into a basic code point.
               * @see `basicToDigit()`
               * @private
               * @param {Number} digit The numeric value of a basic code point.
               * @returns {Number} The basic code point whose value (when used for
               * representing integers) is `digit`, which needs to be in the range
               * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
               * used; else, the lowercase form is used. The behavior is undefined
               * if `flag` is non-zero and `digit` has no uppercase form.
               */
              function digitToBasic(digit, flag) {
                //  0..25 map to ASCII a..z or A..Z
                // 26..35 map to ASCII 0..9
                return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
              }

              /**
               * Bias adaptation function as per section 3.4 of RFC 3492.
               * http://tools.ietf.org/html/rfc3492#section-3.4
               * @private
               */
              function adapt(delta, numPoints, firstTime) {
                var k = 0;
                delta = firstTime ? floor(delta / damp) : delta >> 1;
                delta += floor(delta / numPoints);
                for (
                  ;
                  /* no initialization */ delta > (baseMinusTMin * tMax) >> 1;
                  k += base
                ) {
                  delta = floor(delta / baseMinusTMin);
                }
                return floor(
                  k + ((baseMinusTMin + 1) * delta) / (delta + skew)
                );
              }

              /**
               * Converts a Punycode string of ASCII-only symbols to a string of Unicode
               * symbols.
               * @memberOf punycode
               * @param {String} input The Punycode string of ASCII-only symbols.
               * @returns {String} The resulting string of Unicode symbols.
               */
              function decode(input) {
                // Don't use UCS-2
                var output = [],
                  inputLength = input.length,
                  out,
                  i = 0,
                  n = initialN,
                  bias = initialBias,
                  basic,
                  j,
                  index,
                  oldi,
                  w,
                  k,
                  digit,
                  t,
                  /** Cached calculation results */
                  baseMinusT;

                // Handle the basic code points: let `basic` be the number of input code
                // points before the last delimiter, or `0` if there is none, then copy
                // the first basic code points to the output.

                basic = input.lastIndexOf(delimiter);
                if (basic < 0) {
                  basic = 0;
                }

                for (j = 0; j < basic; ++j) {
                  // if it's not a basic code point
                  if (input.charCodeAt(j) >= 0x80) {
                    error("not-basic");
                  }
                  output.push(input.charCodeAt(j));
                }

                // Main decoding loop: start just after the last delimiter if any basic code
                // points were copied; start at the beginning otherwise.

                for (
                  index = basic > 0 ? basic + 1 : 0;
                  index < inputLength /* no final expression */;

                ) {
                  // `index` is the index of the next character to be consumed.
                  // Decode a generalized variable-length integer into `delta`,
                  // which gets added to `i`. The overflow checking is easier
                  // if we increase `i` as we go, then subtract off its starting
                  // value at the end to obtain `delta`.
                  for (
                    oldi = i, w = 1, k = base /* no condition */;
                    ;
                    k += base
                  ) {
                    if (index >= inputLength) {
                      error("invalid-input");
                    }

                    digit = basicToDigit(input.charCodeAt(index++));

                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                      error("overflow");
                    }

                    i += digit * w;
                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                    if (digit < t) {
                      break;
                    }

                    baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                      error("overflow");
                    }

                    w *= baseMinusT;
                  }

                  out = output.length + 1;
                  bias = adapt(i - oldi, out, oldi == 0);

                  // `i` was supposed to wrap around from `out` to `0`,
                  // incrementing `n` each time, so we'll fix that now:
                  if (floor(i / out) > maxInt - n) {
                    error("overflow");
                  }

                  n += floor(i / out);
                  i %= out;

                  // Insert `n` at position `i` of the output
                  output.splice(i++, 0, n);
                }

                return ucs2encode(output);
              }

              /**
               * Converts a string of Unicode symbols (e.g. a domain name label) to a
               * Punycode string of ASCII-only symbols.
               * @memberOf punycode
               * @param {String} input The string of Unicode symbols.
               * @returns {String} The resulting Punycode string of ASCII-only symbols.
               */
              function encode(input) {
                var n,
                  delta,
                  handledCPCount,
                  basicLength,
                  bias,
                  j,
                  m,
                  q,
                  k,
                  t,
                  currentValue,
                  output = [],
                  /** `inputLength` will hold the number of code points in `input`. */
                  inputLength,
                  /** Cached calculation results */
                  handledCPCountPlusOne,
                  baseMinusT,
                  qMinusT;

                // Convert the input in UCS-2 to Unicode
                input = ucs2decode(input);

                // Cache the length
                inputLength = input.length;

                // Initialize the state
                n = initialN;
                delta = 0;
                bias = initialBias;

                // Handle the basic code points
                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue < 0x80) {
                    output.push(stringFromCharCode(currentValue));
                  }
                }

                handledCPCount = basicLength = output.length;

                // `handledCPCount` is the number of code points that have been handled;
                // `basicLength` is the number of basic code points.

                // Finish the basic string - if it is not empty - with a delimiter
                if (basicLength) {
                  output.push(delimiter);
                }

                // Main encoding loop:
                while (handledCPCount < inputLength) {
                  // All non-basic code points < n have been handled already. Find the next
                  // larger one:
                  for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue >= n && currentValue < m) {
                      m = currentValue;
                    }
                  }

                  // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                  // but guard against overflow
                  handledCPCountPlusOne = handledCPCount + 1;
                  if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error("overflow");
                  }

                  delta += (m - n) * handledCPCountPlusOne;
                  n = m;

                  for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];

                    if (currentValue < n && ++delta > maxInt) {
                      error("overflow");
                    }

                    if (currentValue == n) {
                      // Represent delta as a generalized variable-length integer
                      for (
                        q = delta, k = base /* no condition */;
                        ;
                        k += base
                      ) {
                        t =
                          k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (q < t) {
                          break;
                        }
                        qMinusT = q - t;
                        baseMinusT = base - t;
                        output.push(
                          stringFromCharCode(
                            digitToBasic(t + (qMinusT % baseMinusT), 0)
                          )
                        );
                        q = floor(qMinusT / baseMinusT);
                      }

                      output.push(stringFromCharCode(digitToBasic(q, 0)));
                      bias = adapt(
                        delta,
                        handledCPCountPlusOne,
                        handledCPCount == basicLength
                      );
                      delta = 0;
                      ++handledCPCount;
                    }
                  }

                  ++delta;
                  ++n;
                }
                return output.join("");
              }

              /**
               * Converts a Punycode string representing a domain name or an email address
               * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
               * it doesn't matter if you call it on a string that has already been
               * converted to Unicode.
               * @memberOf punycode
               * @param {String} input The Punycoded domain name or email address to
               * convert to Unicode.
               * @returns {String} The Unicode representation of the given Punycode
               * string.
               */
              function toUnicode(input) {
                return mapDomain(input, function (string) {
                  return regexPunycode.test(string)
                    ? decode(string.slice(4).toLowerCase())
                    : string;
                });
              }

              /**
               * Converts a Unicode string representing a domain name or an email address to
               * Punycode. Only the non-ASCII parts of the domain name will be converted,
               * i.e. it doesn't matter if you call it with a domain that's already in
               * ASCII.
               * @memberOf punycode
               * @param {String} input The domain name or email address to convert, as a
               * Unicode string.
               * @returns {String} The Punycode representation of the given domain name or
               * email address.
               */
              function toASCII(input) {
                return mapDomain(input, function (string) {
                  return regexNonASCII.test(string)
                    ? "xn--" + encode(string)
                    : string;
                });
              }

              /*--------------------------------------------------------------------------*/

              /** Define the public API */
              punycode = {
                /**
                 * A string representing the current Punycode.js version number.
                 * @memberOf punycode
                 * @type String
                 */
                version: "1.3.2",
                /**
                 * An object of methods to convert from JavaScript's internal character
                 * representation (UCS-2) to Unicode code points, and back.
                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                 * @memberOf punycode
                 * @type Object
                 */
                ucs2: {
                  decode: ucs2decode,
                  encode: ucs2encode,
                },
                decode: decode,
                encode: encode,
                toASCII: toASCII,
                toUnicode: toUnicode,
              };

              /** Expose `punycode` */
              // Some AMD build optimizers, like r.js, check for specific condition patterns
              // like the following:
              if (
                typeof define == "function" &&
                typeof define.amd == "object" &&
                define.amd
              ) {
                define("punycode", function () {
                  return punycode;
                });
              } else if (freeExports && freeModule) {
                if (module.exports == freeExports) {
                  // in Node.js or RingoJS v0.8.0+
                  freeModule.exports = punycode;
                } else {
                  // in Narwhal or RingoJS v0.7.0-
                  for (key in punycode) {
                    punycode.hasOwnProperty(key) &&
                      (freeExports[key] = punycode[key]);
                  }
                }
              } else {
                // in Rhino or a web browser
                root.punycode = punycode;
              }
            })(this);
          }.call(this));
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      {},
    ],
    181: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict";

        // If obj.hasOwnProperty has been overridden, then calling
        // obj.hasOwnProperty(prop) will break.
        // See: https://github.com/joyent/node/issues/1707
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }

        module.exports = function (qs, sep, eq, options) {
          sep = sep || "&";
          eq = eq || "=";
          var obj = {};

          if (typeof qs !== "string" || qs.length === 0) {
            return obj;
          }

          var regexp = /\+/g;
          qs = qs.split(sep);

          var maxKeys = 1000;
          if (options && typeof options.maxKeys === "number") {
            maxKeys = options.maxKeys;
          }

          var len = qs.length;
          // maxKeys <= 0 means that we should not limit keys count
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }

          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, "%20"),
              idx = x.indexOf(eq),
              kstr,
              vstr,
              k,
              v;

            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = "";
            }

            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);

            if (!hasOwnProperty(obj, k)) {
              obj[k] = v;
            } else if (isArray(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [obj[k], v];
            }
          }

          return obj;
        };

        var isArray =
          Array.isArray ||
          function (xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
          };
      },
      {},
    ],
    182: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict";

        var stringifyPrimitive = function (v) {
          switch (typeof v) {
            case "string":
              return v;

            case "boolean":
              return v ? "true" : "false";

            case "number":
              return isFinite(v) ? v : "";

            default:
              return "";
          }
        };

        module.exports = function (obj, sep, eq, name) {
          sep = sep || "&";
          eq = eq || "=";
          if (obj === null) {
            obj = undefined;
          }

          if (typeof obj === "object") {
            return map(objectKeys(obj), function (k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (isArray(obj[k])) {
                return map(obj[k], function (v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).join(sep);
          }

          if (!name) return "";
          return (
            encodeURIComponent(stringifyPrimitive(name)) +
            eq +
            encodeURIComponent(stringifyPrimitive(obj))
          );
        };

        var isArray =
          Array.isArray ||
          function (xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
          };

        function map(xs, f) {
          if (xs.map) return xs.map(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
          }
          return res;
        }

        var objectKeys =
          Object.keys ||
          function (obj) {
            var res = [];
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
            }
            return res;
          };
      },
      {},
    ],
    183: [
      function (require, module, exports) {
        "use strict";

        exports.decode = exports.parse = require("./decode");
        exports.encode = exports.stringify = require("./encode");
      },
      { "./decode": 181, "./encode": 182 },
    ],
    184: [
      function (require, module, exports) {
        "use strict";

        var extend = require("extend-shallow");
        var safe = require("safe-regex");

        /**
 * The main export is a function that takes a `pattern` string and an `options` object.
 *
 * ```js
 & var not = require('regex-not');
 & console.log(not('foo'));
 & //=> /^(?:(?!^(?:foo)$).)*$/
 * ```
 *
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {RegExp} Converts the given `pattern` to a regex using the specified `options`.
 * @api public
 */

        function toRegex(pattern, options) {
          return new RegExp(toRegex.create(pattern, options));
        }

        /**
 * Create a regex-compatible string from the given `pattern` and `options`.
 *
 * ```js
 & var not = require('regex-not');
 & console.log(not.create('foo'));
 & //=> '^(?:(?!^(?:foo)$).)*$'
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

        toRegex.create = function (pattern, options) {
          if (typeof pattern !== "string") {
            throw new TypeError("expected a string");
          }

          var opts = extend({}, options);
          if (opts.contains === true) {
            opts.strictNegate = false;
          }

          var open = opts.strictOpen !== false ? "^" : "";
          var close = opts.strictClose !== false ? "$" : "";
          var endChar = opts.endChar ? opts.endChar : "+";
          var str = pattern;

          if (opts.strictNegate === false) {
            str = "(?:(?!(?:" + pattern + ")).)" + endChar;
          } else {
            str = "(?:(?!^(?:" + pattern + ")$).)" + endChar;
          }

          var res = open + str + close;
          if (opts.safe === true && safe(res) === false) {
            throw new Error("potentially unsafe regular expression: " + res);
          }

          return res;
        };

        /**
         * Expose `toRegex`
         */

        module.exports = toRegex;
      },
      { "extend-shallow": 185, "safe-regex": 197 },
    ],
    185: [
      function (require, module, exports) {
        arguments[4][148][0].apply(exports, arguments);
      },
      { "assign-symbols": 7, dup: 148, "is-extendable": 186 },
    ],
    186: [
      function (require, module, exports) {
        arguments[4][149][0].apply(exports, arguments);
      },
      { dup: 149, "is-plain-object": 126 },
    ],
    187: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            "use strict";

            var isObject = require("isobject");
            var path = require("path");
            var fs = require("fs");

            /**
             * Expose `relative`
             */

            module.exports = relative;

            /**
             * Get the relative path from `a` to `b`.
             */

            function relative(a, b, stat) {
              if (typeof a !== "string") {
                throw new TypeError("relative expects a string.");
              }

              if (a == "" && !b) return a;

              var len = arguments.length;
              if (len === 1) {
                b = a;
                a = process.cwd();
                stat = null;
              }

              if (len === 2 && typeof b === "boolean") {
                b = a;
                a = process.cwd();
                stat = true;
              }

              if (len === 2 && typeof b === "object") {
                stat = b;
                b = a;
                a = process.cwd();
              }

              var origB = b;

              // see if a slash exists before normalizing
              var slashA = endsWith(a, "/");
              var slashB = endsWith(b, "/");

              a = unixify(a);
              b = unixify(b);

              // if `a` had a slash, add it back
              if (slashA) {
                a = a + "/";
              }

              if (isFile(a, stat)) {
                a = path.dirname(a);
              }

              var res = path.relative(a, b);
              if (res === "") {
                return ".";
              }

              // if `b` originally had a slash, and the path ends
              // with `b` missing a slash, then re-add the slash.
              var noslash = trimEnd(origB, "/");
              if (slashB && (res === noslash || endsWith(res, noslash))) {
                res = res + "/";
              }
              return res;
            }

            /**
             * Get the path relative to the given base path.
             */

            relative.toBase = function toBase(base, fp) {
              base = unixify(base);
              fp = unixify(fp);

              var res = fp.slice(base.length);
              if (res.charAt(0) === "/") {
                res = res.slice(1);
              }
              return res;
            };

            /**
             * Normalize slashes in paths to unix slashes. This is necessary since
             * paths are not calculated the same by node.js when
             * windows paths are used.
             */

            function unixify(str) {
              return str.replace(/[\\\/]+/g, "/");
            }

            /**
             * Remove the given character from the path.
             */

            function trimEnd(fp, ch) {
              return fp.slice(0, fp.length - ch.length);
            }

            /**
             * Does the path end with the given `ch`aracter?
             */

            function endsWith(fp, ch) {
              return fp.slice(-ch.length)[0] === ch;
            }

            /**
             * If `fp` exists, return a `stat` object,
             * otherwise return `null`.
             */

            function tryStats(fp) {
              try {
                return fs.statSync(fp);
              } catch (err) {}
              return null;
            }

            /**
             * Returns true if `fp` is a directory. To use a `fs`
             * stat object to actually check the file system,
             * either pass `true` as the second arg, or pass your
             * own stat object as the second arg.
             *
             * @param  {String} `fp`
             * @param  {Boolean|Object} `stat`
             * @return {Boolean}
             */

            function isDir(fp, stat) {
              if (endsWith(fp, "/")) {
                return true;
              }

              if (stat === null) {
                // try to get the directory info if it hasn't been done yet
                // to ensure directories containing dots are well handle
                stat = tryStats(fp);
              }

              if (isObject(stat) && typeof stat.isDirectory === "function") {
                return stat.isDirectory();
              }

              var segs = fp.split("/");
              var last = segs[segs.length - 1];
              if (last && last.indexOf(".") !== -1) {
                return false;
              }
              return true;
            }

            /**
             * Return true if `fp` looks like a file, or
             * actually is a file if fs.stat is used.
             */

            function isFile(fp, stat) {
              if (stat === true) {
                stat = tryStats(fp);
              }
              return !isDir(fp, stat);
            }
          }.call(this));
        }.call(this, require("_process")));
      },
      { _process: 179, fs: 10, isobject: 188, path: 177 },
    ],
    188: [
      function (require, module, exports) {
        /*!
         * isobject <https://github.com/jonschlinkert/isobject>
         *
         * Copyright (c) 2014-2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        var isArray = require("isarray");

        module.exports = function isObject(val) {
          return (
            val != null && typeof val === "object" && isArray(val) === false
          );
        };
      },
      { isarray: 130 },
    ],
    189: [
      function (require, module, exports) {
        /*!
         * repeat-element <https://github.com/jonschlinkert/repeat-element>
         *
         * Copyright (c) 2015-present, Jon Schlinkert.
         * Licensed under the MIT license.
         */

        "use strict";

        module.exports = function repeat(ele, num) {
          if (Array.prototype.fill) {
            return new Array(num).fill(ele);
          }

          var arr = new Array(num);

          for (var i = 0; i < num; i++) {
            arr[i] = ele;
          }

          return arr;
        };
      },
      {},
    ],
    190: [
      function (require, module, exports) {
        /*!
         * repeat-string <https://github.com/jonschlinkert/repeat-string>
         *
         * Copyright (c) 2014-2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        /**
         * Results cache
         */

        var res = "";
        var cache;

        /**
         * Expose `repeat`
         */

        module.exports = repeat;

        /**
         * Repeat the given `string` the specified `number`
         * of times.
         *
         * **Example:**
         *
         * ```js
         * var repeat = require('repeat-string');
         * repeat('A', 5);
         * //=> AAAAA
         * ```
         *
         * @param {String} `string` The string to repeat
         * @param {Number} `number` The number of times to repeat the string
         * @return {String} Repeated string
         * @api public
         */

        function repeat(str, num) {
          if (typeof str !== "string") {
            throw new TypeError("expected a string");
          }

          // cover common, quick use cases
          if (num === 1) return str;
          if (num === 2) return str + str;

          var max = str.length * num;
          if (cache !== str || typeof cache === "undefined") {
            cache = str;
            res = "";
          } else if (res.length >= max) {
            return res.substr(0, max);
          }

          while (max > res.length && num > 1) {
            if (num & 1) {
              res += str;
            }

            num >>= 1;
            str += str;
          }

          res += str;
          res = res.substr(0, max);
          return res;
        }
      },
      {},
    ],
    191: [
      function (require, module, exports) {
        // Copyright 2014 Simon Lydell
        // X11 (MIT) Licensed. (See LICENSE.)

        void (function (root, factory) {
          if (typeof define === "function" && define.amd) {
            define(factory);
          } else if (typeof exports === "object") {
            module.exports = factory();
          } else {
            root.resolveUrl = factory();
          }
        })(this, function () {
          function resolveUrl(/* ...urls */) {
            var numUrls = arguments.length;

            if (numUrls === 0) {
              throw new Error(
                "resolveUrl requires at least one argument; got none."
              );
            }

            var base = document.createElement("base");
            base.href = arguments[0];

            if (numUrls === 1) {
              return base.href;
            }

            var head = document.getElementsByTagName("head")[0];
            head.insertBefore(base, head.firstChild);

            var a = document.createElement("a");
            var resolved;

            for (var index = 1; index < numUrls; index++) {
              a.href = arguments[index];
              resolved = a.href;
              base.href = resolved;
            }

            head.removeChild(base);

            return resolved;
          }

          return resolveUrl;
        });
      },
      {},
    ],
    192: [
      function (require, module, exports) {
        var util = require("./util");
        var types = require("./types");
        var sets = require("./sets");
        var positions = require("./positions");

        module.exports = function (regexpStr) {
          var i = 0,
            l,
            c,
            start = { type: types.ROOT, stack: [] },
            // Keep track of last clause/group and stack.
            lastGroup = start,
            last = start.stack,
            groupStack = [];

          var repeatErr = function (i) {
            util.error(regexpStr, "Nothing to repeat at column " + (i - 1));
          };

          // Decode a few escaped characters.
          var str = util.strToChars(regexpStr);
          l = str.length;

          // Iterate through each character in string.
          while (i < l) {
            c = str[i++];

            switch (c) {
              // Handle escaped characters, inclues a few sets.
              case "\\":
                c = str[i++];

                switch (c) {
                  case "b":
                    last.push(positions.wordBoundary());
                    break;

                  case "B":
                    last.push(positions.nonWordBoundary());
                    break;

                  case "w":
                    last.push(sets.words());
                    break;

                  case "W":
                    last.push(sets.notWords());
                    break;

                  case "d":
                    last.push(sets.ints());
                    break;

                  case "D":
                    last.push(sets.notInts());
                    break;

                  case "s":
                    last.push(sets.whitespace());
                    break;

                  case "S":
                    last.push(sets.notWhitespace());
                    break;

                  default:
                    // Check if c is integer.
                    // In which case it's a reference.
                    if (/\d/.test(c)) {
                      last.push({
                        type: types.REFERENCE,
                        value: parseInt(c, 10),
                      });

                      // Escaped character.
                    } else {
                      last.push({ type: types.CHAR, value: c.charCodeAt(0) });
                    }
                }

                break;

              // Positionals.
              case "^":
                last.push(positions.begin());
                break;

              case "$":
                last.push(positions.end());
                break;

              // Handle custom sets.
              case "[":
                // Check if this class is 'anti' i.e. [^abc].
                var not;
                if (str[i] === "^") {
                  not = true;
                  i++;
                } else {
                  not = false;
                }

                // Get all the characters in class.
                var classTokens = util.tokenizeClass(str.slice(i), regexpStr);

                // Increase index by length of class.
                i += classTokens[1];
                last.push({
                  type: types.SET,
                  set: classTokens[0],
                  not: not,
                });

                break;

              // Class of any character except \n.
              case ".":
                last.push(sets.anyChar());
                break;

              // Push group onto stack.
              case "(":
                // Create group.
                var group = {
                  type: types.GROUP,
                  stack: [],
                  remember: true,
                };

                c = str[i];

                // If if this is a special kind of group.
                if (c === "?") {
                  c = str[i + 1];
                  i += 2;

                  // Match if followed by.
                  if (c === "=") {
                    group.followedBy = true;

                    // Match if not followed by.
                  } else if (c === "!") {
                    group.notFollowedBy = true;
                  } else if (c !== ":") {
                    util.error(
                      regexpStr,
                      "Invalid group, character '" +
                        c +
                        "' after '?' at column " +
                        (i - 1)
                    );
                  }

                  group.remember = false;
                }

                // Insert subgroup into current group stack.
                last.push(group);

                // Remember the current group for when the group closes.
                groupStack.push(lastGroup);

                // Make this new group the current group.
                lastGroup = group;
                last = group.stack;
                break;

              // Pop group out of stack.
              case ")":
                if (groupStack.length === 0) {
                  util.error(regexpStr, "Unmatched ) at column " + (i - 1));
                }
                lastGroup = groupStack.pop();

                // Check if this group has a PIPE.
                // To get back the correct last stack.
                last = lastGroup.options
                  ? lastGroup.options[lastGroup.options.length - 1]
                  : lastGroup.stack;
                break;

              // Use pipe character to give more choices.
              case "|":
                // Create array where options are if this is the first PIPE
                // in this clause.
                if (!lastGroup.options) {
                  lastGroup.options = [lastGroup.stack];
                  delete lastGroup.stack;
                }

                // Create a new stack and add to options for rest of clause.
                var stack = [];
                lastGroup.options.push(stack);
                last = stack;
                break;

              // Repetition.
              // For every repetition, remove last element from last stack
              // then insert back a RANGE object.
              // This design is chosen because there could be more than
              // one repetition symbols in a regex i.e. `a?+{2,3}`.
              case "{":
                var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)),
                  min,
                  max;
                if (rs !== null) {
                  if (last.length === 0) {
                    repeatErr(i);
                  }
                  min = parseInt(rs[1], 10);
                  max = rs[2] ? (rs[3] ? parseInt(rs[3], 10) : Infinity) : min;
                  i += rs[0].length;

                  last.push({
                    type: types.REPETITION,
                    min: min,
                    max: max,
                    value: last.pop(),
                  });
                } else {
                  last.push({
                    type: types.CHAR,
                    value: 123,
                  });
                }
                break;

              case "?":
                if (last.length === 0) {
                  repeatErr(i);
                }
                last.push({
                  type: types.REPETITION,
                  min: 0,
                  max: 1,
                  value: last.pop(),
                });
                break;

              case "+":
                if (last.length === 0) {
                  repeatErr(i);
                }
                last.push({
                  type: types.REPETITION,
                  min: 1,
                  max: Infinity,
                  value: last.pop(),
                });
                break;

              case "*":
                if (last.length === 0) {
                  repeatErr(i);
                }
                last.push({
                  type: types.REPETITION,
                  min: 0,
                  max: Infinity,
                  value: last.pop(),
                });
                break;

              // Default is a character that is not `\[](){}?+*^$`.
              default:
                last.push({
                  type: types.CHAR,
                  value: c.charCodeAt(0),
                });
            }
          }

          // Check if any groups have not been closed.
          if (groupStack.length !== 0) {
            util.error(regexpStr, "Unterminated group");
          }

          return start;
        };

        module.exports.types = types;
      },
      { "./positions": 193, "./sets": 194, "./types": 195, "./util": 196 },
    ],
    193: [
      function (require, module, exports) {
        var types = require("./types");

        exports.wordBoundary = function () {
          return { type: types.POSITION, value: "b" };
        };

        exports.nonWordBoundary = function () {
          return { type: types.POSITION, value: "B" };
        };

        exports.begin = function () {
          return { type: types.POSITION, value: "^" };
        };

        exports.end = function () {
          return { type: types.POSITION, value: "$" };
        };
      },
      { "./types": 195 },
    ],
    194: [
      function (require, module, exports) {
        var types = require("./types");

        var INTS = function () {
          return [{ type: types.RANGE, from: 48, to: 57 }];
        };

        var WORDS = function () {
          return [
            { type: types.CHAR, value: 95 },
            { type: types.RANGE, from: 97, to: 122 },
            { type: types.RANGE, from: 65, to: 90 },
          ].concat(INTS());
        };

        var WHITESPACE = function () {
          return [
            { type: types.CHAR, value: 9 },
            { type: types.CHAR, value: 10 },
            { type: types.CHAR, value: 11 },
            { type: types.CHAR, value: 12 },
            { type: types.CHAR, value: 13 },
            { type: types.CHAR, value: 32 },
            { type: types.CHAR, value: 160 },
            { type: types.CHAR, value: 5760 },
            { type: types.CHAR, value: 6158 },
            { type: types.CHAR, value: 8192 },
            { type: types.CHAR, value: 8193 },
            { type: types.CHAR, value: 8194 },
            { type: types.CHAR, value: 8195 },
            { type: types.CHAR, value: 8196 },
            { type: types.CHAR, value: 8197 },
            { type: types.CHAR, value: 8198 },
            { type: types.CHAR, value: 8199 },
            { type: types.CHAR, value: 8200 },
            { type: types.CHAR, value: 8201 },
            { type: types.CHAR, value: 8202 },
            { type: types.CHAR, value: 8232 },
            { type: types.CHAR, value: 8233 },
            { type: types.CHAR, value: 8239 },
            { type: types.CHAR, value: 8287 },
            { type: types.CHAR, value: 12288 },
            { type: types.CHAR, value: 65279 },
          ];
        };

        var NOTANYCHAR = function () {
          return [
            { type: types.CHAR, value: 10 },
            { type: types.CHAR, value: 13 },
            { type: types.CHAR, value: 8232 },
            { type: types.CHAR, value: 8233 },
          ];
        };

        // Predefined class objects.
        exports.words = function () {
          return { type: types.SET, set: WORDS(), not: false };
        };

        exports.notWords = function () {
          return { type: types.SET, set: WORDS(), not: true };
        };

        exports.ints = function () {
          return { type: types.SET, set: INTS(), not: false };
        };

        exports.notInts = function () {
          return { type: types.SET, set: INTS(), not: true };
        };

        exports.whitespace = function () {
          return { type: types.SET, set: WHITESPACE(), not: false };
        };

        exports.notWhitespace = function () {
          return { type: types.SET, set: WHITESPACE(), not: true };
        };

        exports.anyChar = function () {
          return { type: types.SET, set: NOTANYCHAR(), not: true };
        };
      },
      { "./types": 195 },
    ],
    195: [
      function (require, module, exports) {
        module.exports = {
          ROOT: 0,
          GROUP: 1,
          POSITION: 2,
          SET: 3,
          RANGE: 4,
          REPETITION: 5,
          REFERENCE: 6,
          CHAR: 7,
        };
      },
      {},
    ],
    196: [
      function (require, module, exports) {
        var types = require("./types");
        var sets = require("./sets");

        // All of these are private and only used by randexp.
        // It's assumed that they will always be called with the correct input.

        var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
        var SLSH = { 0: 0, t: 9, n: 10, v: 11, f: 12, r: 13 };

        /**
         * Finds character representations in str and convert all to
         * their respective characters
         *
         * @param {String} str
         * @return {String}
         */
        exports.strToChars = function (str) {
          /* jshint maxlen: false */
          var chars_regex =
            /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\[\\\]\^?])|([0tnvfr]))/g;
          str = str.replace(
            chars_regex,
            function (s, b, lbs, a16, b16, c8, dctrl, eslsh) {
              if (lbs) {
                return s;
              }

              var code = b
                ? 8
                : a16
                ? parseInt(a16, 16)
                : b16
                ? parseInt(b16, 16)
                : c8
                ? parseInt(c8, 8)
                : dctrl
                ? CTRL.indexOf(dctrl)
                : SLSH[eslsh];

              var c = String.fromCharCode(code);

              // Escape special regex characters.
              if (/[\[\]{}\^$.|?*+()]/.test(c)) {
                c = "\\" + c;
              }

              return c;
            }
          );

          return str;
        };

        /**
         * turns class into tokens
         * reads str until it encounters a ] not preceeded by a \
         *
         * @param {String} str
         * @param {String} regexpStr
         * @return {Array.<Array.<Object>, Number>}
         */
        exports.tokenizeClass = function (str, regexpStr) {
          /* jshint maxlen: false */
          var tokens = [];
          var regexp =
            /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?(.)/g;
          var rs, c;

          while ((rs = regexp.exec(str)) != null) {
            if (rs[1]) {
              tokens.push(sets.words());
            } else if (rs[2]) {
              tokens.push(sets.ints());
            } else if (rs[3]) {
              tokens.push(sets.whitespace());
            } else if (rs[4]) {
              tokens.push(sets.notWords());
            } else if (rs[5]) {
              tokens.push(sets.notInts());
            } else if (rs[6]) {
              tokens.push(sets.notWhitespace());
            } else if (rs[7]) {
              tokens.push({
                type: types.RANGE,
                from: (rs[8] || rs[9]).charCodeAt(0),
                to: rs[10].charCodeAt(0),
              });
            } else if ((c = rs[12])) {
              tokens.push({
                type: types.CHAR,
                value: c.charCodeAt(0),
              });
            } else {
              return [tokens, regexp.lastIndex];
            }
          }

          exports.error(regexpStr, "Unterminated character class");
        };

        /**
         * Shortcut to throw errors.
         *
         * @param {String} regexp
         * @param {String} msg
         */
        exports.error = function (regexp, msg) {
          throw new SyntaxError(
            "Invalid regular expression: /" + regexp + "/: " + msg
          );
        };
      },
      { "./sets": 194, "./types": 195 },
    ],
    197: [
      function (require, module, exports) {
        var parse = require("ret");
        var types = parse.types;

        module.exports = function (re, opts) {
          if (!opts) opts = {};
          var replimit = opts.limit === undefined ? 25 : opts.limit;

          if (isRegExp(re)) re = re.source;
          else if (typeof re !== "string") re = String(re);

          try {
            re = parse(re);
          } catch (err) {
            return false;
          }

          var reps = 0;
          return (function walk(node, starHeight) {
            if (node.type === types.REPETITION) {
              starHeight++;
              reps++;
              if (starHeight > 1) return false;
              if (reps > replimit) return false;
            }

            if (node.options) {
              for (var i = 0, len = node.options.length; i < len; i++) {
                var ok = walk({ stack: node.options[i] }, starHeight);
                if (!ok) return false;
              }
            }
            var stack = node.stack || (node.value && node.value.stack);
            if (!stack) return true;

            for (var i = 0; i < stack.length; i++) {
              var ok = walk(stack[i], starHeight);
              if (!ok) return false;
            }

            return true;
          })(re, 0);
        };

        function isRegExp(x) {
          return {}.toString.call(x) === "[object RegExp]";
        }
      },
      { ret: 192 },
    ],
    198: [
      function (require, module, exports) {
        "use strict";

        var svgElements = [
          "circle",
          "ellipse",
          "line",
          "path",
          "polygon",
          "polyline",
          "rect",
          "stop",
          "use",
        ];

        var voidElements = [
          "area",
          "base",
          "br",
          "col",
          "command",
          "embed",
          "hr",
          "img",
          "input",
          "keygen",
          "link",
          "meta",
          "param",
          "source",
          "track",
          "wbr",
        ];

        module.exports = voidElements.concat(svgElements);
        module.exports.voidElements = voidElements;
        module.exports.svgElements = svgElements;
      },
      {},
    ],
    199: [
      function (require, module, exports) {
        /*!
         * set-getter (https://github.com/doowb/set-getter)
         *
         * Copyright (c) 2016, Brian Woodward.
         * Licensed under the MIT License.
         */

        "use strict";

        var toPath = require("to-object-path");

        function isValidKey(key) {
          return (
            key !== "__proto__" && key !== "constructor" && key !== "prototype"
          );
        }

        /**
         * Defines a getter function on an object using property path notation.
         *
         * ```js
         * var obj = {};
         * getter(obj, 'foo', function() {
         *   return 'bar';
         * });
         * ```
         * @param {Object} `obj` Object to add property to.
         * @param {String|Array} `prop` Property string or array to add.
         * @param {Function} `getter` Getter function to add as a property.
         * @api public
         */

        function setGetter(obj, prop, getter) {
          var key = toPath(arguments);
          return define(obj, key, getter);
        }

        /**
         * Define getter function on object or object hierarchy using dot notation.
         *
         * @param  {Object} `obj` Object to define getter property on.
         * @param  {String} `prop` Property string to define.
         * @param  {Function} `getter` Getter function to define.
         * @return {Object} Returns original object.
         */

        function define(obj, prop, getter) {
          if (!~prop.indexOf(".")) {
            if (isValidKey(prop)) {
              defineProperty(obj, prop, getter);
            }
            return obj;
          }

          var keys = prop.split(".").filter(isValidKey);
          var last = keys.pop();
          var target = obj;
          var key;

          while ((key = keys.shift())) {
            while (key.slice(-1) === "\\") {
              key = key.slice(0, -1) + "." + keys.shift();
            }
            target = target[key] || (target[key] = {});
          }

          defineProperty(target, last, getter);
          return obj;
        }

        /**
         * Define getter function on object as a configurable and enumerable property.
         *
         * @param  {Object} `obj` Object to define property on.
         * @param  {String} `prop` Property to define.
         * @param  {Function} `getter` Getter function to define.
         */

        function defineProperty(obj, prop, getter) {
          Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: true,
            get: getter,
          });
        }

        /**
         * Expose `setGetter`
         */

        module.exports = setGetter;
      },
      { "to-object-path": 246 },
    ],
    200: [
      function (require, module, exports) {
        /*!
         * set-value <https://github.com/jonschlinkert/set-value>
         *
         * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var split = require("split-string");
        var extend = require("extend-shallow");
        var isPlainObject = require("is-plain-object");
        var isObject = require("is-extendable");

        module.exports = function (obj, prop, val) {
          if (!isObject(obj)) {
            return obj;
          }

          if (Array.isArray(prop)) {
            prop = [].concat.apply([], prop).join(".");
          }

          if (typeof prop !== "string") {
            return obj;
          }

          var keys = split(prop, { sep: ".", brackets: true }).filter(
            isValidKey
          );
          var len = keys.length;
          var idx = -1;
          var current = obj;

          while (++idx < len) {
            var key = keys[idx];
            if (idx !== len - 1) {
              if (!isObject(current[key])) {
                current[key] = {};
              }
              current = current[key];
              continue;
            }

            if (isPlainObject(current[key]) && isPlainObject(val)) {
              current[key] = extend({}, current[key], val);
            } else {
              current[key] = val;
            }
          }

          return obj;
        };

        function isValidKey(key) {
          return (
            key !== "__proto__" && key !== "constructor" && key !== "prototype"
          );
        }
      },
      {
        "extend-shallow": 61,
        "is-extendable": 119,
        "is-plain-object": 126,
        "split-string": 232,
      },
    ],
    201: [
      function (require, module, exports) {
        "use strict";

        var isObject = require("isobject");
        var define = require("define-property");
        var utils = require("snapdragon-util");
        var ownNames;

        /**
         * Create a new AST `Node` with the given `val` and `type`.
         *
         * ```js
         * var node = new Node('*', 'Star');
         * var node = new Node({type: 'star', val: '*'});
         * ```
         * @name Node
         * @param {String|Object} `val` Pass a matched substring, or an object to merge onto the node.
         * @param {String} `type` The node type to use when `val` is a string.
         * @return {Object} node instance
         * @api public
         */

        function Node(val, type, parent) {
          if (typeof type !== "string") {
            parent = type;
            type = null;
          }

          define(this, "parent", parent);
          define(this, "isNode", true);
          define(this, "expect", null);

          if (typeof type !== "string" && isObject(val)) {
            lazyKeys();
            var keys = Object.keys(val);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (ownNames.indexOf(key) === -1) {
                this[key] = val[key];
              }
            }
          } else {
            this.type = type;
            this.val = val;
          }
        }

        /**
         * Returns true if the given value is a node.
         *
         * ```js
         * var Node = require('snapdragon-node');
         * var node = new Node({type: 'foo'});
         * console.log(Node.isNode(node)); //=> true
         * console.log(Node.isNode({})); //=> false
         * ```
         * @param {Object} `node`
         * @returns {Boolean}
         * @api public
         */

        Node.isNode = function (node) {
          return utils.isNode(node);
        };

        /**
         * Define a non-enumberable property on the node instance.
         * Useful for adding properties that shouldn't be extended
         * or visible during debugging.
         *
         * ```js
         * var node = new Node();
         * node.define('foo', 'something non-enumerable');
         * ```
         * @param {String} `name`
         * @param {any} `val`
         * @return {Object} returns the node instance
         * @api public
         */

        Node.prototype.define = function (name, val) {
          define(this, name, val);
          return this;
        };

        /**
         * Returns true if `node.val` is an empty string, or `node.nodes` does
         * not contain any non-empty text nodes.
         *
         * ```js
         * var node = new Node({type: 'text'});
         * node.isEmpty(); //=> true
         * node.val = 'foo';
         * node.isEmpty(); //=> false
         * ```
         * @param {Function} `fn` (optional) Filter function that is called on `node` and/or child nodes. `isEmpty` will return false immediately when the filter function returns false on any nodes.
         * @return {Boolean}
         * @api public
         */

        Node.prototype.isEmpty = function (fn) {
          return utils.isEmpty(this, fn);
        };

        /**
         * Given node `foo` and node `bar`, push node `bar` onto `foo.nodes`, and
         * set `foo` as `bar.parent`.
         *
         * ```js
         * var foo = new Node({type: 'foo'});
         * var bar = new Node({type: 'bar'});
         * foo.push(bar);
         * ```
         * @param {Object} `node`
         * @return {Number} Returns the length of `node.nodes`
         * @api public
         */

        Node.prototype.push = function (node) {
          assert(Node.isNode(node), "expected node to be an instance of Node");
          define(node, "parent", this);

          this.nodes = this.nodes || [];
          return this.nodes.push(node);
        };

        /**
         * Given node `foo` and node `bar`, unshift node `bar` onto `foo.nodes`, and
         * set `foo` as `bar.parent`.
         *
         * ```js
         * var foo = new Node({type: 'foo'});
         * var bar = new Node({type: 'bar'});
         * foo.unshift(bar);
         * ```
         * @param {Object} `node`
         * @return {Number} Returns the length of `node.nodes`
         * @api public
         */

        Node.prototype.unshift = function (node) {
          assert(Node.isNode(node), "expected node to be an instance of Node");
          define(node, "parent", this);

          this.nodes = this.nodes || [];
          return this.nodes.unshift(node);
        };

        /**
         * Pop a node from `node.nodes`.
         *
         * ```js
         * var node = new Node({type: 'foo'});
         * node.push(new Node({type: 'a'}));
         * node.push(new Node({type: 'b'}));
         * node.push(new Node({type: 'c'}));
         * node.push(new Node({type: 'd'}));
         * console.log(node.nodes.length);
         * //=> 4
         * node.pop();
         * console.log(node.nodes.length);
         * //=> 3
         * ```
         * @return {Number} Returns the popped `node`
         * @api public
         */

        Node.prototype.pop = function () {
          return this.nodes && this.nodes.pop();
        };

        /**
         * Shift a node from `node.nodes`.
         *
         * ```js
         * var node = new Node({type: 'foo'});
         * node.push(new Node({type: 'a'}));
         * node.push(new Node({type: 'b'}));
         * node.push(new Node({type: 'c'}));
         * node.push(new Node({type: 'd'}));
         * console.log(node.nodes.length);
         * //=> 4
         * node.shift();
         * console.log(node.nodes.length);
         * //=> 3
         * ```
         * @return {Object} Returns the shifted `node`
         * @api public
         */

        Node.prototype.shift = function () {
          return this.nodes && this.nodes.shift();
        };

        /**
         * Remove `node` from `node.nodes`.
         *
         * ```js
         * node.remove(childNode);
         * ```
         * @param {Object} `node`
         * @return {Object} Returns the removed node.
         * @api public
         */

        Node.prototype.remove = function (node) {
          assert(Node.isNode(node), "expected node to be an instance of Node");
          this.nodes = this.nodes || [];
          var idx = node.index;
          if (idx !== -1) {
            node.index = -1;
            return this.nodes.splice(idx, 1);
          }
          return null;
        };

        /**
         * Get the first child node from `node.nodes` that matches the given `type`.
         * If `type` is a number, the child node at that index is returned.
         *
         * ```js
         * var child = node.find(1); //<= index of the node to get
         * var child = node.find('foo'); //<= node.type of a child node
         * var child = node.find(/^(foo|bar)$/); //<= regex to match node.type
         * var child = node.find(['foo', 'bar']); //<= array of node.type(s)
         * ```
         * @param {String} `type`
         * @return {Object} Returns a child node or undefined.
         * @api public
         */

        Node.prototype.find = function (type) {
          return utils.findNode(this.nodes, type);
        };

        /**
         * Return true if the node is the given `type`.
         *
         * ```js
         * var node = new Node({type: 'bar'});
         * cosole.log(node.isType('foo'));          // false
         * cosole.log(node.isType(/^(foo|bar)$/));  // true
         * cosole.log(node.isType(['foo', 'bar'])); // true
         * ```
         * @param {String} `type`
         * @return {Boolean}
         * @api public
         */

        Node.prototype.isType = function (type) {
          return utils.isType(this, type);
        };

        /**
         * Return true if the `node.nodes` has the given `type`.
         *
         * ```js
         * var foo = new Node({type: 'foo'});
         * var bar = new Node({type: 'bar'});
         * foo.push(bar);
         *
         * cosole.log(foo.hasType('qux'));          // false
         * cosole.log(foo.hasType(/^(qux|bar)$/));  // true
         * cosole.log(foo.hasType(['qux', 'bar'])); // true
         * ```
         * @param {String} `type`
         * @return {Boolean}
         * @api public
         */

        Node.prototype.hasType = function (type) {
          return utils.hasType(this, type);
        };

        /**
         * Get the siblings array, or `null` if it doesn't exist.
         *
         * ```js
         * var foo = new Node({type: 'foo'});
         * var bar = new Node({type: 'bar'});
         * var baz = new Node({type: 'baz'});
         * foo.push(bar);
         * foo.push(baz);
         *
         * console.log(bar.siblings.length) // 2
         * console.log(baz.siblings.length) // 2
         * ```
         * @return {Array}
         * @api public
         */

        Object.defineProperty(Node.prototype, "siblings", {
          set: function () {
            throw new Error("node.siblings is a getter and cannot be defined");
          },
          get: function () {
            return this.parent ? this.parent.nodes : null;
          },
        });

        /**
         * Get the node's current index from `node.parent.nodes`.
         * This should always be correct, even when the parent adds nodes.
         *
         * ```js
         * var foo = new Node({type: 'foo'});
         * var bar = new Node({type: 'bar'});
         * var baz = new Node({type: 'baz'});
         * var qux = new Node({type: 'qux'});
         * foo.push(bar);
         * foo.push(baz);
         * foo.unshift(qux);
         *
         * console.log(bar.index) // 1
         * console.log(baz.index) // 2
         * console.log(qux.index) // 0
         * ```
         * @return {Number}
         * @api public
         */

        Object.defineProperty(Node.prototype, "index", {
          set: function (index) {
            define(this, "idx", index);
          },
          get: function () {
            if (!Array.isArray(this.siblings)) {
              return -1;
            }
            var tok = this.idx !== -1 ? this.siblings[this.idx] : null;
            if (tok !== this) {
              this.idx = this.siblings.indexOf(this);
            }
            return this.idx;
          },
        });

        /**
         * Get the previous node from the siblings array or `null`.
         *
         * ```js
         * var foo = new Node({type: 'foo'});
         * var bar = new Node({type: 'bar'});
         * var baz = new Node({type: 'baz'});
         * foo.push(bar);
         * foo.push(baz);
         *
         * console.log(baz.prev.type) // 'bar'
         * ```
         * @return {Object}
         * @api public
         */

        Object.defineProperty(Node.prototype, "prev", {
          set: function () {
            throw new Error("node.prev is a getter and cannot be defined");
          },
          get: function () {
            if (Array.isArray(this.siblings)) {
              return this.siblings[this.index - 1] || this.parent.prev;
            }
            return null;
          },
        });

        /**
         * Get the siblings array, or `null` if it doesn't exist.
         *
         * ```js
         * var foo = new Node({type: 'foo'});
         * var bar = new Node({type: 'bar'});
         * var baz = new Node({type: 'baz'});
         * foo.push(bar);
         * foo.push(baz);
         *
         * console.log(bar.siblings.length) // 2
         * console.log(baz.siblings.length) // 2
         * ```
         * @return {Object}
         * @api public
         */

        Object.defineProperty(Node.prototype, "next", {
          set: function () {
            throw new Error("node.next is a getter and cannot be defined");
          },
          get: function () {
            if (Array.isArray(this.siblings)) {
              return this.siblings[this.index + 1] || this.parent.next;
            }
            return null;
          },
        });

        /**
         * Get the first node from `node.nodes`.
         *
         * ```js
         * var foo = new Node({type: 'foo'});
         * var bar = new Node({type: 'bar'});
         * var baz = new Node({type: 'baz'});
         * var qux = new Node({type: 'qux'});
         * foo.push(bar);
         * foo.push(baz);
         * foo.push(qux);
         *
         * console.log(foo.first.type) // 'bar'
         * ```
         * @return {Object} The first node, or undefiend
         * @api public
         */

        Object.defineProperty(Node.prototype, "first", {
          get: function () {
            return this.nodes ? this.nodes[0] : null;
          },
        });

        /**
         * Get the last node from `node.nodes`.
         *
         * ```js
         * var foo = new Node({type: 'foo'});
         * var bar = new Node({type: 'bar'});
         * var baz = new Node({type: 'baz'});
         * var qux = new Node({type: 'qux'});
         * foo.push(bar);
         * foo.push(baz);
         * foo.push(qux);
         *
         * console.log(foo.last.type) // 'qux'
         * ```
         * @return {Object} The last node, or undefiend
         * @api public
         */

        Object.defineProperty(Node.prototype, "last", {
          get: function () {
            return this.nodes ? utils.last(this.nodes) : null;
          },
        });

        /**
         * Get the last node from `node.nodes`.
         *
         * ```js
         * var foo = new Node({type: 'foo'});
         * var bar = new Node({type: 'bar'});
         * var baz = new Node({type: 'baz'});
         * var qux = new Node({type: 'qux'});
         * foo.push(bar);
         * foo.push(baz);
         * foo.push(qux);
         *
         * console.log(foo.last.type) // 'qux'
         * ```
         * @return {Object} The last node, or undefiend
         * @api public
         */

        Object.defineProperty(Node.prototype, "scope", {
          get: function () {
            if (this.isScope !== true) {
              return this.parent ? this.parent.scope : this;
            }
            return this;
          },
        });

        /**
         * Get own property names from Node prototype, but only the
         * first time `Node` is instantiated
         */

        function lazyKeys() {
          if (!ownNames) {
            ownNames = Object.getOwnPropertyNames(Node.prototype);
          }
        }

        /**
         * Simplified assertion. Throws an error is `val` is falsey.
         */

        function assert(val, message) {
          if (!val) throw new Error(message);
        }

        /**
         * Expose `Node`
         */

        exports = module.exports = Node;
      },
      { "define-property": 47, isobject: 131, "snapdragon-util": 202 },
    ],
    202: [
      function (require, module, exports) {
        "use strict";

        var typeOf = require("kind-of");
        var utils = module.exports;

        /**
         * Returns true if the given value is a node.
         *
         * ```js
         * var Node = require('snapdragon-node');
         * var node = new Node({type: 'foo'});
         * console.log(utils.isNode(node)); //=> true
         * console.log(utils.isNode({})); //=> false
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @returns {Boolean}
         * @api public
         */

        utils.isNode = function (node) {
          return typeOf(node) === "object" && node.isNode === true;
        };

        /**
         * Emit an empty string for the given `node`.
         *
         * ```js
         * // do nothing for beginning-of-string
         * snapdragon.compiler.set('bos', utils.noop);
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @returns {undefined}
         * @api public
         */

        utils.noop = function (node) {
          append(this, "", node);
        };

        /**
         * Appdend `node.val` to `compiler.output`, exactly as it was created
         * by the parser.
         *
         * ```js
         * snapdragon.compiler.set('text', utils.identity);
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @returns {undefined}
         * @api public
         */

        utils.identity = function (node) {
          append(this, node.val, node);
        };

        /**
         * Previously named `.emit`, this method appends the given `val`
         * to `compiler.output` for the given node. Useful when you know
         * what value should be appended advance, regardless of the actual
         * value of `node.val`.
         *
         * ```js
         * snapdragon.compiler
         *   .set('i', function(node) {
         *     this.mapVisit(node);
         *   })
         *   .set('i.open', utils.append('<i>'))
         *   .set('i.close', utils.append('</i>'))
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @returns {Function} Returns a compiler middleware function.
         * @api public
         */

        utils.append = function (val) {
          return function (node) {
            append(this, val, node);
          };
        };

        /**
         * Used in compiler middleware, this onverts an AST node into
         * an empty `text` node and deletes `node.nodes` if it exists.
         * The advantage of this method is that, as opposed to completely
         * removing the node, indices will not need to be re-calculated
         * in sibling nodes, and nothing is appended to the output.
         *
         * ```js
         * utils.toNoop(node);
         * // convert `node.nodes` to the given value instead of deleting it
         * utils.toNoop(node, []);
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.
         * @api public
         */

        utils.toNoop = function (node, nodes) {
          if (nodes) {
            node.nodes = nodes;
          } else {
            delete node.nodes;
            node.type = "text";
            node.val = "";
          }
        };

        /**
         * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon
         * automatically calls registered compilers, this allows you to pass a visitor
         * function.
         *
         * ```js
         * snapdragon.compiler.set('i', function(node) {
         *   utils.visit(node, function(childNode) {
         *     // do stuff with "childNode"
         *     return childNode;
         *   });
         * });
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @param {Function} `fn`
         * @return {Object} returns the node after recursively visiting all child nodes.
         * @api public
         */

        utils.visit = function (node, fn) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          assert(isFunction(fn), "expected a visitor function");
          fn(node);
          return node.nodes ? utils.mapVisit(node, fn) : node;
        };

        /**
         * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by
         * [visit](#visit), use this method if you do not want `fn` to be called on
         * the first node.
         *
         * ```js
         * snapdragon.compiler.set('i', function(node) {
         *   utils.mapVisit(node, function(childNode) {
         *     // do stuff with "childNode"
         *     return childNode;
         *   });
         * });
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @param {Object} `options`
         * @param {Function} `fn`
         * @return {Object} returns the node
         * @api public
         */

        utils.mapVisit = function (node, fn) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          assert(isArray(node.nodes), "expected node.nodes to be an array");
          assert(isFunction(fn), "expected a visitor function");

          for (var i = 0; i < node.nodes.length; i++) {
            utils.visit(node.nodes[i], fn);
          }
          return node;
        };

        /**
         * Unshift an `*.open` node onto `node.nodes`.
         *
         * ```js
         * var Node = require('snapdragon-node');
         * snapdragon.parser.set('brace', function(node) {
         *   var match = this.match(/^{/);
         *   if (match) {
         *     var parent = new Node({type: 'brace'});
         *     utils.addOpen(parent, Node);
         *     console.log(parent.nodes[0]):
         *     // { type: 'brace.open', val: '' };
         *
         *     // push the parent "brace" node onto the stack
         *     this.push(parent);
         *
         *     // return the parent node, so it's also added to the AST
         *     return brace;
         *   }
         * });
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
         * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
         * @return {Object} Returns the created opening node.
         * @api public
         */

        utils.addOpen = function (node, Node, val, filter) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          assert(
            isFunction(Node),
            "expected Node to be a constructor function"
          );

          if (typeof val === "function") {
            filter = val;
            val = "";
          }

          if (typeof filter === "function" && !filter(node)) return;
          var open = new Node({ type: node.type + ".open", val: val });
          var unshift = node.unshift || node.unshiftNode;
          if (typeof unshift === "function") {
            unshift.call(node, open);
          } else {
            utils.unshiftNode(node, open);
          }
          return open;
        };

        /**
         * Push a `*.close` node onto `node.nodes`.
         *
         * ```js
         * var Node = require('snapdragon-node');
         * snapdragon.parser.set('brace', function(node) {
         *   var match = this.match(/^}/);
         *   if (match) {
         *     var parent = this.parent();
         *     if (parent.type !== 'brace') {
         *       throw new Error('missing opening: ' + '}');
         *     }
         *
         *     utils.addClose(parent, Node);
         *     console.log(parent.nodes[parent.nodes.length - 1]):
         *     // { type: 'brace.close', val: '' };
         *
         *     // no need to return a node, since the parent
         *     // was already added to the AST
         *     return;
         *   }
         * });
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
         * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
         * @return {Object} Returns the created closing node.
         * @api public
         */

        utils.addClose = function (node, Node, val, filter) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          assert(
            isFunction(Node),
            "expected Node to be a constructor function"
          );

          if (typeof val === "function") {
            filter = val;
            val = "";
          }

          if (typeof filter === "function" && !filter(node)) return;
          var close = new Node({ type: node.type + ".close", val: val });
          var push = node.push || node.pushNode;
          if (typeof push === "function") {
            push.call(node, close);
          } else {
            utils.pushNode(node, close);
          }
          return close;
        };

        /**
         * Wraps the given `node` with `*.open` and `*.close` nodes.
         *
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
         * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
         * @return {Object} Returns the node
         * @api public
         */

        utils.wrapNodes = function (node, Node, filter) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          assert(
            isFunction(Node),
            "expected Node to be a constructor function"
          );

          utils.addOpen(node, Node, filter);
          utils.addClose(node, Node, filter);
          return node;
        };

        /**
         * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.
         *
         * ```js
         * var parent = new Node({type: 'foo'});
         * var node = new Node({type: 'bar'});
         * utils.pushNode(parent, node);
         * console.log(parent.nodes[0].type) // 'bar'
         * console.log(node.parent.type) // 'foo'
         * ```
         * @param {Object} `parent`
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @return {Object} Returns the child node
         * @api public
         */

        utils.pushNode = function (parent, node) {
          assert(
            utils.isNode(parent),
            "expected parent node to be an instance of Node"
          );
          assert(utils.isNode(node), "expected node to be an instance of Node");

          node.define("parent", parent);
          parent.nodes = parent.nodes || [];
          parent.nodes.push(node);
          return node;
        };

        /**
         * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.
         *
         * ```js
         * var parent = new Node({type: 'foo'});
         * var node = new Node({type: 'bar'});
         * utils.unshiftNode(parent, node);
         * console.log(parent.nodes[0].type) // 'bar'
         * console.log(node.parent.type) // 'foo'
         * ```
         * @param {Object} `parent`
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @return {undefined}
         * @api public
         */

        utils.unshiftNode = function (parent, node) {
          assert(
            utils.isNode(parent),
            "expected parent node to be an instance of Node"
          );
          assert(utils.isNode(node), "expected node to be an instance of Node");

          node.define("parent", parent);
          parent.nodes = parent.nodes || [];
          parent.nodes.unshift(node);
        };

        /**
         * Pop the last `node` off of `parent.nodes`. The advantage of
         * using this method is that it checks for `node.nodes` and works
         * with any version of `snapdragon-node`.
         *
         * ```js
         * var parent = new Node({type: 'foo'});
         * utils.pushNode(parent, new Node({type: 'foo'}));
         * utils.pushNode(parent, new Node({type: 'bar'}));
         * utils.pushNode(parent, new Node({type: 'baz'}));
         * console.log(parent.nodes.length); //=> 3
         * utils.popNode(parent);
         * console.log(parent.nodes.length); //=> 2
         * ```
         * @param {Object} `parent`
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
         * @api public
         */

        utils.popNode = function (node) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          if (typeof node.pop === "function") {
            return node.pop();
          }
          return node.nodes && node.nodes.pop();
        };

        /**
         * Shift the first `node` off of `parent.nodes`. The advantage of
         * using this method is that it checks for `node.nodes` and works
         * with any version of `snapdragon-node`.
         *
         * ```js
         * var parent = new Node({type: 'foo'});
         * utils.pushNode(parent, new Node({type: 'foo'}));
         * utils.pushNode(parent, new Node({type: 'bar'}));
         * utils.pushNode(parent, new Node({type: 'baz'}));
         * console.log(parent.nodes.length); //=> 3
         * utils.shiftNode(parent);
         * console.log(parent.nodes.length); //=> 2
         * ```
         * @param {Object} `parent`
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
         * @api public
         */

        utils.shiftNode = function (node) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          if (typeof node.shift === "function") {
            return node.shift();
          }
          return node.nodes && node.nodes.shift();
        };

        /**
         * Remove the specified `node` from `parent.nodes`.
         *
         * ```js
         * var parent = new Node({type: 'abc'});
         * var foo = new Node({type: 'foo'});
         * utils.pushNode(parent, foo);
         * utils.pushNode(parent, new Node({type: 'bar'}));
         * utils.pushNode(parent, new Node({type: 'baz'}));
         * console.log(parent.nodes.length); //=> 3
         * utils.removeNode(parent, foo);
         * console.log(parent.nodes.length); //=> 2
         * ```
         * @param {Object} `parent`
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.
         * @api public
         */

        utils.removeNode = function (parent, node) {
          assert(
            utils.isNode(parent),
            "expected parent.node to be an instance of Node"
          );
          assert(utils.isNode(node), "expected node to be an instance of Node");

          if (!parent.nodes) {
            return null;
          }

          if (typeof parent.remove === "function") {
            return parent.remove(node);
          }

          var idx = parent.nodes.indexOf(node);
          if (idx !== -1) {
            return parent.nodes.splice(idx, 1);
          }
        };

        /**
         * Returns true if `node.type` matches the given `type`. Throws a
         * `TypeError` if `node` is not an instance of `Node`.
         *
         * ```js
         * var Node = require('snapdragon-node');
         * var node = new Node({type: 'foo'});
         * console.log(utils.isType(node, 'foo')); // false
         * console.log(utils.isType(node, 'bar')); // true
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @param {String} `type`
         * @return {Boolean}
         * @api public
         */

        utils.isType = function (node, type) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          switch (typeOf(type)) {
            case "array":
              var types = type.slice();
              for (var i = 0; i < types.length; i++) {
                if (utils.isType(node, types[i])) {
                  return true;
                }
              }
              return false;
            case "string":
              return node.type === type;
            case "regexp":
              return type.test(node.type);
            default: {
              throw new TypeError(
                'expected "type" to be an array, string or regexp'
              );
            }
          }
        };

        /**
         * Returns true if the given `node` has the given `type` in `node.nodes`.
         * Throws a `TypeError` if `node` is not an instance of `Node`.
         *
         * ```js
         * var Node = require('snapdragon-node');
         * var node = new Node({
         *   type: 'foo',
         *   nodes: [
         *     new Node({type: 'bar'}),
         *     new Node({type: 'baz'})
         *   ]
         * });
         * console.log(utils.hasType(node, 'xyz')); // false
         * console.log(utils.hasType(node, 'baz')); // true
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @param {String} `type`
         * @return {Boolean}
         * @api public
         */

        utils.hasType = function (node, type) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          if (!Array.isArray(node.nodes)) return false;
          for (var i = 0; i < node.nodes.length; i++) {
            if (utils.isType(node.nodes[i], type)) {
              return true;
            }
          }
          return false;
        };

        /**
         * Returns the first node from `node.nodes` of the given `type`
         *
         * ```js
         * var node = new Node({
         *   type: 'foo',
         *   nodes: [
         *     new Node({type: 'text', val: 'abc'}),
         *     new Node({type: 'text', val: 'xyz'})
         *   ]
         * });
         *
         * var textNode = utils.firstOfType(node.nodes, 'text');
         * console.log(textNode.val);
         * //=> 'abc'
         * ```
         * @param {Array} `nodes`
         * @param {String} `type`
         * @return {Object|undefined} Returns the first matching node or undefined.
         * @api public
         */

        utils.firstOfType = function (nodes, type) {
          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (utils.isType(node, type)) {
              return node;
            }
          }
        };

        /**
         * Returns the node at the specified index, or the first node of the
         * given `type` from `node.nodes`.
         *
         * ```js
         * var node = new Node({
         *   type: 'foo',
         *   nodes: [
         *     new Node({type: 'text', val: 'abc'}),
         *     new Node({type: 'text', val: 'xyz'})
         *   ]
         * });
         *
         * var nodeOne = utils.findNode(node.nodes, 'text');
         * console.log(nodeOne.val);
         * //=> 'abc'
         *
         * var nodeTwo = utils.findNode(node.nodes, 1);
         * console.log(nodeTwo.val);
         * //=> 'xyz'
         * ```
         *
         * @param {Array} `nodes`
         * @param {String|Number} `type` Node type or index.
         * @return {Object} Returns a node or undefined.
         * @api public
         */

        utils.findNode = function (nodes, type) {
          if (!Array.isArray(nodes)) {
            return null;
          }
          if (typeof type === "number") {
            return nodes[type];
          }
          return utils.firstOfType(nodes, type);
        };

        /**
         * Returns true if the given node is an "*.open" node.
         *
         * ```js
         * var Node = require('snapdragon-node');
         * var brace = new Node({type: 'brace'});
         * var open = new Node({type: 'brace.open'});
         * var close = new Node({type: 'brace.close'});
         *
         * console.log(utils.isOpen(brace)); // false
         * console.log(utils.isOpen(open)); // true
         * console.log(utils.isOpen(close)); // false
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @return {Boolean}
         * @api public
         */

        utils.isOpen = function (node) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          return node.type.slice(-5) === ".open";
        };

        /**
         * Returns true if the given node is a "*.close" node.
         *
         * ```js
         * var Node = require('snapdragon-node');
         * var brace = new Node({type: 'brace'});
         * var open = new Node({type: 'brace.open'});
         * var close = new Node({type: 'brace.close'});
         *
         * console.log(utils.isClose(brace)); // false
         * console.log(utils.isClose(open)); // false
         * console.log(utils.isClose(close)); // true
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @return {Boolean}
         * @api public
         */

        utils.isClose = function (node) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          return node.type.slice(-6) === ".close";
        };

        /**
         * Returns true if `node.nodes` **has** an `.open` node
         *
         * ```js
         * var Node = require('snapdragon-node');
         * var brace = new Node({
         *   type: 'brace',
         *   nodes: []
         * });
         *
         * var open = new Node({type: 'brace.open'});
         * console.log(utils.hasOpen(brace)); // false
         *
         * brace.pushNode(open);
         * console.log(utils.hasOpen(brace)); // true
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @return {Boolean}
         * @api public
         */

        utils.hasOpen = function (node) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          var first = node.first || node.nodes ? node.nodes[0] : null;
          if (utils.isNode(first)) {
            return first.type === node.type + ".open";
          }
          return false;
        };

        /**
         * Returns true if `node.nodes` **has** a `.close` node
         *
         * ```js
         * var Node = require('snapdragon-node');
         * var brace = new Node({
         *   type: 'brace',
         *   nodes: []
         * });
         *
         * var close = new Node({type: 'brace.close'});
         * console.log(utils.hasClose(brace)); // false
         *
         * brace.pushNode(close);
         * console.log(utils.hasClose(brace)); // true
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @return {Boolean}
         * @api public
         */

        utils.hasClose = function (node) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          var last =
            node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;
          if (utils.isNode(last)) {
            return last.type === node.type + ".close";
          }
          return false;
        };

        /**
         * Returns true if `node.nodes` has both `.open` and `.close` nodes
         *
         * ```js
         * var Node = require('snapdragon-node');
         * var brace = new Node({
         *   type: 'brace',
         *   nodes: []
         * });
         *
         * var open = new Node({type: 'brace.open'});
         * var close = new Node({type: 'brace.close'});
         * console.log(utils.hasOpen(brace)); // false
         * console.log(utils.hasClose(brace)); // false
         *
         * brace.pushNode(open);
         * brace.pushNode(close);
         * console.log(utils.hasOpen(brace)); // true
         * console.log(utils.hasClose(brace)); // true
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @return {Boolean}
         * @api public
         */

        utils.hasOpenAndClose = function (node) {
          return utils.hasOpen(node) && utils.hasClose(node);
        };

        /**
         * Push the given `node` onto the `state.inside` array for the
         * given type. This array is used as a specialized "stack" for
         * only the given `node.type`.
         *
         * ```js
         * var state = { inside: {}};
         * var node = new Node({type: 'brace'});
         * utils.addType(state, node);
         * console.log(state.inside);
         * //=> { brace: [{type: 'brace'}] }
         * ```
         * @param {Object} `state` The `compiler.state` object or custom state object.
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @return {Array} Returns the `state.inside` stack for the given type.
         * @api public
         */

        utils.addType = function (state, node) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          assert(isObject(state), "expected state to be an object");

          var type = node.parent
            ? node.parent.type
            : node.type.replace(/\.open$/, "");

          if (!state.hasOwnProperty("inside")) {
            state.inside = {};
          }
          if (!state.inside.hasOwnProperty(type)) {
            state.inside[type] = [];
          }

          var arr = state.inside[type];
          arr.push(node);
          return arr;
        };

        /**
         * Remove the given `node` from the `state.inside` array for the
         * given type. This array is used as a specialized "stack" for
         * only the given `node.type`.
         *
         * ```js
         * var state = { inside: {}};
         * var node = new Node({type: 'brace'});
         * utils.addType(state, node);
         * console.log(state.inside);
         * //=> { brace: [{type: 'brace'}] }
         * utils.removeType(state, node);
         * //=> { brace: [] }
         * ```
         * @param {Object} `state` The `compiler.state` object or custom state object.
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @return {Array} Returns the `state.inside` stack for the given type.
         * @api public
         */

        utils.removeType = function (state, node) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          assert(isObject(state), "expected state to be an object");

          var type = node.parent
            ? node.parent.type
            : node.type.replace(/\.close$/, "");

          if (state.inside.hasOwnProperty(type)) {
            return state.inside[type].pop();
          }
        };

        /**
         * Returns true if `node.val` is an empty string, or `node.nodes` does
         * not contain any non-empty text nodes.
         *
         * ```js
         * var node = new Node({type: 'text'});
         * utils.isEmpty(node); //=> true
         * node.val = 'foo';
         * utils.isEmpty(node); //=> false
         * ```
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @param {Function} `fn`
         * @return {Boolean}
         * @api public
         */

        utils.isEmpty = function (node, fn) {
          assert(utils.isNode(node), "expected node to be an instance of Node");

          if (!Array.isArray(node.nodes)) {
            if (node.type !== "text") {
              return true;
            }
            if (typeof fn === "function") {
              return fn(node, node.parent);
            }
            return !utils.trim(node.val);
          }

          for (var i = 0; i < node.nodes.length; i++) {
            var child = node.nodes[i];
            if (utils.isOpen(child) || utils.isClose(child)) {
              continue;
            }
            if (!utils.isEmpty(child, fn)) {
              return false;
            }
          }

          return true;
        };

        /**
         * Returns true if the `state.inside` stack for the given type exists
         * and has one or more nodes on it.
         *
         * ```js
         * var state = { inside: {}};
         * var node = new Node({type: 'brace'});
         * console.log(utils.isInsideType(state, 'brace')); //=> false
         * utils.addType(state, node);
         * console.log(utils.isInsideType(state, 'brace')); //=> true
         * utils.removeType(state, node);
         * console.log(utils.isInsideType(state, 'brace')); //=> false
         * ```
         * @param {Object} `state`
         * @param {String} `type`
         * @return {Boolean}
         * @api public
         */

        utils.isInsideType = function (state, type) {
          assert(isObject(state), "expected state to be an object");
          assert(isString(type), "expected type to be a string");

          if (!state.hasOwnProperty("inside")) {
            return false;
          }

          if (!state.inside.hasOwnProperty(type)) {
            return false;
          }

          return state.inside[type].length > 0;
        };

        /**
         * Returns true if `node` is either a child or grand-child of the given `type`,
         * or `state.inside[type]` is a non-empty array.
         *
         * ```js
         * var state = { inside: {}};
         * var node = new Node({type: 'brace'});
         * var open = new Node({type: 'brace.open'});
         * console.log(utils.isInside(state, open, 'brace')); //=> false
         * utils.pushNode(node, open);
         * console.log(utils.isInside(state, open, 'brace')); //=> true
         * ```
         * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.
         * @param {Object} `node` Instance of [snapdragon-node][]
         * @param {String} `type` The `node.type` to check for.
         * @return {Boolean}
         * @api public
         */

        utils.isInside = function (state, node, type) {
          assert(utils.isNode(node), "expected node to be an instance of Node");
          assert(isObject(state), "expected state to be an object");

          if (Array.isArray(type)) {
            for (var i = 0; i < type.length; i++) {
              if (utils.isInside(state, node, type[i])) {
                return true;
              }
            }
            return false;
          }

          var parent = node.parent;
          if (typeof type === "string") {
            return (
              (parent && parent.type === type) ||
              utils.isInsideType(state, type)
            );
          }

          if (typeOf(type) === "regexp") {
            if (parent && parent.type && type.test(parent.type)) {
              return true;
            }

            var keys = Object.keys(state.inside);
            var len = keys.length;
            var idx = -1;
            while (++idx < len) {
              var key = keys[idx];
              var val = state.inside[key];

              if (Array.isArray(val) && val.length !== 0 && type.test(key)) {
                return true;
              }
            }
          }
          return false;
        };

        /**
         * Get the last `n` element from the given `array`. Used for getting
         * a node from `node.nodes.`
         *
         * @param {Array} `array`
         * @param {Number} `n`
         * @return {undefined}
         * @api public
         */

        utils.last = function (arr, n) {
          return arr[arr.length - (n || 1)];
        };

        /**
         * Cast the given `val` to an array.
         *
         * ```js
         * console.log(utils.arrayify(''));
         * //=> []
         * console.log(utils.arrayify('foo'));
         * //=> ['foo']
         * console.log(utils.arrayify(['foo']));
         * //=> ['foo']
         * ```
         * @param {any} `val`
         * @return {Array}
         * @api public
         */

        utils.arrayify = function (val) {
          if (typeof val === "string" && val !== "") {
            return [val];
          }
          if (!Array.isArray(val)) {
            return [];
          }
          return val;
        };

        /**
         * Convert the given `val` to a string by joining with `,`. Useful
         * for creating a cheerio/CSS/DOM-style selector from a list of strings.
         *
         * @param {any} `val`
         * @return {Array}
         * @api public
         */

        utils.stringify = function (val) {
          return utils.arrayify(val).join(",");
        };

        /**
         * Ensure that the given value is a string and call `.trim()` on it,
         * or return an empty string.
         *
         * @param {String} `str`
         * @return {String}
         * @api public
         */

        utils.trim = function (str) {
          return typeof str === "string" ? str.trim() : "";
        };

        /**
         * Return true if val is an object
         */

        function isObject(val) {
          return typeOf(val) === "object";
        }

        /**
         * Return true if val is a string
         */

        function isString(val) {
          return typeof val === "string";
        }

        /**
         * Return true if val is a function
         */

        function isFunction(val) {
          return typeof val === "function";
        }

        /**
         * Return true if val is an array
         */

        function isArray(val) {
          return Array.isArray(val);
        }

        /**
         * Shim to ensure the `.append` methods work with any version of snapdragon
         */

        function append(compiler, val, node) {
          if (typeof compiler.append !== "function") {
            return compiler.emit(val, node);
          }
          return compiler.append(val, node);
        }

        /**
         * Simplified assertion. Throws an error is `val` is falsey.
         */

        function assert(val, message) {
          if (!val) throw new Error(message);
        }
      },
      { "kind-of": 203 },
    ],
    203: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    204: [
      function (require, module, exports) {
        "use strict";

        var Base = require("base");
        var define = require("define-property");
        var Compiler = require("./lib/compiler");
        var Parser = require("./lib/parser");
        var utils = require("./lib/utils");
        var regexCache = {};
        var cache = {};

        /**
         * Create a new instance of `Snapdragon` with the given `options`.
         *
         * ```js
         * var snapdragon = new Snapdragon();
         * ```
         *
         * @param {Object} `options`
         * @api public
         */

        function Snapdragon(options) {
          Base.call(this, null, options);
          this.options = utils.extend({ source: "string" }, this.options);
          this.compiler = new Compiler(this.options);
          this.parser = new Parser(this.options);

          Object.defineProperty(this, "compilers", {
            get: function () {
              return this.compiler.compilers;
            },
          });

          Object.defineProperty(this, "parsers", {
            get: function () {
              return this.parser.parsers;
            },
          });

          Object.defineProperty(this, "regex", {
            get: function () {
              return this.parser.regex;
            },
          });
        }

        /**
         * Inherit Base
         */

        Base.extend(Snapdragon);

        /**
         * Add a parser to `snapdragon.parsers` for capturing the given `type` using
         * the specified regex or parser function. A function is useful if you need
         * to customize how the token is created and/or have access to the parser
         * instance to check options, etc.
         *
         * ```js
         * snapdragon
         *   .capture('slash', /^\//)
         *   .capture('dot', function() {
         *     var pos = this.position();
         *     var m = this.match(/^\./);
         *     if (!m) return;
         *     return pos({
         *       type: 'dot',
         *       val: m[0]
         *     });
         *   });
         * ```
         * @param {String} `type`
         * @param {RegExp|Function} `regex`
         * @return {Object} Returns the parser instance for chaining
         * @api public
         */

        Snapdragon.prototype.capture = function () {
          return this.parser.capture.apply(this.parser, arguments);
        };

        /**
         * Register a plugin `fn`.
         *
         * ```js
         * var snapdragon = new Snapdgragon([options]);
         * snapdragon.use(function() {
         *   console.log(this);          //<= snapdragon instance
         *   console.log(this.parser);   //<= parser instance
         *   console.log(this.compiler); //<= compiler instance
         * });
         * ```
         * @param {Object} `fn`
         * @api public
         */

        Snapdragon.prototype.use = function (fn) {
          fn.call(this, this);
          return this;
        };

        /**
         * Parse the given `str`.
         *
         * ```js
         * var snapdragon = new Snapdgragon([options]);
         * // register parsers
         * snapdragon.parser.use(function() {});
         *
         * // parse
         * var ast = snapdragon.parse('foo/bar');
         * console.log(ast);
         * ```
         * @param {String} `str`
         * @param {Object} `options` Set `options.sourcemap` to true to enable source maps.
         * @return {Object} Returns an AST.
         * @api public
         */

        Snapdragon.prototype.parse = function (str, options) {
          this.options = utils.extend({}, this.options, options);
          var parsed = this.parser.parse(str, this.options);

          // add non-enumerable parser reference
          define(parsed, "parser", this.parser);
          return parsed;
        };

        /**
         * Compile the given `AST`.
         *
         * ```js
         * var snapdragon = new Snapdgragon([options]);
         * // register plugins
         * snapdragon.use(function() {});
         * // register parser plugins
         * snapdragon.parser.use(function() {});
         * // register compiler plugins
         * snapdragon.compiler.use(function() {});
         *
         * // parse
         * var ast = snapdragon.parse('foo/bar');
         *
         * // compile
         * var res = snapdragon.compile(ast);
         * console.log(res.output);
         * ```
         * @param {Object} `ast`
         * @param {Object} `options`
         * @return {Object} Returns an object with an `output` property with the rendered string.
         * @api public
         */

        Snapdragon.prototype.compile = function (ast, options) {
          this.options = utils.extend({}, this.options, options);
          var compiled = this.compiler.compile(ast, this.options);

          // add non-enumerable compiler reference
          define(compiled, "compiler", this.compiler);
          return compiled;
        };

        /**
         * Expose `Snapdragon`
         */

        module.exports = Snapdragon;

        /**
         * Expose `Parser` and `Compiler`
         */

        module.exports.Compiler = Compiler;
        module.exports.Parser = Parser;
      },
      {
        "./lib/compiler": 205,
        "./lib/parser": 206,
        "./lib/utils": 209,
        base: 9,
        "define-property": 212,
      },
    ],
    205: [
      function (require, module, exports) {
        (function (__filename) {
          (function () {
            "use strict";

            var use = require("use");
            var define = require("define-property");
            var debug = require("debug")("snapdragon:compiler");
            var utils = require("./utils");

            /**
             * Create a new `Compiler` with the given `options`.
             * @param {Object} `options`
             */

            function Compiler(options, state) {
              debug("initializing", __filename);
              this.options = utils.extend({ source: "string" }, options);
              this.state = state || {};
              this.compilers = {};
              this.output = "";
              this.set("eos", function (node) {
                return this.emit(node.val, node);
              });
              this.set("noop", function (node) {
                return this.emit(node.val, node);
              });
              this.set("bos", function (node) {
                return this.emit(node.val, node);
              });
              use(this);
            }

            /**
             * Prototype methods
             */

            Compiler.prototype = {
              /**
               * Throw an error message with details including the cursor position.
               * @param {String} `msg` Message to use in the Error.
               */

              error: function (msg, node) {
                var pos = node.position || { start: { column: 0 } };
                var message =
                  this.options.source +
                  " column:" +
                  pos.start.column +
                  ": " +
                  msg;

                var err = new Error(message);
                err.reason = msg;
                err.column = pos.start.column;
                err.source = this.pattern;

                if (this.options.silent) {
                  this.errors.push(err);
                } else {
                  throw err;
                }
              },

              /**
               * Define a non-enumberable property on the `Compiler` instance.
               *
               * ```js
               * compiler.define('foo', 'bar');
               * ```
               * @name .define
               * @param {String} `key` propery name
               * @param {any} `val` property value
               * @return {Object} Returns the Compiler instance for chaining.
               * @api public
               */

              define: function (key, val) {
                define(this, key, val);
                return this;
              },

              /**
               * Emit `node.val`
               */

              emit: function (str, node) {
                this.output += str;
                return str;
              },

              /**
               * Add a compiler `fn` with the given `name`
               */

              set: function (name, fn) {
                this.compilers[name] = fn;
                return this;
              },

              /**
               * Get compiler `name`.
               */

              get: function (name) {
                return this.compilers[name];
              },

              /**
               * Get the previous AST node.
               */

              prev: function (n) {
                return (
                  this.ast.nodes[this.idx - (n || 1)] || {
                    type: "bos",
                    val: "",
                  }
                );
              },

              /**
               * Get the next AST node.
               */

              next: function (n) {
                return (
                  this.ast.nodes[this.idx + (n || 1)] || {
                    type: "eos",
                    val: "",
                  }
                );
              },

              /**
               * Visit `node`.
               */

              visit: function (node, nodes, i) {
                var fn = this.compilers[node.type];
                this.idx = i;

                if (typeof fn !== "function") {
                  throw this.error(
                    'compiler "' + node.type + '" is not registered',
                    node
                  );
                }
                return fn.call(this, node, nodes, i);
              },

              /**
               * Map visit over array of `nodes`.
               */

              mapVisit: function (nodes) {
                if (!Array.isArray(nodes)) {
                  throw new TypeError("expected an array");
                }
                var len = nodes.length;
                var idx = -1;
                while (++idx < len) {
                  this.visit(nodes[idx], nodes, idx);
                }
                return this;
              },

              /**
               * Compile `ast`.
               */

              compile: function (ast, options) {
                var opts = utils.extend({}, this.options, options);
                this.ast = ast;
                this.parsingErrors = this.ast.errors;
                this.output = "";

                // source map support
                if (opts.sourcemap) {
                  var sourcemaps = require("./source-maps");
                  sourcemaps(this);
                  this.mapVisit(this.ast.nodes);
                  this.applySourceMaps();
                  this.map =
                    opts.sourcemap === "generator"
                      ? this.map
                      : this.map.toJSON();
                  return this;
                }

                this.mapVisit(this.ast.nodes);
                return this;
              },
            };

            /**
             * Expose `Compiler`
             */

            module.exports = Compiler;
          }.call(this));
        }.call(this, "/node_modules/snapdragon/lib/compiler.js"));
      },
      {
        "./source-maps": 208,
        "./utils": 209,
        debug: 210,
        "define-property": 212,
        use: 261,
      },
    ],
    206: [
      function (require, module, exports) {
        (function (__filename) {
          (function () {
            "use strict";

            var use = require("use");
            var util = require("util");
            var Cache = require("map-cache");
            var define = require("define-property");
            var debug = require("debug")("snapdragon:parser");
            var Position = require("./position");
            var utils = require("./utils");

            /**
             * Create a new `Parser` with the given `input` and `options`.
             * @param {String} `input`
             * @param {Object} `options`
             * @api public
             */

            function Parser(options) {
              debug("initializing", __filename);
              this.options = utils.extend({ source: "string" }, options);
              this.init(this.options);
              use(this);
            }

            /**
             * Prototype methods
             */

            Parser.prototype = {
              constructor: Parser,

              init: function (options) {
                this.orig = "";
                this.input = "";
                this.parsed = "";

                this.column = 1;
                this.line = 1;

                this.regex = new Cache();
                this.errors = this.errors || [];
                this.parsers = this.parsers || {};
                this.types = this.types || [];
                this.sets = this.sets || {};
                this.fns = this.fns || [];
                this.currentType = "root";

                var pos = this.position();
                this.bos = pos({ type: "bos", val: "" });

                this.ast = {
                  type: "root",
                  errors: this.errors,
                  nodes: [this.bos],
                };

                define(this.bos, "parent", this.ast);
                this.nodes = [this.ast];

                this.count = 0;
                this.setCount = 0;
                this.stack = [];
              },

              /**
               * Throw a formatted error with the cursor column and `msg`.
               * @param {String} `msg` Message to use in the Error.
               */

              error: function (msg, node) {
                var pos = node.position || { start: { column: 0, line: 0 } };
                var line = pos.start.line;
                var column = pos.start.column;
                var source = this.options.source;

                var message =
                  source + " <line:" + line + " column:" + column + ">: " + msg;
                var err = new Error(message);
                err.source = source;
                err.reason = msg;
                err.pos = pos;

                if (this.options.silent) {
                  this.errors.push(err);
                } else {
                  throw err;
                }
              },

              /**
               * Define a non-enumberable property on the `Parser` instance.
               *
               * ```js
               * parser.define('foo', 'bar');
               * ```
               * @name .define
               * @param {String} `key` propery name
               * @param {any} `val` property value
               * @return {Object} Returns the Parser instance for chaining.
               * @api public
               */

              define: function (key, val) {
                define(this, key, val);
                return this;
              },

              /**
               * Mark position and patch `node.position`.
               */

              position: function () {
                var start = { line: this.line, column: this.column };
                var self = this;

                return function (node) {
                  define(node, "position", new Position(start, self));
                  return node;
                };
              },

              /**
               * Set parser `name` with the given `fn`
               * @param {String} `name`
               * @param {Function} `fn`
               * @api public
               */

              set: function (type, fn) {
                if (this.types.indexOf(type) === -1) {
                  this.types.push(type);
                }
                this.parsers[type] = fn.bind(this);
                return this;
              },

              /**
               * Get parser `name`
               * @param {String} `name`
               * @api public
               */

              get: function (name) {
                return this.parsers[name];
              },

              /**
               * Push a `token` onto the `type` stack.
               *
               * @param {String} `type`
               * @return {Object} `token`
               * @api public
               */

              push: function (type, token) {
                this.sets[type] = this.sets[type] || [];
                this.count++;
                this.stack.push(token);
                return this.sets[type].push(token);
              },

              /**
               * Pop a token off of the `type` stack
               * @param {String} `type`
               * @returns {Object} Returns a token
               * @api public
               */

              pop: function (type) {
                this.sets[type] = this.sets[type] || [];
                this.count--;
                this.stack.pop();
                return this.sets[type].pop();
              },

              /**
               * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.
               *
               * @param {String} `type`
               * @return {Boolean}
               * @api public
               */

              isInside: function (type) {
                this.sets[type] = this.sets[type] || [];
                return this.sets[type].length > 0;
              },

              /**
               * Return true if `node` is the given `type`.
               *
               * ```js
               * parser.isType(node, 'brace');
               * ```
               * @param {Object} `node`
               * @param {String} `type`
               * @return {Boolean}
               * @api public
               */

              isType: function (node, type) {
                return node && node.type === type;
              },

              /**
               * Get the previous AST node
               * @return {Object}
               */

              prev: function (n) {
                return this.stack.length > 0
                  ? utils.last(this.stack, n)
                  : utils.last(this.nodes, n);
              },

              /**
               * Update line and column based on `str`.
               */

              consume: function (len) {
                this.input = this.input.substr(len);
              },

              /**
               * Update column based on `str`.
               */

              updatePosition: function (str, len) {
                var lines = str.match(/\n/g);
                if (lines) this.line += lines.length;
                var i = str.lastIndexOf("\n");
                this.column = ~i ? len - i : this.column + len;
                this.parsed += str;
                this.consume(len);
              },

              /**
               * Match `regex`, return captures, and update the cursor position by `match[0]` length.
               * @param {RegExp} `regex`
               * @return {Object}
               */

              match: function (regex) {
                var m = regex.exec(this.input);
                if (m) {
                  this.updatePosition(m[0], m[0].length);
                  return m;
                }
              },

              /**
               * Capture `type` with the given regex.
               * @param {String} `type`
               * @param {RegExp} `regex`
               * @return {Function}
               */

              capture: function (type, regex) {
                if (typeof regex === "function") {
                  return this.set.apply(this, arguments);
                }

                this.regex.set(type, regex);
                this.set(
                  type,
                  function () {
                    var parsed = this.parsed;
                    var pos = this.position();
                    var m = this.match(regex);
                    if (!m || !m[0]) return;

                    var prev = this.prev();
                    var node = pos({
                      type: type,
                      val: m[0],
                      parsed: parsed,
                      rest: this.input,
                    });

                    if (m[1]) {
                      node.inner = m[1];
                    }

                    define(node, "inside", this.stack.length > 0);
                    define(node, "parent", prev);
                    prev.nodes.push(node);
                  }.bind(this)
                );
                return this;
              },

              /**
               * Create a parser with open and close for parens,
               * brackets or braces
               */

              capturePair: function (type, openRegex, closeRegex, fn) {
                this.sets[type] = this.sets[type] || [];

                /**
                 * Open
                 */

                this.set(type + ".open", function () {
                  var parsed = this.parsed;
                  var pos = this.position();
                  var m = this.match(openRegex);
                  if (!m || !m[0]) return;

                  var val = m[0];
                  this.setCount++;
                  this.specialChars = true;
                  var open = pos({
                    type: type + ".open",
                    val: val,
                    rest: this.input,
                  });

                  if (typeof m[1] !== "undefined") {
                    open.inner = m[1];
                  }

                  var prev = this.prev();
                  var node = pos({
                    type: type,
                    nodes: [open],
                  });

                  define(node, "rest", this.input);
                  define(node, "parsed", parsed);
                  define(node, "prefix", m[1]);
                  define(node, "parent", prev);
                  define(open, "parent", node);

                  if (typeof fn === "function") {
                    fn.call(this, open, node);
                  }

                  this.push(type, node);
                  prev.nodes.push(node);
                });

                /**
                 * Close
                 */

                this.set(type + ".close", function () {
                  var pos = this.position();
                  var m = this.match(closeRegex);
                  if (!m || !m[0]) return;

                  var parent = this.pop(type);
                  var node = pos({
                    type: type + ".close",
                    rest: this.input,
                    suffix: m[1],
                    val: m[0],
                  });

                  if (!this.isType(parent, type)) {
                    if (this.options.strict) {
                      throw new Error('missing opening "' + type + '"');
                    }

                    this.setCount--;
                    node.escaped = true;
                    return node;
                  }

                  if (node.suffix === "\\") {
                    parent.escaped = true;
                    node.escaped = true;
                  }

                  parent.nodes.push(node);
                  define(node, "parent", parent);
                });

                return this;
              },

              /**
               * Capture end-of-string
               */

              eos: function () {
                var pos = this.position();
                if (this.input) return;
                var prev = this.prev();

                while (prev.type !== "root" && !prev.visited) {
                  if (this.options.strict === true) {
                    throw new SyntaxError(
                      "invalid syntax:" + util.inspect(prev, null, 2)
                    );
                  }

                  if (!hasDelims(prev)) {
                    prev.parent.escaped = true;
                    prev.escaped = true;
                  }

                  visit(prev, function (node) {
                    if (!hasDelims(node.parent)) {
                      node.parent.escaped = true;
                      node.escaped = true;
                    }
                  });

                  prev = prev.parent;
                }

                var tok = pos({
                  type: "eos",
                  val: this.append || "",
                });

                define(tok, "parent", this.ast);
                return tok;
              },

              /**
               * Run parsers to advance the cursor position
               */

              next: function () {
                var parsed = this.parsed;
                var len = this.types.length;
                var idx = -1;
                var tok;

                while (++idx < len) {
                  if ((tok = this.parsers[this.types[idx]].call(this))) {
                    define(tok, "rest", this.input);
                    define(tok, "parsed", parsed);
                    this.last = tok;
                    return tok;
                  }
                }
              },

              /**
               * Parse the given string.
               * @return {Array}
               */

              parse: function (input) {
                if (typeof input !== "string") {
                  throw new TypeError("expected a string");
                }

                this.init(this.options);
                this.orig = input;
                this.input = input;
                var self = this;

                function parse() {
                  // check input before calling `.next()`
                  input = self.input;

                  // get the next AST ndoe
                  var node = self.next();
                  if (node) {
                    var prev = self.prev();
                    if (prev) {
                      define(node, "parent", prev);
                      if (prev.nodes) {
                        prev.nodes.push(node);
                      }
                    }

                    if (self.sets.hasOwnProperty(prev.type)) {
                      self.currentType = prev.type;
                    }
                  }

                  // if we got here but input is not changed, throw an error
                  if (self.input && input === self.input) {
                    throw new Error(
                      'no parsers registered for: "' +
                        self.input.slice(0, 5) +
                        '"'
                    );
                  }
                }

                while (this.input) parse();
                if (this.stack.length && this.options.strict) {
                  var node = this.stack.pop();
                  throw this.error(
                    "missing opening " + node.type + ': "' + this.orig + '"'
                  );
                }

                var eos = this.eos();
                var tok = this.prev();
                if (tok.type !== "eos") {
                  this.ast.nodes.push(eos);
                }

                return this.ast;
              },
            };

            /**
             * Visit `node` with the given `fn`
             */

            function visit(node, fn) {
              if (!node.visited) {
                define(node, "visited", true);
                return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
              }
              return node;
            }

            /**
             * Map visit over array of `nodes`.
             */

            function mapVisit(nodes, fn) {
              var len = nodes.length;
              var idx = -1;
              while (++idx < len) {
                visit(nodes[idx], fn);
              }
            }

            function hasOpen(node) {
              return node.nodes && node.nodes[0].type === node.type + ".open";
            }

            function hasClose(node) {
              return (
                node.nodes &&
                utils.last(node.nodes).type === node.type + ".close"
              );
            }

            function hasDelims(node) {
              return hasOpen(node) && hasClose(node);
            }

            /**
             * Expose `Parser`
             */

            module.exports = Parser;
          }.call(this));
        }.call(this, "/node_modules/snapdragon/lib/parser.js"));
      },
      {
        "./position": 207,
        "./utils": 209,
        debug: 210,
        "define-property": 212,
        "map-cache": 134,
        use: 261,
        util: 264,
      },
    ],
    207: [
      function (require, module, exports) {
        "use strict";

        var define = require("define-property");

        /**
         * Store position for a node
         */

        module.exports = function Position(start, parser) {
          this.start = start;
          this.end = { line: parser.line, column: parser.column };
          define(this, "content", parser.orig);
          define(this, "source", parser.options.source);
        };
      },
      { "define-property": 212 },
    ],
    208: [
      function (require, module, exports) {
        "use strict";

        var fs = require("fs");
        var path = require("path");
        var define = require("define-property");
        var utils = require("./utils");

        /**
         * Expose `mixin()`.
         * This code is based on `source-maps-support.js` in reworkcss/css
         * https://github.com/reworkcss/css/blob/master/lib/stringify/source-map-support.js
         * Copyright (c) 2012 TJ Holowaychuk <tj@vision-media.ca>
         */

        module.exports = mixin;

        /**
         * Mixin source map support into `compiler`.
         *
         * @param {Object} `compiler`
         * @api public
         */

        function mixin(compiler) {
          define(compiler, "_comment", compiler.comment);
          compiler.map = new utils.SourceMap.SourceMapGenerator();
          compiler.position = { line: 1, column: 1 };
          compiler.content = {};
          compiler.files = {};

          for (var key in exports) {
            define(compiler, key, exports[key]);
          }
        }

        /**
         * Update position.
         *
         * @param {String} str
         */

        exports.updatePosition = function (str) {
          var lines = str.match(/\n/g);
          if (lines) this.position.line += lines.length;
          var i = str.lastIndexOf("\n");
          this.position.column = ~i
            ? str.length - i
            : this.position.column + str.length;
        };

        /**
         * Emit `str` with `position`.
         *
         * @param {String} str
         * @param {Object} [pos]
         * @return {String}
         */

        exports.emit = function (str, node) {
          var position = node.position || {};
          var source = position.source;
          if (source) {
            if (position.filepath) {
              source = utils.unixify(position.filepath);
            }

            this.map.addMapping({
              source: source,
              generated: {
                line: this.position.line,
                column: Math.max(this.position.column - 1, 0),
              },
              original: {
                line: position.start.line,
                column: position.start.column - 1,
              },
            });

            if (position.content) {
              this.addContent(source, position);
            }
            if (position.filepath) {
              this.addFile(source, position);
            }

            this.updatePosition(str);
            this.output += str;
          }
          return str;
        };

        /**
         * Adds a file to the source map output if it has not already been added
         * @param {String} `file`
         * @param {Object} `pos`
         */

        exports.addFile = function (file, position) {
          if (typeof position.content !== "string") return;
          if (Object.prototype.hasOwnProperty.call(this.files, file)) return;
          this.files[file] = position.content;
        };

        /**
         * Adds a content source to the source map output if it has not already been added
         * @param {String} `source`
         * @param {Object} `position`
         */

        exports.addContent = function (source, position) {
          if (typeof position.content !== "string") return;
          if (Object.prototype.hasOwnProperty.call(this.content, source))
            return;
          this.map.setSourceContent(source, position.content);
        };

        /**
         * Applies any original source maps to the output and embeds the source file
         * contents in the source map.
         */

        exports.applySourceMaps = function () {
          Object.keys(this.files).forEach(function (file) {
            var content = this.files[file];
            this.map.setSourceContent(file, content);

            if (this.options.inputSourcemaps === true) {
              var originalMap = utils.sourceMapResolve.resolveSync(
                content,
                file,
                fs.readFileSync
              );
              if (originalMap) {
                var map = new utils.SourceMap.SourceMapConsumer(
                  originalMap.map
                );
                var relativeTo = originalMap.sourcesRelativeTo;
                this.map.applySourceMap(
                  map,
                  file,
                  utils.unixify(path.dirname(relativeTo))
                );
              }
            }
          }, this);
        };

        /**
         * Process comments, drops sourceMap comments.
         * @param {Object} node
         */

        exports.comment = function (node) {
          if (/^# sourceMappingURL=/.test(node.comment)) {
            return this.emit("", node.position);
          }
          return this._comment(node);
        };
      },
      { "./utils": 209, "define-property": 212, fs: 10, path: 177 },
    ],
    209: [
      function (require, module, exports) {
        "use strict";

        /**
         * Module dependencies
         */

        exports.extend = require("extend-shallow");
        exports.SourceMap = require("source-map");
        exports.sourceMapResolve = require("source-map-resolve");

        /**
         * Convert backslash in the given string to forward slashes
         */

        exports.unixify = function (fp) {
          return fp.split(/\\+/).join("/");
        };

        /**
         * Return true if `val` is a non-empty string
         *
         * @param {String} `str`
         * @return {Boolean}
         */

        exports.isString = function (str) {
          return str && typeof str === "string";
        };

        /**
         * Cast `val` to an array
         * @return {Array}
         */

        exports.arrayify = function (val) {
          if (typeof val === "string") return [val];
          return val ? (Array.isArray(val) ? val : [val]) : [];
        };

        /**
         * Get the last `n` element from the given `array`
         * @param {Array} `array`
         * @return {*}
         */

        exports.last = function (arr, n) {
          return arr[arr.length - (n || 1)];
        };
      },
      { "extend-shallow": 61, "source-map": 229, "source-map-resolve": 230 },
    ],
    210: [
      function (require, module, exports) {
        arguments[4][52][0].apply(exports, arguments);
      },
      { "./debug": 211, _process: 179, dup: 52 },
    ],
    211: [
      function (require, module, exports) {
        arguments[4][53][0].apply(exports, arguments);
      },
      { dup: 53, ms: 158 },
    ],
    212: [
      function (require, module, exports) {
        arguments[4][15][0].apply(exports, arguments);
      },
      { dup: 15, "is-descriptor": 217 },
    ],
    213: [
      function (require, module, exports) {
        arguments[4][16][0].apply(exports, arguments);
      },
      { dup: 16, "kind-of": 214 },
    ],
    214: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    215: [
      function (require, module, exports) {
        arguments[4][18][0].apply(exports, arguments);
      },
      { dup: 18, "kind-of": 216 },
    ],
    216: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    217: [
      function (require, module, exports) {
        arguments[4][20][0].apply(exports, arguments);
      },
      {
        dup: 20,
        "is-accessor-descriptor": 213,
        "is-data-descriptor": 215,
        "kind-of": 218,
      },
    ],
    218: [
      function (require, module, exports) {
        arguments[4][5][0].apply(exports, arguments);
      },
      { dup: 5 },
    ],
    219: [
      function (require, module, exports) {
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */

        var util = require("./util");
        var has = Object.prototype.hasOwnProperty;
        var hasNativeMap = typeof Map !== "undefined";

        /**
         * A data structure which is a combination of an array and a set. Adding a new
         * member is O(1), testing for membership is O(1), and finding the index of an
         * element is O(1). Removing elements from the set is not supported. Only
         * strings are supported for membership.
         */
        function ArraySet() {
          this._array = [];
          this._set = hasNativeMap ? new Map() : Object.create(null);
        }

        /**
         * Static method for creating ArraySet instances from an existing array.
         */
        ArraySet.fromArray = function ArraySet_fromArray(
          aArray,
          aAllowDuplicates
        ) {
          var set = new ArraySet();
          for (var i = 0, len = aArray.length; i < len; i++) {
            set.add(aArray[i], aAllowDuplicates);
          }
          return set;
        };

        /**
         * Return how many unique items are in this ArraySet. If duplicates have been
         * added, than those do not count towards the size.
         *
         * @returns Number
         */
        ArraySet.prototype.size = function ArraySet_size() {
          return hasNativeMap
            ? this._set.size
            : Object.getOwnPropertyNames(this._set).length;
        };

        /**
         * Add the given string to this set.
         *
         * @param String aStr
         */
        ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
          var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
          var isDuplicate = hasNativeMap
            ? this.has(aStr)
            : has.call(this._set, sStr);
          var idx = this._array.length;
          if (!isDuplicate || aAllowDuplicates) {
            this._array.push(aStr);
          }
          if (!isDuplicate) {
            if (hasNativeMap) {
              this._set.set(aStr, idx);
            } else {
              this._set[sStr] = idx;
            }
          }
        };

        /**
         * Is the given string a member of this set?
         *
         * @param String aStr
         */
        ArraySet.prototype.has = function ArraySet_has(aStr) {
          if (hasNativeMap) {
            return this._set.has(aStr);
          } else {
            var sStr = util.toSetString(aStr);
            return has.call(this._set, sStr);
          }
        };

        /**
         * What is the index of the given string in the array?
         *
         * @param String aStr
         */
        ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
          if (hasNativeMap) {
            var idx = this._set.get(aStr);
            if (idx >= 0) {
              return idx;
            }
          } else {
            var sStr = util.toSetString(aStr);
            if (has.call(this._set, sStr)) {
              return this._set[sStr];
            }
          }

          throw new Error('"' + aStr + '" is not in the set.');
        };

        /**
         * What is the element at the given index?
         *
         * @param Number aIdx
         */
        ArraySet.prototype.at = function ArraySet_at(aIdx) {
          if (aIdx >= 0 && aIdx < this._array.length) {
            return this._array[aIdx];
          }
          throw new Error("No element indexed by " + aIdx);
        };

        /**
         * Returns the array representation of this set (which has the proper indices
         * indicated by indexOf). Note that this is a copy of the internal array used
         * for storing the members so that no one can mess with internal state.
         */
        ArraySet.prototype.toArray = function ArraySet_toArray() {
          return this._array.slice();
        };

        exports.ArraySet = ArraySet;
      },
      { "./util": 228 },
    ],
    220: [
      function (require, module, exports) {
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         *
         * Based on the Base 64 VLQ implementation in Closure Compiler:
         * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
         *
         * Copyright 2011 The Closure Compiler Authors. All rights reserved.
         * Redistribution and use in source and binary forms, with or without
         * modification, are permitted provided that the following conditions are
         * met:
         *
         *  * Redistributions of source code must retain the above copyright
         *    notice, this list of conditions and the following disclaimer.
         *  * Redistributions in binary form must reproduce the above
         *    copyright notice, this list of conditions and the following
         *    disclaimer in the documentation and/or other materials provided
         *    with the distribution.
         *  * Neither the name of Google Inc. nor the names of its
         *    contributors may be used to endorse or promote products derived
         *    from this software without specific prior written permission.
         *
         * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
         * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
         * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
         * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
         * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
         * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
         * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
         * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
         * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
         * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         */

        var base64 = require("./base64");

        // A single base 64 digit can contain 6 bits of data. For the base 64 variable
        // length quantities we use in the source map spec, the first bit is the sign,
        // the next four bits are the actual value, and the 6th bit is the
        // continuation bit. The continuation bit tells us whether there are more
        // digits in this value following this digit.
        //
        //   Continuation
        //   |    Sign
        //   |    |
        //   V    V
        //   101011

        var VLQ_BASE_SHIFT = 5;

        // binary: 100000
        var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

        // binary: 011111
        var VLQ_BASE_MASK = VLQ_BASE - 1;

        // binary: 100000
        var VLQ_CONTINUATION_BIT = VLQ_BASE;

        /**
         * Converts from a two-complement value to a value where the sign bit is
         * placed in the least significant bit.  For example, as decimals:
         *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
         *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
         */
        function toVLQSigned(aValue) {
          return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
        }

        /**
         * Converts to a two-complement value from a value where the sign bit is
         * placed in the least significant bit.  For example, as decimals:
         *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
         *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
         */
        function fromVLQSigned(aValue) {
          var isNegative = (aValue & 1) === 1;
          var shifted = aValue >> 1;
          return isNegative ? -shifted : shifted;
        }

        /**
         * Returns the base 64 VLQ encoded value.
         */
        exports.encode = function base64VLQ_encode(aValue) {
          var encoded = "";
          var digit;

          var vlq = toVLQSigned(aValue);

          do {
            digit = vlq & VLQ_BASE_MASK;
            vlq >>>= VLQ_BASE_SHIFT;
            if (vlq > 0) {
              // There are still more digits in this value, so we must make sure the
              // continuation bit is marked.
              digit |= VLQ_CONTINUATION_BIT;
            }
            encoded += base64.encode(digit);
          } while (vlq > 0);

          return encoded;
        };

        /**
         * Decodes the next base 64 VLQ value from the given string and returns the
         * value and the rest of the string via the out parameter.
         */
        exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
          var strLen = aStr.length;
          var result = 0;
          var shift = 0;
          var continuation, digit;

          do {
            if (aIndex >= strLen) {
              throw new Error("Expected more digits in base 64 VLQ value.");
            }

            digit = base64.decode(aStr.charCodeAt(aIndex++));
            if (digit === -1) {
              throw new Error(
                "Invalid base64 digit: " + aStr.charAt(aIndex - 1)
              );
            }

            continuation = !!(digit & VLQ_CONTINUATION_BIT);
            digit &= VLQ_BASE_MASK;
            result = result + (digit << shift);
            shift += VLQ_BASE_SHIFT;
          } while (continuation);

          aOutParam.value = fromVLQSigned(result);
          aOutParam.rest = aIndex;
        };
      },
      { "./base64": 221 },
    ],
    221: [
      function (require, module, exports) {
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */

        var intToCharMap =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
            ""
          );

        /**
         * Encode an integer in the range of 0 to 63 to a single base 64 digit.
         */
        exports.encode = function (number) {
          if (0 <= number && number < intToCharMap.length) {
            return intToCharMap[number];
          }
          throw new TypeError("Must be between 0 and 63: " + number);
        };

        /**
         * Decode a single base 64 character code digit to an integer. Returns -1 on
         * failure.
         */
        exports.decode = function (charCode) {
          var bigA = 65; // 'A'
          var bigZ = 90; // 'Z'

          var littleA = 97; // 'a'
          var littleZ = 122; // 'z'

          var zero = 48; // '0'
          var nine = 57; // '9'

          var plus = 43; // '+'
          var slash = 47; // '/'

          var littleOffset = 26;
          var numberOffset = 52;

          // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
          if (bigA <= charCode && charCode <= bigZ) {
            return charCode - bigA;
          }

          // 26 - 51: abcdefghijklmnopqrstuvwxyz
          if (littleA <= charCode && charCode <= littleZ) {
            return charCode - littleA + littleOffset;
          }

          // 52 - 61: 0123456789
          if (zero <= charCode && charCode <= nine) {
            return charCode - zero + numberOffset;
          }

          // 62: +
          if (charCode == plus) {
            return 62;
          }

          // 63: /
          if (charCode == slash) {
            return 63;
          }

          // Invalid base64 digit.
          return -1;
        };
      },
      {},
    ],
    222: [
      function (require, module, exports) {
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */

        exports.GREATEST_LOWER_BOUND = 1;
        exports.LEAST_UPPER_BOUND = 2;

        /**
         * Recursive implementation of binary search.
         *
         * @param aLow Indices here and lower do not contain the needle.
         * @param aHigh Indices here and higher do not contain the needle.
         * @param aNeedle The element being searched for.
         * @param aHaystack The non-empty array being searched.
         * @param aCompare Function which takes two elements and returns -1, 0, or 1.
         * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
         *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
         *     closest element that is smaller than or greater than the one we are
         *     searching for, respectively, if the exact element cannot be found.
         */
        function recursiveSearch(
          aLow,
          aHigh,
          aNeedle,
          aHaystack,
          aCompare,
          aBias
        ) {
          // This function terminates when one of the following is true:
          //
          //   1. We find the exact element we are looking for.
          //
          //   2. We did not find the exact element, but we can return the index of
          //      the next-closest element.
          //
          //   3. We did not find the exact element, and there is no next-closest
          //      element than the one we are searching for, so we return -1.
          var mid = Math.floor((aHigh - aLow) / 2) + aLow;
          var cmp = aCompare(aNeedle, aHaystack[mid], true);
          if (cmp === 0) {
            // Found the element we are looking for.
            return mid;
          } else if (cmp > 0) {
            // Our needle is greater than aHaystack[mid].
            if (aHigh - mid > 1) {
              // The element is in the upper half.
              return recursiveSearch(
                mid,
                aHigh,
                aNeedle,
                aHaystack,
                aCompare,
                aBias
              );
            }

            // The exact needle element was not found in this haystack. Determine if
            // we are in termination case (3) or (2) and return the appropriate thing.
            if (aBias == exports.LEAST_UPPER_BOUND) {
              return aHigh < aHaystack.length ? aHigh : -1;
            } else {
              return mid;
            }
          } else {
            // Our needle is less than aHaystack[mid].
            if (mid - aLow > 1) {
              // The element is in the lower half.
              return recursiveSearch(
                aLow,
                mid,
                aNeedle,
                aHaystack,
                aCompare,
                aBias
              );
            }

            // we are in termination case (3) or (2) and return the appropriate thing.
            if (aBias == exports.LEAST_UPPER_BOUND) {
              return mid;
            } else {
              return aLow < 0 ? -1 : aLow;
            }
          }
        }

        /**
         * This is an implementation of binary search which will always try and return
         * the index of the closest element if there is no exact hit. This is because
         * mappings between original and generated line/col pairs are single points,
         * and there is an implicit region between each of them, so a miss just means
         * that you aren't on the very start of a region.
         *
         * @param aNeedle The element you are looking for.
         * @param aHaystack The array that is being searched.
         * @param aCompare A function which takes the needle and an element in the
         *     array and returns -1, 0, or 1 depending on whether the needle is less
         *     than, equal to, or greater than the element, respectively.
         * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
         *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
         *     closest element that is smaller than or greater than the one we are
         *     searching for, respectively, if the exact element cannot be found.
         *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
         */
        exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
          if (aHaystack.length === 0) {
            return -1;
          }

          var index = recursiveSearch(
            -1,
            aHaystack.length,
            aNeedle,
            aHaystack,
            aCompare,
            aBias || exports.GREATEST_LOWER_BOUND
          );
          if (index < 0) {
            return -1;
          }

          // We have found either the exact element, or the next-closest element than
          // the one we are searching for. However, there may be more than one such
          // element. Make sure we always return the smallest of these.
          while (index - 1 >= 0) {
            if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
              break;
            }
            --index;
          }

          return index;
        };
      },
      {},
    ],
    223: [
      function (require, module, exports) {
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2014 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */

        var util = require("./util");

        /**
         * Determine whether mappingB is after mappingA with respect to generated
         * position.
         */
        function generatedPositionAfter(mappingA, mappingB) {
          // Optimized for most common case
          var lineA = mappingA.generatedLine;
          var lineB = mappingB.generatedLine;
          var columnA = mappingA.generatedColumn;
          var columnB = mappingB.generatedColumn;
          return (
            lineB > lineA ||
            (lineB == lineA && columnB >= columnA) ||
            util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
          );
        }

        /**
         * A data structure to provide a sorted view of accumulated mappings in a
         * performance conscious manner. It trades a neglibable overhead in general
         * case for a large speedup in case of mappings being added in order.
         */
        function MappingList() {
          this._array = [];
          this._sorted = true;
          // Serves as infimum
          this._last = { generatedLine: -1, generatedColumn: 0 };
        }

        /**
         * Iterate through internal items. This method takes the same arguments that
         * `Array.prototype.forEach` takes.
         *
         * NOTE: The order of the mappings is NOT guaranteed.
         */
        MappingList.prototype.unsortedForEach = function MappingList_forEach(
          aCallback,
          aThisArg
        ) {
          this._array.forEach(aCallback, aThisArg);
        };

        /**
         * Add the given source mapping.
         *
         * @param Object aMapping
         */
        MappingList.prototype.add = function MappingList_add(aMapping) {
          if (generatedPositionAfter(this._last, aMapping)) {
            this._last = aMapping;
            this._array.push(aMapping);
          } else {
            this._sorted = false;
            this._array.push(aMapping);
          }
        };

        /**
         * Returns the flat, sorted array of mappings. The mappings are sorted by
         * generated position.
         *
         * WARNING: This method returns internal data without copying, for
         * performance. The return value must NOT be mutated, and should be treated as
         * an immutable borrow. If you want to take ownership, you must make your own
         * copy.
         */
        MappingList.prototype.toArray = function MappingList_toArray() {
          if (!this._sorted) {
            this._array.sort(util.compareByGeneratedPositionsInflated);
            this._sorted = true;
          }
          return this._array;
        };

        exports.MappingList = MappingList;
      },
      { "./util": 228 },
    ],
    224: [
      function (require, module, exports) {
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */

        // It turns out that some (most?) JavaScript engines don't self-host
        // `Array.prototype.sort`. This makes sense because C++ will likely remain
        // faster than JS when doing raw CPU-intensive sorting. However, when using a
        // custom comparator function, calling back and forth between the VM's C++ and
        // JIT'd JS is rather slow *and* loses JIT type information, resulting in
        // worse generated code for the comparator function than would be optimal. In
        // fact, when sorting with a comparator, these costs outweigh the benefits of
        // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
        // a ~3500ms mean speed-up in `bench/bench.html`.

        /**
         * Swap the elements indexed by `x` and `y` in the array `ary`.
         *
         * @param {Array} ary
         *        The array.
         * @param {Number} x
         *        The index of the first item.
         * @param {Number} y
         *        The index of the second item.
         */
        function swap(ary, x, y) {
          var temp = ary[x];
          ary[x] = ary[y];
          ary[y] = temp;
        }

        /**
         * Returns a random integer within the range `low .. high` inclusive.
         *
         * @param {Number} low
         *        The lower bound on the range.
         * @param {Number} high
         *        The upper bound on the range.
         */
        function randomIntInRange(low, high) {
          return Math.round(low + Math.random() * (high - low));
        }

        /**
         * The Quick Sort algorithm.
         *
         * @param {Array} ary
         *        An array to sort.
         * @param {function} comparator
         *        Function to use to compare two items.
         * @param {Number} p
         *        Start index of the array
         * @param {Number} r
         *        End index of the array
         */
        function doQuickSort(ary, comparator, p, r) {
          // If our lower bound is less than our upper bound, we (1) partition the
          // array into two pieces and (2) recurse on each half. If it is not, this is
          // the empty array and our base case.

          if (p < r) {
            // (1) Partitioning.
            //
            // The partitioning chooses a pivot between `p` and `r` and moves all
            // elements that are less than or equal to the pivot to the before it, and
            // all the elements that are greater than it after it. The effect is that
            // once partition is done, the pivot is in the exact place it will be when
            // the array is put in sorted order, and it will not need to be moved
            // again. This runs in O(n) time.

            // Always choose a random pivot so that an input array which is reverse
            // sorted does not cause O(n^2) running time.
            var pivotIndex = randomIntInRange(p, r);
            var i = p - 1;

            swap(ary, pivotIndex, r);
            var pivot = ary[r];

            // Immediately after `j` is incremented in this loop, the following hold
            // true:
            //
            //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
            //
            //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
            for (var j = p; j < r; j++) {
              if (comparator(ary[j], pivot) <= 0) {
                i += 1;
                swap(ary, i, j);
              }
            }

            swap(ary, i + 1, j);
            var q = i + 1;

            // (2) Recurse on each half.

            doQuickSort(ary, comparator, p, q - 1);
            doQuickSort(ary, comparator, q + 1, r);
          }
        }

        /**
         * Sort the given array in-place with the given comparator function.
         *
         * @param {Array} ary
         *        An array to sort.
         * @param {function} comparator
         *        Function to use to compare two items.
         */
        exports.quickSort = function (ary, comparator) {
          doQuickSort(ary, comparator, 0, ary.length - 1);
        };
      },
      {},
    ],
    225: [
      function (require, module, exports) {
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */

        var util = require("./util");
        var binarySearch = require("./binary-search");
        var ArraySet = require("./array-set").ArraySet;
        var base64VLQ = require("./base64-vlq");
        var quickSort = require("./quick-sort").quickSort;

        function SourceMapConsumer(aSourceMap) {
          var sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
          }

          return sourceMap.sections != null
            ? new IndexedSourceMapConsumer(sourceMap)
            : new BasicSourceMapConsumer(sourceMap);
        }

        SourceMapConsumer.fromSourceMap = function (aSourceMap) {
          return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
        };

        /**
         * The version of the source mapping spec that we are consuming.
         */
        SourceMapConsumer.prototype._version = 3;

        // `__generatedMappings` and `__originalMappings` are arrays that hold the
        // parsed mapping coordinates from the source map's "mappings" attribute. They
        // are lazily instantiated, accessed via the `_generatedMappings` and
        // `_originalMappings` getters respectively, and we only parse the mappings
        // and create these arrays once queried for a source location. We jump through
        // these hoops because there can be many thousands of mappings, and parsing
        // them is expensive, so we only want to do it if we must.
        //
        // Each object in the arrays is of the form:
        //
        //     {
        //       generatedLine: The line number in the generated code,
        //       generatedColumn: The column number in the generated code,
        //       source: The path to the original source file that generated this
        //               chunk of code,
        //       originalLine: The line number in the original source that
        //                     corresponds to this chunk of generated code,
        //       originalColumn: The column number in the original source that
        //                       corresponds to this chunk of generated code,
        //       name: The name of the original symbol which generated this chunk of
        //             code.
        //     }
        //
        // All properties except for `generatedLine` and `generatedColumn` can be
        // `null`.
        //
        // `_generatedMappings` is ordered by the generated positions.
        //
        // `_originalMappings` is ordered by the original positions.

        SourceMapConsumer.prototype.__generatedMappings = null;
        Object.defineProperty(
          SourceMapConsumer.prototype,
          "_generatedMappings",
          {
            get: function () {
              if (!this.__generatedMappings) {
                this._parseMappings(this._mappings, this.sourceRoot);
              }

              return this.__generatedMappings;
            },
          }
        );

        SourceMapConsumer.prototype.__originalMappings = null;
        Object.defineProperty(
          SourceMapConsumer.prototype,
          "_originalMappings",
          {
            get: function () {
              if (!this.__originalMappings) {
                this._parseMappings(this._mappings, this.sourceRoot);
              }

              return this.__originalMappings;
            },
          }
        );

        SourceMapConsumer.prototype._charIsMappingSeparator =
          function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
            var c = aStr.charAt(index);
            return c === ";" || c === ",";
          };

        /**
         * Parse the mappings in a string in to a data structure which we can easily
         * query (the ordered arrays in the `this.__generatedMappings` and
         * `this.__originalMappings` properties).
         */
        SourceMapConsumer.prototype._parseMappings =
          function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
            throw new Error("Subclasses must implement _parseMappings");
          };

        SourceMapConsumer.GENERATED_ORDER = 1;
        SourceMapConsumer.ORIGINAL_ORDER = 2;

        SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
        SourceMapConsumer.LEAST_UPPER_BOUND = 2;

        /**
         * Iterate over each mapping between an original source/line/column and a
         * generated line/column in this source map.
         *
         * @param Function aCallback
         *        The function that is called with each mapping.
         * @param Object aContext
         *        Optional. If specified, this object will be the value of `this` every
         *        time that `aCallback` is called.
         * @param aOrder
         *        Either `SourceMapConsumer.GENERATED_ORDER` or
         *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
         *        iterate over the mappings sorted by the generated file's line/column
         *        order or the original's source/line/column order, respectively. Defaults to
         *        `SourceMapConsumer.GENERATED_ORDER`.
         */
        SourceMapConsumer.prototype.eachMapping =
          function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
            var context = aContext || null;
            var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

            var mappings;
            switch (order) {
              case SourceMapConsumer.GENERATED_ORDER:
                mappings = this._generatedMappings;
                break;
              case SourceMapConsumer.ORIGINAL_ORDER:
                mappings = this._originalMappings;
                break;
              default:
                throw new Error("Unknown order of iteration.");
            }

            var sourceRoot = this.sourceRoot;
            mappings
              .map(function (mapping) {
                var source =
                  mapping.source === null
                    ? null
                    : this._sources.at(mapping.source);
                if (source != null && sourceRoot != null) {
                  source = util.join(sourceRoot, source);
                }
                return {
                  source: source,
                  generatedLine: mapping.generatedLine,
                  generatedColumn: mapping.generatedColumn,
                  originalLine: mapping.originalLine,
                  originalColumn: mapping.originalColumn,
                  name:
                    mapping.name === null ? null : this._names.at(mapping.name),
                };
              }, this)
              .forEach(aCallback, context);
          };

        /**
         * Returns all generated line and column information for the original source,
         * line, and column provided. If no column is provided, returns all mappings
         * corresponding to a either the line we are searching for or the next
         * closest line that has any mappings. Otherwise, returns all mappings
         * corresponding to the given line and either the column we are searching for
         * or the next closest column that has any offsets.
         *
         * The only argument is an object with the following properties:
         *
         *   - source: The filename of the original source.
         *   - line: The line number in the original source.
         *   - column: Optional. the column number in the original source.
         *
         * and an array of objects is returned, each with the following properties:
         *
         *   - line: The line number in the generated source, or null.
         *   - column: The column number in the generated source, or null.
         */
        SourceMapConsumer.prototype.allGeneratedPositionsFor =
          function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
            var line = util.getArg(aArgs, "line");

            // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
            // returns the index of the closest mapping less than the needle. By
            // setting needle.originalColumn to 0, we thus find the last mapping for
            // the given line, provided such a mapping exists.
            var needle = {
              source: util.getArg(aArgs, "source"),
              originalLine: line,
              originalColumn: util.getArg(aArgs, "column", 0),
            };

            if (this.sourceRoot != null) {
              needle.source = util.relative(this.sourceRoot, needle.source);
            }
            if (!this._sources.has(needle.source)) {
              return [];
            }
            needle.source = this._sources.indexOf(needle.source);

            var mappings = [];

            var index = this._findMapping(
              needle,
              this._originalMappings,
              "originalLine",
              "originalColumn",
              util.compareByOriginalPositions,
              binarySearch.LEAST_UPPER_BOUND
            );
            if (index >= 0) {
              var mapping = this._originalMappings[index];

              if (aArgs.column === undefined) {
                var originalLine = mapping.originalLine;

                // Iterate until either we run out of mappings, or we run into
                // a mapping for a different line than the one we found. Since
                // mappings are sorted, this is guaranteed to find all mappings for
                // the line we found.
                while (mapping && mapping.originalLine === originalLine) {
                  mappings.push({
                    line: util.getArg(mapping, "generatedLine", null),
                    column: util.getArg(mapping, "generatedColumn", null),
                    lastColumn: util.getArg(
                      mapping,
                      "lastGeneratedColumn",
                      null
                    ),
                  });

                  mapping = this._originalMappings[++index];
                }
              } else {
                var originalColumn = mapping.originalColumn;

                // Iterate until either we run out of mappings, or we run into
                // a mapping for a different line than the one we were searching for.
                // Since mappings are sorted, this is guaranteed to find all mappings for
                // the line we are searching for.
                while (
                  mapping &&
                  mapping.originalLine === line &&
                  mapping.originalColumn == originalColumn
                ) {
                  mappings.push({
                    line: util.getArg(mapping, "generatedLine", null),
                    column: util.getArg(mapping, "generatedColumn", null),
                    lastColumn: util.getArg(
                      mapping,
                      "lastGeneratedColumn",
                      null
                    ),
                  });

                  mapping = this._originalMappings[++index];
                }
              }
            }

            return mappings;
          };

        exports.SourceMapConsumer = SourceMapConsumer;

        /**
         * A BasicSourceMapConsumer instance represents a parsed source map which we can
         * query for information about the original file positions by giving it a file
         * position in the generated source.
         *
         * The only parameter is the raw source map (either as a JSON string, or
         * already parsed to an object). According to the spec, source maps have the
         * following attributes:
         *
         *   - version: Which version of the source map spec this map is following.
         *   - sources: An array of URLs to the original source files.
         *   - names: An array of identifiers which can be referrenced by individual mappings.
         *   - sourceRoot: Optional. The URL root from which all sources are relative.
         *   - sourcesContent: Optional. An array of contents of the original source files.
         *   - mappings: A string of base64 VLQs which contain the actual mappings.
         *   - file: Optional. The generated file this source map is associated with.
         *
         * Here is an example source map, taken from the source map spec[0]:
         *
         *     {
         *       version : 3,
         *       file: "out.js",
         *       sourceRoot : "",
         *       sources: ["foo.js", "bar.js"],
         *       names: ["src", "maps", "are", "fun"],
         *       mappings: "AA,AB;;ABCDE;"
         *     }
         *
         * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
         */
        function BasicSourceMapConsumer(aSourceMap) {
          var sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
          }

          var version = util.getArg(sourceMap, "version");
          var sources = util.getArg(sourceMap, "sources");
          // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
          // requires the array) to play nice here.
          var names = util.getArg(sourceMap, "names", []);
          var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
          var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
          var mappings = util.getArg(sourceMap, "mappings");
          var file = util.getArg(sourceMap, "file", null);

          // Once again, Sass deviates from the spec and supplies the version as a
          // string rather than a number, so we use loose equality checking here.
          if (version != this._version) {
            throw new Error("Unsupported version: " + version);
          }

          sources = sources
            .map(String)
            // Some source maps produce relative source paths like "./foo.js" instead of
            // "foo.js".  Normalize these first so that future comparisons will succeed.
            // See bugzil.la/1090768.
            .map(util.normalize)
            // Always ensure that absolute sources are internally stored relative to
            // the source root, if the source root is absolute. Not doing this would
            // be particularly problematic when the source root is a prefix of the
            // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
            .map(function (source) {
              return sourceRoot &&
                util.isAbsolute(sourceRoot) &&
                util.isAbsolute(source)
                ? util.relative(sourceRoot, source)
                : source;
            });

          // Pass `true` below to allow duplicate names and sources. While source maps
          // are intended to be compressed and deduplicated, the TypeScript compiler
          // sometimes generates source maps with duplicates in them. See Github issue
          // #72 and bugzil.la/889492.
          this._names = ArraySet.fromArray(names.map(String), true);
          this._sources = ArraySet.fromArray(sources, true);

          this.sourceRoot = sourceRoot;
          this.sourcesContent = sourcesContent;
          this._mappings = mappings;
          this.file = file;
        }

        BasicSourceMapConsumer.prototype = Object.create(
          SourceMapConsumer.prototype
        );
        BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

        /**
         * Create a BasicSourceMapConsumer from a SourceMapGenerator.
         *
         * @param SourceMapGenerator aSourceMap
         *        The source map that will be consumed.
         * @returns BasicSourceMapConsumer
         */
        BasicSourceMapConsumer.fromSourceMap =
          function SourceMapConsumer_fromSourceMap(aSourceMap) {
            var smc = Object.create(BasicSourceMapConsumer.prototype);

            var names = (smc._names = ArraySet.fromArray(
              aSourceMap._names.toArray(),
              true
            ));
            var sources = (smc._sources = ArraySet.fromArray(
              aSourceMap._sources.toArray(),
              true
            ));
            smc.sourceRoot = aSourceMap._sourceRoot;
            smc.sourcesContent = aSourceMap._generateSourcesContent(
              smc._sources.toArray(),
              smc.sourceRoot
            );
            smc.file = aSourceMap._file;

            // Because we are modifying the entries (by converting string sources and
            // names to indices into the sources and names ArraySets), we have to make
            // a copy of the entry or else bad things happen. Shared mutable state
            // strikes again! See github issue #191.

            var generatedMappings = aSourceMap._mappings.toArray().slice();
            var destGeneratedMappings = (smc.__generatedMappings = []);
            var destOriginalMappings = (smc.__originalMappings = []);

            for (
              var i = 0, length = generatedMappings.length;
              i < length;
              i++
            ) {
              var srcMapping = generatedMappings[i];
              var destMapping = new Mapping();
              destMapping.generatedLine = srcMapping.generatedLine;
              destMapping.generatedColumn = srcMapping.generatedColumn;

              if (srcMapping.source) {
                destMapping.source = sources.indexOf(srcMapping.source);
                destMapping.originalLine = srcMapping.originalLine;
                destMapping.originalColumn = srcMapping.originalColumn;

                if (srcMapping.name) {
                  destMapping.name = names.indexOf(srcMapping.name);
                }

                destOriginalMappings.push(destMapping);
              }

              destGeneratedMappings.push(destMapping);
            }

            quickSort(smc.__originalMappings, util.compareByOriginalPositions);

            return smc;
          };

        /**
         * The version of the source mapping spec that we are consuming.
         */
        BasicSourceMapConsumer.prototype._version = 3;

        /**
         * The list of original sources.
         */
        Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
          get: function () {
            return this._sources.toArray().map(function (s) {
              return this.sourceRoot != null
                ? util.join(this.sourceRoot, s)
                : s;
            }, this);
          },
        });

        /**
         * Provide the JIT with a nice shape / hidden class.
         */
        function Mapping() {
          this.generatedLine = 0;
          this.generatedColumn = 0;
          this.source = null;
          this.originalLine = null;
          this.originalColumn = null;
          this.name = null;
        }

        /**
         * Parse the mappings in a string in to a data structure which we can easily
         * query (the ordered arrays in the `this.__generatedMappings` and
         * `this.__originalMappings` properties).
         */
        BasicSourceMapConsumer.prototype._parseMappings =
          function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
            var generatedLine = 1;
            var previousGeneratedColumn = 0;
            var previousOriginalLine = 0;
            var previousOriginalColumn = 0;
            var previousSource = 0;
            var previousName = 0;
            var length = aStr.length;
            var index = 0;
            var cachedSegments = {};
            var temp = {};
            var originalMappings = [];
            var generatedMappings = [];
            var mapping, str, segment, end, value;

            while (index < length) {
              if (aStr.charAt(index) === ";") {
                generatedLine++;
                index++;
                previousGeneratedColumn = 0;
              } else if (aStr.charAt(index) === ",") {
                index++;
              } else {
                mapping = new Mapping();
                mapping.generatedLine = generatedLine;

                // Because each offset is encoded relative to the previous one,
                // many segments often have the same encoding. We can exploit this
                // fact by caching the parsed variable length fields of each segment,
                // allowing us to avoid a second parse if we encounter the same
                // segment again.
                for (end = index; end < length; end++) {
                  if (this._charIsMappingSeparator(aStr, end)) {
                    break;
                  }
                }
                str = aStr.slice(index, end);

                segment = cachedSegments[str];
                if (segment) {
                  index += str.length;
                } else {
                  segment = [];
                  while (index < end) {
                    base64VLQ.decode(aStr, index, temp);
                    value = temp.value;
                    index = temp.rest;
                    segment.push(value);
                  }

                  if (segment.length === 2) {
                    throw new Error("Found a source, but no line and column");
                  }

                  if (segment.length === 3) {
                    throw new Error("Found a source and line, but no column");
                  }

                  cachedSegments[str] = segment;
                }

                // Generated column.
                mapping.generatedColumn = previousGeneratedColumn + segment[0];
                previousGeneratedColumn = mapping.generatedColumn;

                if (segment.length > 1) {
                  // Original source.
                  mapping.source = previousSource + segment[1];
                  previousSource += segment[1];

                  // Original line.
                  mapping.originalLine = previousOriginalLine + segment[2];
                  previousOriginalLine = mapping.originalLine;
                  // Lines are stored 0-based
                  mapping.originalLine += 1;

                  // Original column.
                  mapping.originalColumn = previousOriginalColumn + segment[3];
                  previousOriginalColumn = mapping.originalColumn;

                  if (segment.length > 4) {
                    // Original name.
                    mapping.name = previousName + segment[4];
                    previousName += segment[4];
                  }
                }

                generatedMappings.push(mapping);
                if (typeof mapping.originalLine === "number") {
                  originalMappings.push(mapping);
                }
              }
            }

            quickSort(
              generatedMappings,
              util.compareByGeneratedPositionsDeflated
            );
            this.__generatedMappings = generatedMappings;

            quickSort(originalMappings, util.compareByOriginalPositions);
            this.__originalMappings = originalMappings;
          };

        /**
         * Find the mapping that best matches the hypothetical "needle" mapping that
         * we are searching for in the given "haystack" of mappings.
         */
        BasicSourceMapConsumer.prototype._findMapping =
          function SourceMapConsumer_findMapping(
            aNeedle,
            aMappings,
            aLineName,
            aColumnName,
            aComparator,
            aBias
          ) {
            // To return the position we are searching for, we must first find the
            // mapping for the given position and then return the opposite position it
            // points to. Because the mappings are sorted, we can use binary search to
            // find the best mapping.

            if (aNeedle[aLineName] <= 0) {
              throw new TypeError(
                "Line must be greater than or equal to 1, got " +
                  aNeedle[aLineName]
              );
            }
            if (aNeedle[aColumnName] < 0) {
              throw new TypeError(
                "Column must be greater than or equal to 0, got " +
                  aNeedle[aColumnName]
              );
            }

            return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
          };

        /**
         * Compute the last column for each generated mapping. The last column is
         * inclusive.
         */
        BasicSourceMapConsumer.prototype.computeColumnSpans =
          function SourceMapConsumer_computeColumnSpans() {
            for (
              var index = 0;
              index < this._generatedMappings.length;
              ++index
            ) {
              var mapping = this._generatedMappings[index];

              // Mappings do not contain a field for the last generated columnt. We
              // can come up with an optimistic estimate, however, by assuming that
              // mappings are contiguous (i.e. given two consecutive mappings, the
              // first mapping ends where the second one starts).
              if (index + 1 < this._generatedMappings.length) {
                var nextMapping = this._generatedMappings[index + 1];

                if (mapping.generatedLine === nextMapping.generatedLine) {
                  mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                  continue;
                }
              }

              // The last mapping for each line spans the entire line.
              mapping.lastGeneratedColumn = Infinity;
            }
          };

        /**
         * Returns the original source, line, and column information for the generated
         * source's line and column positions provided. The only argument is an object
         * with the following properties:
         *
         *   - line: The line number in the generated source.
         *   - column: The column number in the generated source.
         *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
         *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
         *     closest element that is smaller than or greater than the one we are
         *     searching for, respectively, if the exact element cannot be found.
         *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
         *
         * and an object is returned with the following properties:
         *
         *   - source: The original source file, or null.
         *   - line: The line number in the original source, or null.
         *   - column: The column number in the original source, or null.
         *   - name: The original identifier, or null.
         */
        BasicSourceMapConsumer.prototype.originalPositionFor =
          function SourceMapConsumer_originalPositionFor(aArgs) {
            var needle = {
              generatedLine: util.getArg(aArgs, "line"),
              generatedColumn: util.getArg(aArgs, "column"),
            };

            var index = this._findMapping(
              needle,
              this._generatedMappings,
              "generatedLine",
              "generatedColumn",
              util.compareByGeneratedPositionsDeflated,
              util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
            );

            if (index >= 0) {
              var mapping = this._generatedMappings[index];

              if (mapping.generatedLine === needle.generatedLine) {
                var source = util.getArg(mapping, "source", null);
                if (source !== null) {
                  source = this._sources.at(source);
                  if (this.sourceRoot != null) {
                    source = util.join(this.sourceRoot, source);
                  }
                }
                var name = util.getArg(mapping, "name", null);
                if (name !== null) {
                  name = this._names.at(name);
                }
                return {
                  source: source,
                  line: util.getArg(mapping, "originalLine", null),
                  column: util.getArg(mapping, "originalColumn", null),
                  name: name,
                };
              }
            }

            return {
              source: null,
              line: null,
              column: null,
              name: null,
            };
          };

        /**
         * Return true if we have the source content for every source in the source
         * map, false otherwise.
         */
        BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
          function BasicSourceMapConsumer_hasContentsOfAllSources() {
            if (!this.sourcesContent) {
              return false;
            }
            return (
              this.sourcesContent.length >= this._sources.size() &&
              !this.sourcesContent.some(function (sc) {
                return sc == null;
              })
            );
          };

        /**
         * Returns the original source content. The only argument is the url of the
         * original source file. Returns null if no original source content is
         * available.
         */
        BasicSourceMapConsumer.prototype.sourceContentFor =
          function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
            if (!this.sourcesContent) {
              return null;
            }

            if (this.sourceRoot != null) {
              aSource = util.relative(this.sourceRoot, aSource);
            }

            if (this._sources.has(aSource)) {
              return this.sourcesContent[this._sources.indexOf(aSource)];
            }

            var url;
            if (
              this.sourceRoot != null &&
              (url = util.urlParse(this.sourceRoot))
            ) {
              // XXX: file:// URIs and absolute paths lead to unexpected behavior for
              // many users. We can help them out when they expect file:// URIs to
              // behave like it would if they were running a local HTTP server. See
              // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
              var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
              if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
                return this.sourcesContent[
                  this._sources.indexOf(fileUriAbsPath)
                ];
              }

              if (
                (!url.path || url.path == "/") &&
                this._sources.has("/" + aSource)
              ) {
                return this.sourcesContent[
                  this._sources.indexOf("/" + aSource)
                ];
              }
            }

            // This function is used recursively from
            // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
            // don't want to throw if we can't find the source - we just want to
            // return null, so we provide a flag to exit gracefully.
            if (nullOnMissing) {
              return null;
            } else {
              throw new Error('"' + aSource + '" is not in the SourceMap.');
            }
          };

        /**
         * Returns the generated line and column information for the original source,
         * line, and column positions provided. The only argument is an object with
         * the following properties:
         *
         *   - source: The filename of the original source.
         *   - line: The line number in the original source.
         *   - column: The column number in the original source.
         *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
         *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
         *     closest element that is smaller than or greater than the one we are
         *     searching for, respectively, if the exact element cannot be found.
         *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
         *
         * and an object is returned with the following properties:
         *
         *   - line: The line number in the generated source, or null.
         *   - column: The column number in the generated source, or null.
         */
        BasicSourceMapConsumer.prototype.generatedPositionFor =
          function SourceMapConsumer_generatedPositionFor(aArgs) {
            var source = util.getArg(aArgs, "source");
            if (this.sourceRoot != null) {
              source = util.relative(this.sourceRoot, source);
            }
            if (!this._sources.has(source)) {
              return {
                line: null,
                column: null,
                lastColumn: null,
              };
            }
            source = this._sources.indexOf(source);

            var needle = {
              source: source,
              originalLine: util.getArg(aArgs, "line"),
              originalColumn: util.getArg(aArgs, "column"),
            };

            var index = this._findMapping(
              needle,
              this._originalMappings,
              "originalLine",
              "originalColumn",
              util.compareByOriginalPositions,
              util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
            );

            if (index >= 0) {
              var mapping = this._originalMappings[index];

              if (mapping.source === needle.source) {
                return {
                  line: util.getArg(mapping, "generatedLine", null),
                  column: util.getArg(mapping, "generatedColumn", null),
                  lastColumn: util.getArg(mapping, "lastGeneratedColumn", null),
                };
              }
            }

            return {
              line: null,
              column: null,
              lastColumn: null,
            };
          };

        exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

        /**
         * An IndexedSourceMapConsumer instance represents a parsed source map which
         * we can query for information. It differs from BasicSourceMapConsumer in
         * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
         * input.
         *
         * The only parameter is a raw source map (either as a JSON string, or already
         * parsed to an object). According to the spec for indexed source maps, they
         * have the following attributes:
         *
         *   - version: Which version of the source map spec this map is following.
         *   - file: Optional. The generated file this source map is associated with.
         *   - sections: A list of section definitions.
         *
         * Each value under the "sections" field has two fields:
         *   - offset: The offset into the original specified at which this section
         *       begins to apply, defined as an object with a "line" and "column"
         *       field.
         *   - map: A source map definition. This source map could also be indexed,
         *       but doesn't have to be.
         *
         * Instead of the "map" field, it's also possible to have a "url" field
         * specifying a URL to retrieve a source map from, but that's currently
         * unsupported.
         *
         * Here's an example source map, taken from the source map spec[0], but
         * modified to omit a section which uses the "url" field.
         *
         *  {
         *    version : 3,
         *    file: "app.js",
         *    sections: [{
         *      offset: {line:100, column:10},
         *      map: {
         *        version : 3,
         *        file: "section.js",
         *        sources: ["foo.js", "bar.js"],
         *        names: ["src", "maps", "are", "fun"],
         *        mappings: "AAAA,E;;ABCDE;"
         *      }
         *    }],
         *  }
         *
         * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
         */
        function IndexedSourceMapConsumer(aSourceMap) {
          var sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
          }

          var version = util.getArg(sourceMap, "version");
          var sections = util.getArg(sourceMap, "sections");

          if (version != this._version) {
            throw new Error("Unsupported version: " + version);
          }

          this._sources = new ArraySet();
          this._names = new ArraySet();

          var lastOffset = {
            line: -1,
            column: 0,
          };
          this._sections = sections.map(function (s) {
            if (s.url) {
              // The url field will require support for asynchronicity.
              // See https://github.com/mozilla/source-map/issues/16
              throw new Error(
                "Support for url field in sections not implemented."
              );
            }
            var offset = util.getArg(s, "offset");
            var offsetLine = util.getArg(offset, "line");
            var offsetColumn = util.getArg(offset, "column");

            if (
              offsetLine < lastOffset.line ||
              (offsetLine === lastOffset.line &&
                offsetColumn < lastOffset.column)
            ) {
              throw new Error(
                "Section offsets must be ordered and non-overlapping."
              );
            }
            lastOffset = offset;

            return {
              generatedOffset: {
                // The offset fields are 0-based, but we use 1-based indices when
                // encoding/decoding from VLQ.
                generatedLine: offsetLine + 1,
                generatedColumn: offsetColumn + 1,
              },
              consumer: new SourceMapConsumer(util.getArg(s, "map")),
            };
          });
        }

        IndexedSourceMapConsumer.prototype = Object.create(
          SourceMapConsumer.prototype
        );
        IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

        /**
         * The version of the source mapping spec that we are consuming.
         */
        IndexedSourceMapConsumer.prototype._version = 3;

        /**
         * The list of original sources.
         */
        Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
          get: function () {
            var sources = [];
            for (var i = 0; i < this._sections.length; i++) {
              for (
                var j = 0;
                j < this._sections[i].consumer.sources.length;
                j++
              ) {
                sources.push(this._sections[i].consumer.sources[j]);
              }
            }
            return sources;
          },
        });

        /**
         * Returns the original source, line, and column information for the generated
         * source's line and column positions provided. The only argument is an object
         * with the following properties:
         *
         *   - line: The line number in the generated source.
         *   - column: The column number in the generated source.
         *
         * and an object is returned with the following properties:
         *
         *   - source: The original source file, or null.
         *   - line: The line number in the original source, or null.
         *   - column: The column number in the original source, or null.
         *   - name: The original identifier, or null.
         */
        IndexedSourceMapConsumer.prototype.originalPositionFor =
          function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
            var needle = {
              generatedLine: util.getArg(aArgs, "line"),
              generatedColumn: util.getArg(aArgs, "column"),
            };

            // Find the section containing the generated position we're trying to map
            // to an original position.
            var sectionIndex = binarySearch.search(
              needle,
              this._sections,
              function (needle, section) {
                var cmp =
                  needle.generatedLine - section.generatedOffset.generatedLine;
                if (cmp) {
                  return cmp;
                }

                return (
                  needle.generatedColumn -
                  section.generatedOffset.generatedColumn
                );
              }
            );
            var section = this._sections[sectionIndex];

            if (!section) {
              return {
                source: null,
                line: null,
                column: null,
                name: null,
              };
            }

            return section.consumer.originalPositionFor({
              line:
                needle.generatedLine -
                (section.generatedOffset.generatedLine - 1),
              column:
                needle.generatedColumn -
                (section.generatedOffset.generatedLine === needle.generatedLine
                  ? section.generatedOffset.generatedColumn - 1
                  : 0),
              bias: aArgs.bias,
            });
          };

        /**
         * Return true if we have the source content for every source in the source
         * map, false otherwise.
         */
        IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
          function IndexedSourceMapConsumer_hasContentsOfAllSources() {
            return this._sections.every(function (s) {
              return s.consumer.hasContentsOfAllSources();
            });
          };

        /**
         * Returns the original source content. The only argument is the url of the
         * original source file. Returns null if no original source content is
         * available.
         */
        IndexedSourceMapConsumer.prototype.sourceContentFor =
          function IndexedSourceMapConsumer_sourceContentFor(
            aSource,
            nullOnMissing
          ) {
            for (var i = 0; i < this._sections.length; i++) {
              var section = this._sections[i];

              var content = section.consumer.sourceContentFor(aSource, true);
              if (content) {
                return content;
              }
            }
            if (nullOnMissing) {
              return null;
            } else {
              throw new Error('"' + aSource + '" is not in the SourceMap.');
            }
          };

        /**
         * Returns the generated line and column information for the original source,
         * line, and column positions provided. The only argument is an object with
         * the following properties:
         *
         *   - source: The filename of the original source.
         *   - line: The line number in the original source.
         *   - column: The column number in the original source.
         *
         * and an object is returned with the following properties:
         *
         *   - line: The line number in the generated source, or null.
         *   - column: The column number in the generated source, or null.
         */
        IndexedSourceMapConsumer.prototype.generatedPositionFor =
          function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
            for (var i = 0; i < this._sections.length; i++) {
              var section = this._sections[i];

              // Only consider this section if the requested source is in the list of
              // sources of the consumer.
              if (
                section.consumer.sources.indexOf(
                  util.getArg(aArgs, "source")
                ) === -1
              ) {
                continue;
              }
              var generatedPosition =
                section.consumer.generatedPositionFor(aArgs);
              if (generatedPosition) {
                var ret = {
                  line:
                    generatedPosition.line +
                    (section.generatedOffset.generatedLine - 1),
                  column:
                    generatedPosition.column +
                    (section.generatedOffset.generatedLine ===
                    generatedPosition.line
                      ? section.generatedOffset.generatedColumn - 1
                      : 0),
                };
                return ret;
              }
            }

            return {
              line: null,
              column: null,
            };
          };

        /**
         * Parse the mappings in a string in to a data structure which we can easily
         * query (the ordered arrays in the `this.__generatedMappings` and
         * `this.__originalMappings` properties).
         */
        IndexedSourceMapConsumer.prototype._parseMappings =
          function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            for (var i = 0; i < this._sections.length; i++) {
              var section = this._sections[i];
              var sectionMappings = section.consumer._generatedMappings;
              for (var j = 0; j < sectionMappings.length; j++) {
                var mapping = sectionMappings[j];

                var source = section.consumer._sources.at(mapping.source);
                if (section.consumer.sourceRoot !== null) {
                  source = util.join(section.consumer.sourceRoot, source);
                }
                this._sources.add(source);
                source = this._sources.indexOf(source);

                var name = section.consumer._names.at(mapping.name);
                this._names.add(name);
                name = this._names.indexOf(name);

                // The mappings coming from the consumer for the section have
                // generated positions relative to the start of the section, so we
                // need to offset them to be relative to the start of the concatenated
                // generated file.
                var adjustedMapping = {
                  source: source,
                  generatedLine:
                    mapping.generatedLine +
                    (section.generatedOffset.generatedLine - 1),
                  generatedColumn:
                    mapping.generatedColumn +
                    (section.generatedOffset.generatedLine ===
                    mapping.generatedLine
                      ? section.generatedOffset.generatedColumn - 1
                      : 0),
                  originalLine: mapping.originalLine,
                  originalColumn: mapping.originalColumn,
                  name: name,
                };

                this.__generatedMappings.push(adjustedMapping);
                if (typeof adjustedMapping.originalLine === "number") {
                  this.__originalMappings.push(adjustedMapping);
                }
              }
            }

            quickSort(
              this.__generatedMappings,
              util.compareByGeneratedPositionsDeflated
            );
            quickSort(this.__originalMappings, util.compareByOriginalPositions);
          };

        exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
      },
      {
        "./array-set": 219,
        "./base64-vlq": 220,
        "./binary-search": 222,
        "./quick-sort": 224,
        "./util": 228,
      },
    ],
    226: [
      function (require, module, exports) {
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */

        var base64VLQ = require("./base64-vlq");
        var util = require("./util");
        var ArraySet = require("./array-set").ArraySet;
        var MappingList = require("./mapping-list").MappingList;

        /**
         * An instance of the SourceMapGenerator represents a source map which is
         * being built incrementally. You may pass an object with the following
         * properties:
         *
         *   - file: The filename of the generated source.
         *   - sourceRoot: A root for all relative URLs in this source map.
         */
        function SourceMapGenerator(aArgs) {
          if (!aArgs) {
            aArgs = {};
          }
          this._file = util.getArg(aArgs, "file", null);
          this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
          this._skipValidation = util.getArg(aArgs, "skipValidation", false);
          this._sources = new ArraySet();
          this._names = new ArraySet();
          this._mappings = new MappingList();
          this._sourcesContents = null;
        }

        SourceMapGenerator.prototype._version = 3;

        /**
         * Creates a new SourceMapGenerator based on a SourceMapConsumer
         *
         * @param aSourceMapConsumer The SourceMap.
         */
        SourceMapGenerator.fromSourceMap =
          function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
            var sourceRoot = aSourceMapConsumer.sourceRoot;
            var generator = new SourceMapGenerator({
              file: aSourceMapConsumer.file,
              sourceRoot: sourceRoot,
            });
            aSourceMapConsumer.eachMapping(function (mapping) {
              var newMapping = {
                generated: {
                  line: mapping.generatedLine,
                  column: mapping.generatedColumn,
                },
              };

              if (mapping.source != null) {
                newMapping.source = mapping.source;
                if (sourceRoot != null) {
                  newMapping.source = util.relative(
                    sourceRoot,
                    newMapping.source
                  );
                }

                newMapping.original = {
                  line: mapping.originalLine,
                  column: mapping.originalColumn,
                };

                if (mapping.name != null) {
                  newMapping.name = mapping.name;
                }
              }

              generator.addMapping(newMapping);
            });
            aSourceMapConsumer.sources.forEach(function (sourceFile) {
              var content = aSourceMapConsumer.sourceContentFor(sourceFile);
              if (content != null) {
                generator.setSourceContent(sourceFile, content);
              }
            });
            return generator;
          };

        /**
         * Add a single mapping from original source line and column to the generated
         * source's line and column for this source map being created. The mapping
         * object should have the following properties:
         *
         *   - generated: An object with the generated line and column positions.
         *   - original: An object with the original line and column positions.
         *   - source: The original source file (relative to the sourceRoot).
         *   - name: An optional original token name for this mapping.
         */
        SourceMapGenerator.prototype.addMapping =
          function SourceMapGenerator_addMapping(aArgs) {
            var generated = util.getArg(aArgs, "generated");
            var original = util.getArg(aArgs, "original", null);
            var source = util.getArg(aArgs, "source", null);
            var name = util.getArg(aArgs, "name", null);

            if (!this._skipValidation) {
              this._validateMapping(generated, original, source, name);
            }

            if (source != null) {
              source = String(source);
              if (!this._sources.has(source)) {
                this._sources.add(source);
              }
            }

            if (name != null) {
              name = String(name);
              if (!this._names.has(name)) {
                this._names.add(name);
              }
            }

            this._mappings.add({
              generatedLine: generated.line,
              generatedColumn: generated.column,
              originalLine: original != null && original.line,
              originalColumn: original != null && original.column,
              source: source,
              name: name,
            });
          };

        /**
         * Set the source content for a source file.
         */
        SourceMapGenerator.prototype.setSourceContent =
          function SourceMapGenerator_setSourceContent(
            aSourceFile,
            aSourceContent
          ) {
            var source = aSourceFile;
            if (this._sourceRoot != null) {
              source = util.relative(this._sourceRoot, source);
            }

            if (aSourceContent != null) {
              // Add the source content to the _sourcesContents map.
              // Create a new _sourcesContents map if the property is null.
              if (!this._sourcesContents) {
                this._sourcesContents = Object.create(null);
              }
              this._sourcesContents[util.toSetString(source)] = aSourceContent;
            } else if (this._sourcesContents) {
              // Remove the source file from the _sourcesContents map.
              // If the _sourcesContents map is empty, set the property to null.
              delete this._sourcesContents[util.toSetString(source)];
              if (Object.keys(this._sourcesContents).length === 0) {
                this._sourcesContents = null;
              }
            }
          };

        /**
         * Applies the mappings of a sub-source-map for a specific source file to the
         * source map being generated. Each mapping to the supplied source file is
         * rewritten using the supplied source map. Note: The resolution for the
         * resulting mappings is the minimium of this map and the supplied map.
         *
         * @param aSourceMapConsumer The source map to be applied.
         * @param aSourceFile Optional. The filename of the source file.
         *        If omitted, SourceMapConsumer's file property will be used.
         * @param aSourceMapPath Optional. The dirname of the path to the source map
         *        to be applied. If relative, it is relative to the SourceMapConsumer.
         *        This parameter is needed when the two source maps aren't in the same
         *        directory, and the source map to be applied contains relative source
         *        paths. If so, those relative source paths need to be rewritten
         *        relative to the SourceMapGenerator.
         */
        SourceMapGenerator.prototype.applySourceMap =
          function SourceMapGenerator_applySourceMap(
            aSourceMapConsumer,
            aSourceFile,
            aSourceMapPath
          ) {
            var sourceFile = aSourceFile;
            // If aSourceFile is omitted, we will use the file property of the SourceMap
            if (aSourceFile == null) {
              if (aSourceMapConsumer.file == null) {
                throw new Error(
                  "SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " +
                    'or the source map\'s "file" property. Both were omitted.'
                );
              }
              sourceFile = aSourceMapConsumer.file;
            }
            var sourceRoot = this._sourceRoot;
            // Make "sourceFile" relative if an absolute Url is passed.
            if (sourceRoot != null) {
              sourceFile = util.relative(sourceRoot, sourceFile);
            }
            // Applying the SourceMap can add and remove items from the sources and
            // the names array.
            var newSources = new ArraySet();
            var newNames = new ArraySet();

            // Find mappings for the "sourceFile"
            this._mappings.unsortedForEach(function (mapping) {
              if (
                mapping.source === sourceFile &&
                mapping.originalLine != null
              ) {
                // Check if it can be mapped by the source map, then update the mapping.
                var original = aSourceMapConsumer.originalPositionFor({
                  line: mapping.originalLine,
                  column: mapping.originalColumn,
                });
                if (original.source != null) {
                  // Copy mapping
                  mapping.source = original.source;
                  if (aSourceMapPath != null) {
                    mapping.source = util.join(aSourceMapPath, mapping.source);
                  }
                  if (sourceRoot != null) {
                    mapping.source = util.relative(sourceRoot, mapping.source);
                  }
                  mapping.originalLine = original.line;
                  mapping.originalColumn = original.column;
                  if (original.name != null) {
                    mapping.name = original.name;
                  }
                }
              }

              var source = mapping.source;
              if (source != null && !newSources.has(source)) {
                newSources.add(source);
              }

              var name = mapping.name;
              if (name != null && !newNames.has(name)) {
                newNames.add(name);
              }
            }, this);
            this._sources = newSources;
            this._names = newNames;

            // Copy sourcesContents of applied map.
            aSourceMapConsumer.sources.forEach(function (sourceFile) {
              var content = aSourceMapConsumer.sourceContentFor(sourceFile);
              if (content != null) {
                if (aSourceMapPath != null) {
                  sourceFile = util.join(aSourceMapPath, sourceFile);
                }
                if (sourceRoot != null) {
                  sourceFile = util.relative(sourceRoot, sourceFile);
                }
                this.setSourceContent(sourceFile, content);
              }
            }, this);
          };

        /**
         * A mapping can have one of the three levels of data:
         *
         *   1. Just the generated position.
         *   2. The Generated position, original position, and original source.
         *   3. Generated and original position, original source, as well as a name
         *      token.
         *
         * To maintain consistency, we validate that any new mapping being added falls
         * in to one of these categories.
         */
        SourceMapGenerator.prototype._validateMapping =
          function SourceMapGenerator_validateMapping(
            aGenerated,
            aOriginal,
            aSource,
            aName
          ) {
            // When aOriginal is truthy but has empty values for .line and .column,
            // it is most likely a programmer error. In this case we throw a very
            // specific error message to try to guide them the right way.
            // For example: https://github.com/Polymer/polymer-bundler/pull/519
            if (
              aOriginal &&
              typeof aOriginal.line !== "number" &&
              typeof aOriginal.column !== "number"
            ) {
              throw new Error(
                "original.line and original.column are not numbers -- you probably meant to omit " +
                  "the original mapping entirely and only map the generated position. If so, pass " +
                  "null for the original mapping instead of an object with empty or null values."
              );
            }

            if (
              aGenerated &&
              "line" in aGenerated &&
              "column" in aGenerated &&
              aGenerated.line > 0 &&
              aGenerated.column >= 0 &&
              !aOriginal &&
              !aSource &&
              !aName
            ) {
              // Case 1.
              return;
            } else if (
              aGenerated &&
              "line" in aGenerated &&
              "column" in aGenerated &&
              aOriginal &&
              "line" in aOriginal &&
              "column" in aOriginal &&
              aGenerated.line > 0 &&
              aGenerated.column >= 0 &&
              aOriginal.line > 0 &&
              aOriginal.column >= 0 &&
              aSource
            ) {
              // Cases 2 and 3.
              return;
            } else {
              throw new Error(
                "Invalid mapping: " +
                  JSON.stringify({
                    generated: aGenerated,
                    source: aSource,
                    original: aOriginal,
                    name: aName,
                  })
              );
            }
          };

        /**
         * Serialize the accumulated mappings in to the stream of base 64 VLQs
         * specified by the source map format.
         */
        SourceMapGenerator.prototype._serializeMappings =
          function SourceMapGenerator_serializeMappings() {
            var previousGeneratedColumn = 0;
            var previousGeneratedLine = 1;
            var previousOriginalColumn = 0;
            var previousOriginalLine = 0;
            var previousName = 0;
            var previousSource = 0;
            var result = "";
            var next;
            var mapping;
            var nameIdx;
            var sourceIdx;

            var mappings = this._mappings.toArray();
            for (var i = 0, len = mappings.length; i < len; i++) {
              mapping = mappings[i];
              next = "";

              if (mapping.generatedLine !== previousGeneratedLine) {
                previousGeneratedColumn = 0;
                while (mapping.generatedLine !== previousGeneratedLine) {
                  next += ";";
                  previousGeneratedLine++;
                }
              } else {
                if (i > 0) {
                  if (
                    !util.compareByGeneratedPositionsInflated(
                      mapping,
                      mappings[i - 1]
                    )
                  ) {
                    continue;
                  }
                  next += ",";
                }
              }

              next += base64VLQ.encode(
                mapping.generatedColumn - previousGeneratedColumn
              );
              previousGeneratedColumn = mapping.generatedColumn;

              if (mapping.source != null) {
                sourceIdx = this._sources.indexOf(mapping.source);
                next += base64VLQ.encode(sourceIdx - previousSource);
                previousSource = sourceIdx;

                // lines are stored 0-based in SourceMap spec version 3
                next += base64VLQ.encode(
                  mapping.originalLine - 1 - previousOriginalLine
                );
                previousOriginalLine = mapping.originalLine - 1;

                next += base64VLQ.encode(
                  mapping.originalColumn - previousOriginalColumn
                );
                previousOriginalColumn = mapping.originalColumn;

                if (mapping.name != null) {
                  nameIdx = this._names.indexOf(mapping.name);
                  next += base64VLQ.encode(nameIdx - previousName);
                  previousName = nameIdx;
                }
              }

              result += next;
            }

            return result;
          };

        SourceMapGenerator.prototype._generateSourcesContent =
          function SourceMapGenerator_generateSourcesContent(
            aSources,
            aSourceRoot
          ) {
            return aSources.map(function (source) {
              if (!this._sourcesContents) {
                return null;
              }
              if (aSourceRoot != null) {
                source = util.relative(aSourceRoot, source);
              }
              var key = util.toSetString(source);
              return Object.prototype.hasOwnProperty.call(
                this._sourcesContents,
                key
              )
                ? this._sourcesContents[key]
                : null;
            }, this);
          };

        /**
         * Externalize the source map.
         */
        SourceMapGenerator.prototype.toJSON =
          function SourceMapGenerator_toJSON() {
            var map = {
              version: this._version,
              sources: this._sources.toArray(),
              names: this._names.toArray(),
              mappings: this._serializeMappings(),
            };
            if (this._file != null) {
              map.file = this._file;
            }
            if (this._sourceRoot != null) {
              map.sourceRoot = this._sourceRoot;
            }
            if (this._sourcesContents) {
              map.sourcesContent = this._generateSourcesContent(
                map.sources,
                map.sourceRoot
              );
            }

            return map;
          };

        /**
         * Render the source map being generated to a string.
         */
        SourceMapGenerator.prototype.toString =
          function SourceMapGenerator_toString() {
            return JSON.stringify(this.toJSON());
          };

        exports.SourceMapGenerator = SourceMapGenerator;
      },
      {
        "./array-set": 219,
        "./base64-vlq": 220,
        "./mapping-list": 223,
        "./util": 228,
      },
    ],
    227: [
      function (require, module, exports) {
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */

        var SourceMapGenerator =
          require("./source-map-generator").SourceMapGenerator;
        var util = require("./util");

        // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
        // operating systems these days (capturing the result).
        var REGEX_NEWLINE = /(\r?\n)/;

        // Newline character code for charCodeAt() comparisons
        var NEWLINE_CODE = 10;

        // Private symbol for identifying `SourceNode`s when multiple versions of
        // the source-map library are loaded. This MUST NOT CHANGE across
        // versions!
        var isSourceNode = "$$$isSourceNode$$$";

        /**
         * SourceNodes provide a way to abstract over interpolating/concatenating
         * snippets of generated JavaScript source code while maintaining the line and
         * column information associated with the original source code.
         *
         * @param aLine The original line number.
         * @param aColumn The original column number.
         * @param aSource The original source's filename.
         * @param aChunks Optional. An array of strings which are snippets of
         *        generated JS, or other SourceNodes.
         * @param aName The original identifier.
         */
        function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
          this.children = [];
          this.sourceContents = {};
          this.line = aLine == null ? null : aLine;
          this.column = aColumn == null ? null : aColumn;
          this.source = aSource == null ? null : aSource;
          this.name = aName == null ? null : aName;
          this[isSourceNode] = true;
          if (aChunks != null) this.add(aChunks);
        }

        /**
         * Creates a SourceNode from generated code and a SourceMapConsumer.
         *
         * @param aGeneratedCode The generated code
         * @param aSourceMapConsumer The SourceMap for the generated code
         * @param aRelativePath Optional. The path that relative sources in the
         *        SourceMapConsumer should be relative to.
         */
        SourceNode.fromStringWithSourceMap =
          function SourceNode_fromStringWithSourceMap(
            aGeneratedCode,
            aSourceMapConsumer,
            aRelativePath
          ) {
            // The SourceNode we want to fill with the generated code
            // and the SourceMap
            var node = new SourceNode();

            // All even indices of this array are one line of the generated code,
            // while all odd indices are the newlines between two adjacent lines
            // (since `REGEX_NEWLINE` captures its match).
            // Processed fragments are accessed by calling `shiftNextLine`.
            var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
            var remainingLinesIndex = 0;
            var shiftNextLine = function () {
              var lineContents = getNextLine();
              // The last line of a file might not have a newline.
              var newLine = getNextLine() || "";
              return lineContents + newLine;

              function getNextLine() {
                return remainingLinesIndex < remainingLines.length
                  ? remainingLines[remainingLinesIndex++]
                  : undefined;
              }
            };

            // We need to remember the position of "remainingLines"
            var lastGeneratedLine = 1,
              lastGeneratedColumn = 0;

            // The generate SourceNodes we need a code range.
            // To extract it current and last mapping is used.
            // Here we store the last mapping.
            var lastMapping = null;

            aSourceMapConsumer.eachMapping(function (mapping) {
              if (lastMapping !== null) {
                // We add the code from "lastMapping" to "mapping":
                // First check if there is a new line in between.
                if (lastGeneratedLine < mapping.generatedLine) {
                  // Associate first line with "lastMapping"
                  addMappingWithCode(lastMapping, shiftNextLine());
                  lastGeneratedLine++;
                  lastGeneratedColumn = 0;
                  // The remaining code is added without mapping
                } else {
                  // There is no new line in between.
                  // Associate the code between "lastGeneratedColumn" and
                  // "mapping.generatedColumn" with "lastMapping"
                  var nextLine = remainingLines[remainingLinesIndex];
                  var code = nextLine.substr(
                    0,
                    mapping.generatedColumn - lastGeneratedColumn
                  );
                  remainingLines[remainingLinesIndex] = nextLine.substr(
                    mapping.generatedColumn - lastGeneratedColumn
                  );
                  lastGeneratedColumn = mapping.generatedColumn;
                  addMappingWithCode(lastMapping, code);
                  // No more remaining code, continue
                  lastMapping = mapping;
                  return;
                }
              }
              // We add the generated code until the first mapping
              // to the SourceNode without any mapping.
              // Each line is added as separate string.
              while (lastGeneratedLine < mapping.generatedLine) {
                node.add(shiftNextLine());
                lastGeneratedLine++;
              }
              if (lastGeneratedColumn < mapping.generatedColumn) {
                var nextLine = remainingLines[remainingLinesIndex];
                node.add(nextLine.substr(0, mapping.generatedColumn));
                remainingLines[remainingLinesIndex] = nextLine.substr(
                  mapping.generatedColumn
                );
                lastGeneratedColumn = mapping.generatedColumn;
              }
              lastMapping = mapping;
            }, this);
            // We have processed all mappings.
            if (remainingLinesIndex < remainingLines.length) {
              if (lastMapping) {
                // Associate the remaining code in the current line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine());
              }
              // and add the remaining lines without any mapping
              node.add(remainingLines.splice(remainingLinesIndex).join(""));
            }

            // Copy sourcesContent into SourceNode
            aSourceMapConsumer.sources.forEach(function (sourceFile) {
              var content = aSourceMapConsumer.sourceContentFor(sourceFile);
              if (content != null) {
                if (aRelativePath != null) {
                  sourceFile = util.join(aRelativePath, sourceFile);
                }
                node.setSourceContent(sourceFile, content);
              }
            });

            return node;

            function addMappingWithCode(mapping, code) {
              if (mapping === null || mapping.source === undefined) {
                node.add(code);
              } else {
                var source = aRelativePath
                  ? util.join(aRelativePath, mapping.source)
                  : mapping.source;
                node.add(
                  new SourceNode(
                    mapping.originalLine,
                    mapping.originalColumn,
                    source,
                    code,
                    mapping.name
                  )
                );
              }
            }
          };

        /**
         * Add a chunk of generated JS to this source node.
         *
         * @param aChunk A string snippet of generated JS code, another instance of
         *        SourceNode, or an array where each member is one of those things.
         */
        SourceNode.prototype.add = function SourceNode_add(aChunk) {
          if (Array.isArray(aChunk)) {
            aChunk.forEach(function (chunk) {
              this.add(chunk);
            }, this);
          } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
            if (aChunk) {
              this.children.push(aChunk);
            }
          } else {
            throw new TypeError(
              "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
                aChunk
            );
          }
          return this;
        };

        /**
         * Add a chunk of generated JS to the beginning of this source node.
         *
         * @param aChunk A string snippet of generated JS code, another instance of
         *        SourceNode, or an array where each member is one of those things.
         */
        SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
          if (Array.isArray(aChunk)) {
            for (var i = aChunk.length - 1; i >= 0; i--) {
              this.prepend(aChunk[i]);
            }
          } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
            this.children.unshift(aChunk);
          } else {
            throw new TypeError(
              "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
                aChunk
            );
          }
          return this;
        };

        /**
         * Walk over the tree of JS snippets in this node and its children. The
         * walking function is called once for each snippet of JS and is passed that
         * snippet and the its original associated source's line/column location.
         *
         * @param aFn The traversal function.
         */
        SourceNode.prototype.walk = function SourceNode_walk(aFn) {
          var chunk;
          for (var i = 0, len = this.children.length; i < len; i++) {
            chunk = this.children[i];
            if (chunk[isSourceNode]) {
              chunk.walk(aFn);
            } else {
              if (chunk !== "") {
                aFn(chunk, {
                  source: this.source,
                  line: this.line,
                  column: this.column,
                  name: this.name,
                });
              }
            }
          }
        };

        /**
         * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
         * each of `this.children`.
         *
         * @param aSep The separator.
         */
        SourceNode.prototype.join = function SourceNode_join(aSep) {
          var newChildren;
          var i;
          var len = this.children.length;
          if (len > 0) {
            newChildren = [];
            for (i = 0; i < len - 1; i++) {
              newChildren.push(this.children[i]);
              newChildren.push(aSep);
            }
            newChildren.push(this.children[i]);
            this.children = newChildren;
          }
          return this;
        };

        /**
         * Call String.prototype.replace on the very right-most source snippet. Useful
         * for trimming whitespace from the end of a source node, etc.
         *
         * @param aPattern The pattern to replace.
         * @param aReplacement The thing to replace the pattern with.
         */
        SourceNode.prototype.replaceRight = function SourceNode_replaceRight(
          aPattern,
          aReplacement
        ) {
          var lastChild = this.children[this.children.length - 1];
          if (lastChild[isSourceNode]) {
            lastChild.replaceRight(aPattern, aReplacement);
          } else if (typeof lastChild === "string") {
            this.children[this.children.length - 1] = lastChild.replace(
              aPattern,
              aReplacement
            );
          } else {
            this.children.push("".replace(aPattern, aReplacement));
          }
          return this;
        };

        /**
         * Set the source content for a source file. This will be added to the SourceMapGenerator
         * in the sourcesContent field.
         *
         * @param aSourceFile The filename of the source file
         * @param aSourceContent The content of the source file
         */
        SourceNode.prototype.setSourceContent =
          function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
            this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
          };

        /**
         * Walk over the tree of SourceNodes. The walking function is called for each
         * source file content and is passed the filename and source content.
         *
         * @param aFn The traversal function.
         */
        SourceNode.prototype.walkSourceContents =
          function SourceNode_walkSourceContents(aFn) {
            for (var i = 0, len = this.children.length; i < len; i++) {
              if (this.children[i][isSourceNode]) {
                this.children[i].walkSourceContents(aFn);
              }
            }

            var sources = Object.keys(this.sourceContents);
            for (var i = 0, len = sources.length; i < len; i++) {
              aFn(
                util.fromSetString(sources[i]),
                this.sourceContents[sources[i]]
              );
            }
          };

        /**
         * Return the string representation of this source node. Walks over the tree
         * and concatenates all the various snippets together to one string.
         */
        SourceNode.prototype.toString = function SourceNode_toString() {
          var str = "";
          this.walk(function (chunk) {
            str += chunk;
          });
          return str;
        };

        /**
         * Returns the string representation of this source node along with a source
         * map.
         */
        SourceNode.prototype.toStringWithSourceMap =
          function SourceNode_toStringWithSourceMap(aArgs) {
            var generated = {
              code: "",
              line: 1,
              column: 0,
            };
            var map = new SourceMapGenerator(aArgs);
            var sourceMappingActive = false;
            var lastOriginalSource = null;
            var lastOriginalLine = null;
            var lastOriginalColumn = null;
            var lastOriginalName = null;
            this.walk(function (chunk, original) {
              generated.code += chunk;
              if (
                original.source !== null &&
                original.line !== null &&
                original.column !== null
              ) {
                if (
                  lastOriginalSource !== original.source ||
                  lastOriginalLine !== original.line ||
                  lastOriginalColumn !== original.column ||
                  lastOriginalName !== original.name
                ) {
                  map.addMapping({
                    source: original.source,
                    original: {
                      line: original.line,
                      column: original.column,
                    },
                    generated: {
                      line: generated.line,
                      column: generated.column,
                    },
                    name: original.name,
                  });
                }
                lastOriginalSource = original.source;
                lastOriginalLine = original.line;
                lastOriginalColumn = original.column;
                lastOriginalName = original.name;
                sourceMappingActive = true;
              } else if (sourceMappingActive) {
                map.addMapping({
                  generated: {
                    line: generated.line,
                    column: generated.column,
                  },
                });
                lastOriginalSource = null;
                sourceMappingActive = false;
              }
              for (var idx = 0, length = chunk.length; idx < length; idx++) {
                if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                  generated.line++;
                  generated.column = 0;
                  // Mappings end at eol
                  if (idx + 1 === length) {
                    lastOriginalSource = null;
                    sourceMappingActive = false;
                  } else if (sourceMappingActive) {
                    map.addMapping({
                      source: original.source,
                      original: {
                        line: original.line,
                        column: original.column,
                      },
                      generated: {
                        line: generated.line,
                        column: generated.column,
                      },
                      name: original.name,
                    });
                  }
                } else {
                  generated.column++;
                }
              }
            });
            this.walkSourceContents(function (sourceFile, sourceContent) {
              map.setSourceContent(sourceFile, sourceContent);
            });

            return { code: generated.code, map: map };
          };

        exports.SourceNode = SourceNode;
      },
      { "./source-map-generator": 226, "./util": 228 },
    ],
    228: [
      function (require, module, exports) {
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */

        /**
         * This is a helper function for getting values from parameter/options
         * objects.
         *
         * @param args The object we are extracting values from
         * @param name The name of the property we are getting.
         * @param defaultValue An optional value to return if the property is missing
         * from the object. If this is not specified and the property is missing, an
         * error will be thrown.
         */
        function getArg(aArgs, aName, aDefaultValue) {
          if (aName in aArgs) {
            return aArgs[aName];
          } else if (arguments.length === 3) {
            return aDefaultValue;
          } else {
            throw new Error('"' + aName + '" is a required argument.');
          }
        }
        exports.getArg = getArg;

        var urlRegexp =
          /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
        var dataUrlRegexp = /^data:.+\,.+$/;

        function urlParse(aUrl) {
          var match = aUrl.match(urlRegexp);
          if (!match) {
            return null;
          }
          return {
            scheme: match[1],
            auth: match[2],
            host: match[3],
            port: match[4],
            path: match[5],
          };
        }
        exports.urlParse = urlParse;

        function urlGenerate(aParsedUrl) {
          var url = "";
          if (aParsedUrl.scheme) {
            url += aParsedUrl.scheme + ":";
          }
          url += "//";
          if (aParsedUrl.auth) {
            url += aParsedUrl.auth + "@";
          }
          if (aParsedUrl.host) {
            url += aParsedUrl.host;
          }
          if (aParsedUrl.port) {
            url += ":" + aParsedUrl.port;
          }
          if (aParsedUrl.path) {
            url += aParsedUrl.path;
          }
          return url;
        }
        exports.urlGenerate = urlGenerate;

        /**
         * Normalizes a path, or the path portion of a URL:
         *
         * - Replaces consecutive slashes with one slash.
         * - Removes unnecessary '.' parts.
         * - Removes unnecessary '<dir>/..' parts.
         *
         * Based on code in the Node.js 'path' core module.
         *
         * @param aPath The path or url to normalize.
         */
        function normalize(aPath) {
          var path = aPath;
          var url = urlParse(aPath);
          if (url) {
            if (!url.path) {
              return aPath;
            }
            path = url.path;
          }
          var isAbsolute = exports.isAbsolute(path);

          var parts = path.split(/\/+/);
          for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
            part = parts[i];
            if (part === ".") {
              parts.splice(i, 1);
            } else if (part === "..") {
              up++;
            } else if (up > 0) {
              if (part === "") {
                // The first part is blank if the path is absolute. Trying to go
                // above the root is a no-op. Therefore we can remove all '..' parts
                // directly after the root.
                parts.splice(i + 1, up);
                up = 0;
              } else {
                parts.splice(i, 2);
                up--;
              }
            }
          }
          path = parts.join("/");

          if (path === "") {
            path = isAbsolute ? "/" : ".";
          }

          if (url) {
            url.path = path;
            return urlGenerate(url);
          }
          return path;
        }
        exports.normalize = normalize;

        /**
         * Joins two paths/URLs.
         *
         * @param aRoot The root path or URL.
         * @param aPath The path or URL to be joined with the root.
         *
         * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
         *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
         *   first.
         * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
         *   is updated with the result and aRoot is returned. Otherwise the result
         *   is returned.
         *   - If aPath is absolute, the result is aPath.
         *   - Otherwise the two paths are joined with a slash.
         * - Joining for example 'http://' and 'www.example.com' is also supported.
         */
        function join(aRoot, aPath) {
          if (aRoot === "") {
            aRoot = ".";
          }
          if (aPath === "") {
            aPath = ".";
          }
          var aPathUrl = urlParse(aPath);
          var aRootUrl = urlParse(aRoot);
          if (aRootUrl) {
            aRoot = aRootUrl.path || "/";
          }

          // `join(foo, '//www.example.org')`
          if (aPathUrl && !aPathUrl.scheme) {
            if (aRootUrl) {
              aPathUrl.scheme = aRootUrl.scheme;
            }
            return urlGenerate(aPathUrl);
          }

          if (aPathUrl || aPath.match(dataUrlRegexp)) {
            return aPath;
          }

          // `join('http://', 'www.example.com')`
          if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
            aRootUrl.host = aPath;
            return urlGenerate(aRootUrl);
          }

          var joined =
            aPath.charAt(0) === "/"
              ? aPath
              : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);

          if (aRootUrl) {
            aRootUrl.path = joined;
            return urlGenerate(aRootUrl);
          }
          return joined;
        }
        exports.join = join;

        exports.isAbsolute = function (aPath) {
          return aPath.charAt(0) === "/" || !!aPath.match(urlRegexp);
        };

        /**
         * Make a path relative to a URL or another path.
         *
         * @param aRoot The root path or URL.
         * @param aPath The path or URL to be made relative to aRoot.
         */
        function relative(aRoot, aPath) {
          if (aRoot === "") {
            aRoot = ".";
          }

          aRoot = aRoot.replace(/\/$/, "");

          // It is possible for the path to be above the root. In this case, simply
          // checking whether the root is a prefix of the path won't work. Instead, we
          // need to remove components from the root one by one, until either we find
          // a prefix that fits, or we run out of components to remove.
          var level = 0;
          while (aPath.indexOf(aRoot + "/") !== 0) {
            var index = aRoot.lastIndexOf("/");
            if (index < 0) {
              return aPath;
            }

            // If the only part of the root that is left is the scheme (i.e. http://,
            // file:///, etc.), one or more slashes (/), or simply nothing at all, we
            // have exhausted all components, so the path is not relative to the root.
            aRoot = aRoot.slice(0, index);
            if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
              return aPath;
            }

            ++level;
          }

          // Make sure we add a "../" for each component we removed from the root.
          return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
        }
        exports.relative = relative;

        var supportsNullProto = (function () {
          var obj = Object.create(null);
          return !("__proto__" in obj);
        })();

        function identity(s) {
          return s;
        }

        /**
         * Because behavior goes wacky when you set `__proto__` on objects, we
         * have to prefix all the strings in our set with an arbitrary character.
         *
         * See https://github.com/mozilla/source-map/pull/31 and
         * https://github.com/mozilla/source-map/issues/30
         *
         * @param String aStr
         */
        function toSetString(aStr) {
          if (isProtoString(aStr)) {
            return "$" + aStr;
          }

          return aStr;
        }
        exports.toSetString = supportsNullProto ? identity : toSetString;

        function fromSetString(aStr) {
          if (isProtoString(aStr)) {
            return aStr.slice(1);
          }

          return aStr;
        }
        exports.fromSetString = supportsNullProto ? identity : fromSetString;

        function isProtoString(s) {
          if (!s) {
            return false;
          }

          var length = s.length;

          if (length < 9 /* "__proto__".length */) {
            return false;
          }

          if (
            s.charCodeAt(length - 1) !== 95 /* '_' */ ||
            s.charCodeAt(length - 2) !== 95 /* '_' */ ||
            s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
            s.charCodeAt(length - 4) !== 116 /* 't' */ ||
            s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
            s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
            s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
            s.charCodeAt(length - 8) !== 95 /* '_' */ ||
            s.charCodeAt(length - 9) !== 95 /* '_' */
          ) {
            return false;
          }

          for (var i = length - 10; i >= 0; i--) {
            if (s.charCodeAt(i) !== 36 /* '$' */) {
              return false;
            }
          }

          return true;
        }

        /**
         * Comparator between two mappings where the original positions are compared.
         *
         * Optionally pass in `true` as `onlyCompareGenerated` to consider two
         * mappings with the same original source/line/column, but different generated
         * line and column the same. Useful when searching for a mapping with a
         * stubbed out mapping.
         */
        function compareByOriginalPositions(
          mappingA,
          mappingB,
          onlyCompareOriginal
        ) {
          var cmp = mappingA.source - mappingB.source;
          if (cmp !== 0) {
            return cmp;
          }

          cmp = mappingA.originalLine - mappingB.originalLine;
          if (cmp !== 0) {
            return cmp;
          }

          cmp = mappingA.originalColumn - mappingB.originalColumn;
          if (cmp !== 0 || onlyCompareOriginal) {
            return cmp;
          }

          cmp = mappingA.generatedColumn - mappingB.generatedColumn;
          if (cmp !== 0) {
            return cmp;
          }

          cmp = mappingA.generatedLine - mappingB.generatedLine;
          if (cmp !== 0) {
            return cmp;
          }

          return mappingA.name - mappingB.name;
        }
        exports.compareByOriginalPositions = compareByOriginalPositions;

        /**
         * Comparator between two mappings with deflated source and name indices where
         * the generated positions are compared.
         *
         * Optionally pass in `true` as `onlyCompareGenerated` to consider two
         * mappings with the same generated line and column, but different
         * source/name/original line and column the same. Useful when searching for a
         * mapping with a stubbed out mapping.
         */
        function compareByGeneratedPositionsDeflated(
          mappingA,
          mappingB,
          onlyCompareGenerated
        ) {
          var cmp = mappingA.generatedLine - mappingB.generatedLine;
          if (cmp !== 0) {
            return cmp;
          }

          cmp = mappingA.generatedColumn - mappingB.generatedColumn;
          if (cmp !== 0 || onlyCompareGenerated) {
            return cmp;
          }

          cmp = mappingA.source - mappingB.source;
          if (cmp !== 0) {
            return cmp;
          }

          cmp = mappingA.originalLine - mappingB.originalLine;
          if (cmp !== 0) {
            return cmp;
          }

          cmp = mappingA.originalColumn - mappingB.originalColumn;
          if (cmp !== 0) {
            return cmp;
          }

          return mappingA.name - mappingB.name;
        }
        exports.compareByGeneratedPositionsDeflated =
          compareByGeneratedPositionsDeflated;

        function strcmp(aStr1, aStr2) {
          if (aStr1 === aStr2) {
            return 0;
          }

          if (aStr1 > aStr2) {
            return 1;
          }

          return -1;
        }

        /**
         * Comparator between two mappings with inflated source and name strings where
         * the generated positions are compared.
         */
        function compareByGeneratedPositionsInflated(mappingA, mappingB) {
          var cmp = mappingA.generatedLine - mappingB.generatedLine;
          if (cmp !== 0) {
            return cmp;
          }

          cmp = mappingA.generatedColumn - mappingB.generatedColumn;
          if (cmp !== 0) {
            return cmp;
          }

          cmp = strcmp(mappingA.source, mappingB.source);
          if (cmp !== 0) {
            return cmp;
          }

          cmp = mappingA.originalLine - mappingB.originalLine;
          if (cmp !== 0) {
            return cmp;
          }

          cmp = mappingA.originalColumn - mappingB.originalColumn;
          if (cmp !== 0) {
            return cmp;
          }

          return strcmp(mappingA.name, mappingB.name);
        }
        exports.compareByGeneratedPositionsInflated =
          compareByGeneratedPositionsInflated;
      },
      {},
    ],
    229: [
      function (require, module, exports) {
        /*
         * Copyright 2009-2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE.txt or:
         * http://opensource.org/licenses/BSD-3-Clause
         */
        exports.SourceMapGenerator =
          require("./lib/source-map-generator").SourceMapGenerator;
        exports.SourceMapConsumer =
          require("./lib/source-map-consumer").SourceMapConsumer;
        exports.SourceNode = require("./lib/source-node").SourceNode;
      },
      {
        "./lib/source-map-consumer": 225,
        "./lib/source-map-generator": 226,
        "./lib/source-node": 227,
      },
    ],
    230: [
      function (require, module, exports) {
        (function (setImmediate) {
          (function () {
            // Note: source-map-resolve.js is generated from source-map-resolve-node.js and
            // source-map-resolve-template.js. Only edit the two latter files, _not_
            // source-map-resolve.js!

            void (function (root, factory) {
              if (typeof define === "function" && define.amd) {
                define(["source-map-url", "resolve-url"], factory);
              } else if (typeof exports === "object") {
                var sourceMappingURL = require("source-map-url");
                var resolveUrl = require("resolve-url");
                module.exports = factory(sourceMappingURL, resolveUrl);
              } else {
                root.sourceMapResolve = factory(
                  root.sourceMappingURL,
                  root.resolveUrl
                );
              }
            })(this, function (sourceMappingURL, resolveUrl) {
              function callbackAsync(callback, error, result) {
                setImmediate(function () {
                  callback(error, result);
                });
              }

              function parseMapToJSON(string, data) {
                try {
                  return JSON.parse(string.replace(/^\)\]\}'/, ""));
                } catch (error) {
                  error.sourceMapData = data;
                  throw error;
                }
              }

              function readSync(read, url, data) {
                var readUrl = url;
                try {
                  return String(read(readUrl));
                } catch (error) {
                  error.sourceMapData = data;
                  throw error;
                }
              }

              function resolveSourceMap(code, codeUrl, read, callback) {
                var mapData;
                try {
                  mapData = resolveSourceMapHelper(code, codeUrl);
                } catch (error) {
                  return callbackAsync(callback, error);
                }
                if (!mapData || mapData.map) {
                  return callbackAsync(callback, null, mapData);
                }
                var readUrl = mapData.url;
                read(readUrl, function (error, result) {
                  if (error) {
                    error.sourceMapData = mapData;
                    return callback(error);
                  }
                  mapData.map = String(result);
                  try {
                    mapData.map = parseMapToJSON(mapData.map, mapData);
                  } catch (error) {
                    return callback(error);
                  }
                  callback(null, mapData);
                });
              }

              function resolveSourceMapSync(code, codeUrl, read) {
                var mapData = resolveSourceMapHelper(code, codeUrl);
                if (!mapData || mapData.map) {
                  return mapData;
                }
                mapData.map = readSync(read, mapData.url, mapData);
                mapData.map = parseMapToJSON(mapData.map, mapData);
                return mapData;
              }

              var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;

              /**
               * The media type for JSON text is application/json.
               *
               * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }
               *
               * `text/json` is non-standard media type
               */
              var jsonMimeTypeRegex = /^(?:application|text)\/json$/;

              /**
               * JSON text exchanged between systems that are not part of a closed ecosystem
               * MUST be encoded using UTF-8.
               *
               * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}
               */
              var jsonCharacterEncoding = "utf-8";

              function base64ToBuf(b64) {
                var binStr = atob(b64);
                var len = binStr.length;
                var arr = new Uint8Array(len);
                for (var i = 0; i < len; i++) {
                  arr[i] = binStr.charCodeAt(i);
                }
                return arr;
              }

              function decodeBase64String(b64) {
                if (
                  typeof TextDecoder === "undefined" ||
                  typeof Uint8Array === "undefined"
                ) {
                  return atob(b64);
                }
                var buf = base64ToBuf(b64);
                // Note: `decoder.decode` method will throw a `DOMException` with the
                // `"EncodingError"` value when an coding error is found.
                var decoder = new TextDecoder(jsonCharacterEncoding, {
                  fatal: true,
                });
                return decoder.decode(buf);
              }

              function resolveSourceMapHelper(code, codeUrl) {
                var url = sourceMappingURL.getFrom(code);
                if (!url) {
                  return null;
                }

                var dataUri = url.match(dataUriRegex);
                if (dataUri) {
                  var mimeType = dataUri[1] || "text/plain";
                  var lastParameter = dataUri[2] || "";
                  var encoded = dataUri[3] || "";
                  var data = {
                    sourceMappingURL: url,
                    url: null,
                    sourcesRelativeTo: codeUrl,
                    map: encoded,
                  };
                  if (!jsonMimeTypeRegex.test(mimeType)) {
                    var error = new Error(
                      "Unuseful data uri mime type: " + mimeType
                    );
                    error.sourceMapData = data;
                    throw error;
                  }
                  try {
                    data.map = parseMapToJSON(
                      lastParameter === ";base64"
                        ? decodeBase64String(encoded)
                        : decodeURIComponent(encoded),
                      data
                    );
                  } catch (error) {
                    error.sourceMapData = data;
                    throw error;
                  }
                  return data;
                }

                var mapUrl = resolveUrl(codeUrl, url);
                return {
                  sourceMappingURL: url,
                  url: mapUrl,
                  sourcesRelativeTo: mapUrl,
                  map: null,
                };
              }

              function resolveSources(map, mapUrl, read, options, callback) {
                if (typeof options === "function") {
                  callback = options;
                  options = {};
                }
                var pending = map.sources ? map.sources.length : 0;
                var result = {
                  sourcesResolved: [],
                  sourcesContent: [],
                };

                if (pending === 0) {
                  callbackAsync(callback, null, result);
                  return;
                }

                var done = function () {
                  pending--;
                  if (pending === 0) {
                    callback(null, result);
                  }
                };

                resolveSourcesHelper(
                  map,
                  mapUrl,
                  options,
                  function (fullUrl, sourceContent, index) {
                    result.sourcesResolved[index] = fullUrl;
                    if (typeof sourceContent === "string") {
                      result.sourcesContent[index] = sourceContent;
                      callbackAsync(done, null);
                    } else {
                      var readUrl = fullUrl;
                      read(readUrl, function (error, source) {
                        result.sourcesContent[index] = error
                          ? error
                          : String(source);
                        done();
                      });
                    }
                  }
                );
              }

              function resolveSourcesSync(map, mapUrl, read, options) {
                var result = {
                  sourcesResolved: [],
                  sourcesContent: [],
                };

                if (!map.sources || map.sources.length === 0) {
                  return result;
                }

                resolveSourcesHelper(
                  map,
                  mapUrl,
                  options,
                  function (fullUrl, sourceContent, index) {
                    result.sourcesResolved[index] = fullUrl;
                    if (read !== null) {
                      if (typeof sourceContent === "string") {
                        result.sourcesContent[index] = sourceContent;
                      } else {
                        var readUrl = fullUrl;
                        try {
                          result.sourcesContent[index] = String(read(readUrl));
                        } catch (error) {
                          result.sourcesContent[index] = error;
                        }
                      }
                    }
                  }
                );

                return result;
              }

              var endingSlash = /\/?$/;

              function resolveSourcesHelper(map, mapUrl, options, fn) {
                options = options || {};
                var fullUrl;
                var sourceContent;
                var sourceRoot;
                for (
                  var index = 0, len = map.sources.length;
                  index < len;
                  index++
                ) {
                  sourceRoot = null;
                  if (typeof options.sourceRoot === "string") {
                    sourceRoot = options.sourceRoot;
                  } else if (
                    typeof map.sourceRoot === "string" &&
                    options.sourceRoot !== false
                  ) {
                    sourceRoot = map.sourceRoot;
                  }
                  // If the sourceRoot is the empty string, it is equivalent to not setting
                  // the property at all.
                  if (sourceRoot === null || sourceRoot === "") {
                    fullUrl = resolveUrl(mapUrl, map.sources[index]);
                  } else {
                    // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes
                    // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root
                    // does not make sense.
                    fullUrl = resolveUrl(
                      mapUrl,
                      sourceRoot.replace(endingSlash, "/"),
                      map.sources[index]
                    );
                  }
                  sourceContent = (map.sourcesContent || [])[index];
                  fn(fullUrl, sourceContent, index);
                }
              }

              function resolve(code, codeUrl, read, options, callback) {
                if (typeof options === "function") {
                  callback = options;
                  options = {};
                }
                if (code === null) {
                  var mapUrl = codeUrl;
                  var data = {
                    sourceMappingURL: null,
                    url: mapUrl,
                    sourcesRelativeTo: mapUrl,
                    map: null,
                  };
                  var readUrl = mapUrl;
                  read(readUrl, function (error, result) {
                    if (error) {
                      error.sourceMapData = data;
                      return callback(error);
                    }
                    data.map = String(result);
                    try {
                      data.map = parseMapToJSON(data.map, data);
                    } catch (error) {
                      return callback(error);
                    }
                    _resolveSources(data);
                  });
                } else {
                  resolveSourceMap(
                    code,
                    codeUrl,
                    read,
                    function (error, mapData) {
                      if (error) {
                        return callback(error);
                      }
                      if (!mapData) {
                        return callback(null, null);
                      }
                      _resolveSources(mapData);
                    }
                  );
                }

                function _resolveSources(mapData) {
                  resolveSources(
                    mapData.map,
                    mapData.sourcesRelativeTo,
                    read,
                    options,
                    function (error, result) {
                      if (error) {
                        return callback(error);
                      }
                      mapData.sourcesResolved = result.sourcesResolved;
                      mapData.sourcesContent = result.sourcesContent;
                      callback(null, mapData);
                    }
                  );
                }
              }

              function resolveSync(code, codeUrl, read, options) {
                var mapData;
                if (code === null) {
                  var mapUrl = codeUrl;
                  mapData = {
                    sourceMappingURL: null,
                    url: mapUrl,
                    sourcesRelativeTo: mapUrl,
                    map: null,
                  };
                  mapData.map = readSync(read, mapUrl, mapData);
                  mapData.map = parseMapToJSON(mapData.map, mapData);
                } else {
                  mapData = resolveSourceMapSync(code, codeUrl, read);
                  if (!mapData) {
                    return null;
                  }
                }
                var result = resolveSourcesSync(
                  mapData.map,
                  mapData.sourcesRelativeTo,
                  read,
                  options
                );
                mapData.sourcesResolved = result.sourcesResolved;
                mapData.sourcesContent = result.sourcesContent;
                return mapData;
              }

              return {
                resolveSourceMap: resolveSourceMap,
                resolveSourceMapSync: resolveSourceMapSync,
                resolveSources: resolveSources,
                resolveSourcesSync: resolveSourcesSync,
                resolve: resolve,
                resolveSync: resolveSync,
                parseMapToJSON: parseMapToJSON,
              };
            });
          }.call(this));
        }.call(this, require("timers").setImmediate));
      },
      { "resolve-url": 191, "source-map-url": 231, timers: 244 },
    ],
    231: [
      function (require, module, exports) {
        // Copyright 2014 Simon Lydell
        // X11 (MIT) Licensed. (See LICENSE.)

        void (function (root, factory) {
          if (typeof define === "function" && define.amd) {
            define(factory);
          } else if (typeof exports === "object") {
            module.exports = factory();
          } else {
            root.sourceMappingURL = factory();
          }
        })(this, function () {
          var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/;

          var regex = RegExp(
            "(?:" +
              "/\\*" +
              "(?:\\s*\r?\n(?://)?)?" +
              "(?:" +
              innerRegex.source +
              ")" +
              "\\s*" +
              "\\*/" +
              "|" +
              "//(?:" +
              innerRegex.source +
              ")" +
              ")" +
              "\\s*"
          );

          return {
            regex: regex,
            _innerRegex: innerRegex,

            getFrom: function (code) {
              var match = code.match(regex);
              return match ? match[1] || match[2] || "" : null;
            },

            existsIn: function (code) {
              return regex.test(code);
            },

            removeFrom: function (code) {
              return code.replace(regex, "");
            },

            insertBefore: function (code, string) {
              var match = code.match(regex);
              if (match) {
                return (
                  code.slice(0, match.index) + string + code.slice(match.index)
                );
              } else {
                return code + string;
              }
            },
          };
        });
      },
      {},
    ],
    232: [
      function (require, module, exports) {
        /*!
         * split-string <https://github.com/jonschlinkert/split-string>
         *
         * Copyright (c) 2015-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var extend = require("extend-shallow");

        module.exports = function (str, options, fn) {
          if (typeof str !== "string") {
            throw new TypeError("expected a string");
          }

          if (typeof options === "function") {
            fn = options;
            options = null;
          }

          // allow separator to be defined as a string
          if (typeof options === "string") {
            options = { sep: options };
          }

          var opts = extend({ sep: "." }, options);
          var quotes = opts.quotes || ['"', "'", "`"];
          var brackets;

          if (opts.brackets === true) {
            brackets = {
              "<": ">",
              "(": ")",
              "[": "]",
              "{": "}",
            };
          } else if (opts.brackets) {
            brackets = opts.brackets;
          }

          var tokens = [];
          var stack = [];
          var arr = [""];
          var sep = opts.sep;
          var len = str.length;
          var idx = -1;
          var closeIdx;

          function expected() {
            if (brackets && stack.length) {
              return brackets[stack[stack.length - 1]];
            }
          }

          while (++idx < len) {
            var ch = str[idx];
            var next = str[idx + 1];
            var tok = { val: ch, idx: idx, arr: arr, str: str };
            tokens.push(tok);

            if (ch === "\\") {
              tok.val =
                keepEscaping(opts, str, idx) === true ? ch + next : next;
              tok.escaped = true;
              if (typeof fn === "function") {
                fn(tok);
              }
              arr[arr.length - 1] += tok.val;
              idx++;
              continue;
            }

            if (brackets && brackets[ch]) {
              stack.push(ch);
              var e = expected();
              var i = idx + 1;

              if (str.indexOf(e, i + 1) !== -1) {
                while (stack.length && i < len) {
                  var s = str[++i];
                  if (s === "\\") {
                    s++;
                    continue;
                  }

                  if (quotes.indexOf(s) !== -1) {
                    i = getClosingQuote(str, s, i + 1);
                    continue;
                  }

                  e = expected();
                  if (stack.length && str.indexOf(e, i + 1) === -1) {
                    break;
                  }

                  if (brackets[s]) {
                    stack.push(s);
                    continue;
                  }

                  if (e === s) {
                    stack.pop();
                  }
                }
              }

              closeIdx = i;
              if (closeIdx === -1) {
                arr[arr.length - 1] += ch;
                continue;
              }

              ch = str.slice(idx, closeIdx + 1);
              tok.val = ch;
              tok.idx = idx = closeIdx;
            }

            if (quotes.indexOf(ch) !== -1) {
              closeIdx = getClosingQuote(str, ch, idx + 1);
              if (closeIdx === -1) {
                arr[arr.length - 1] += ch;
                continue;
              }

              if (keepQuotes(ch, opts) === true) {
                ch = str.slice(idx, closeIdx + 1);
              } else {
                ch = str.slice(idx + 1, closeIdx);
              }

              tok.val = ch;
              tok.idx = idx = closeIdx;
            }

            if (typeof fn === "function") {
              fn(tok, tokens);
              ch = tok.val;
              idx = tok.idx;
            }

            if (tok.val === sep && tok.split !== false) {
              arr.push("");
              continue;
            }

            arr[arr.length - 1] += tok.val;
          }

          return arr;
        };

        function getClosingQuote(str, ch, i, brackets) {
          var idx = str.indexOf(ch, i);
          if (str.charAt(idx - 1) === "\\") {
            return getClosingQuote(str, ch, idx + 1);
          }
          return idx;
        }

        function keepQuotes(ch, opts) {
          if (opts.keepDoubleQuotes === true && ch === '"') return true;
          if (opts.keepSingleQuotes === true && ch === "'") return true;
          return opts.keepQuotes;
        }

        function keepEscaping(opts, str, idx) {
          if (typeof opts.keepEscaping === "function") {
            return opts.keepEscaping(str, idx);
          }
          return opts.keepEscaping === true || str[idx + 1] === "\\";
        }
      },
      { "extend-shallow": 233 },
    ],
    233: [
      function (require, module, exports) {
        arguments[4][148][0].apply(exports, arguments);
      },
      { "assign-symbols": 7, dup: 148, "is-extendable": 234 },
    ],
    234: [
      function (require, module, exports) {
        arguments[4][149][0].apply(exports, arguments);
      },
      { dup: 149, "is-plain-object": 126 },
    ],
    235: [
      function (require, module, exports) {
        /*!
         * static-extend <https://github.com/jonschlinkert/static-extend>
         *
         * Copyright (c) 2016, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        var copy = require("object-copy");
        var define = require("define-property");
        var util = require("util");

        /**
         * Returns a function for extending the static properties,
         * prototype properties, and descriptors from the `Parent`
         * constructor onto `Child` constructors.
         *
         * ```js
         * var extend = require('static-extend');
         * Parent.extend = extend(Parent);
         *
         * // optionally pass a custom merge function as the second arg
         * Parent.extend = extend(Parent, function(Child) {
         *   Child.prototype.mixin = function(key, val) {
         *     Child.prototype[key] = val;
         *   };
         * });
         *
         * // extend "child" constructors
         * Parent.extend(Child);
         *
         * // optionally define prototype methods as the second arg
         * Parent.extend(Child, {
         *   foo: function() {},
         *   bar: function() {}
         * });
         * ```
         * @param {Function} `Parent` Parent ctor
         * @param {Function} `extendFn` Optional extend function for handling any necessary custom merging. Useful when updating methods that require a specific prototype.
         *   @param {Function} `Child` Child ctor
         *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.
         *   @return {Object}
         * @api public
         */

        function extend(Parent, extendFn) {
          if (typeof Parent !== "function") {
            throw new TypeError("expected Parent to be a function.");
          }

          return function (Ctor, proto) {
            if (typeof Ctor !== "function") {
              throw new TypeError("expected Ctor to be a function.");
            }

            util.inherits(Ctor, Parent);
            copy(Ctor, Parent);

            // proto can be null or a plain object
            if (typeof proto === "object") {
              var obj = Object.create(proto);

              for (var k in obj) {
                Ctor.prototype[k] = obj[k];
              }
            }

            // keep a reference to the parent prototype
            define(Ctor.prototype, "_parent_", {
              configurable: true,
              set: function () {},
              get: function () {
                return Parent.prototype;
              },
            });

            if (typeof extendFn === "function") {
              extendFn(Ctor, Parent);
            }

            Ctor.extend = extend(Ctor, extendFn);
          };
        }

        /**
         * Expose `extend`
         */

        module.exports = extend;
      },
      { "define-property": 236, "object-copy": 167, util: 264 },
    ],
    236: [
      function (require, module, exports) {
        arguments[4][15][0].apply(exports, arguments);
      },
      { dup: 15, "is-descriptor": 241 },
    ],
    237: [
      function (require, module, exports) {
        arguments[4][16][0].apply(exports, arguments);
      },
      { dup: 16, "kind-of": 238 },
    ],
    238: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    239: [
      function (require, module, exports) {
        arguments[4][18][0].apply(exports, arguments);
      },
      { dup: 18, "kind-of": 240 },
    ],
    240: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    241: [
      function (require, module, exports) {
        arguments[4][20][0].apply(exports, arguments);
      },
      {
        dup: 20,
        "is-accessor-descriptor": 237,
        "is-data-descriptor": 239,
        "kind-of": 242,
      },
    ],
    242: [
      function (require, module, exports) {
        arguments[4][5][0].apply(exports, arguments);
      },
      { dup: 5 },
    ],
    243: [
      function (require, module, exports) {
        "use strict";

        (function (global) {
          // minimal symbol polyfill for IE11 and others
          if (typeof Symbol !== "function") {
            var Symbol = function (name) {
              return name;
            };

            Symbol.nonNative = true;
          }

          const STATE_PLAINTEXT = Symbol("plaintext");
          const STATE_HTML = Symbol("html");
          const STATE_COMMENT = Symbol("comment");

          const ALLOWED_TAGS_REGEX = /<(\w*)>/g;
          const NORMALIZE_TAG_REGEX = /<\/?([^\s\/>]+)/;

          function striptags(html, allowable_tags, tag_replacement) {
            html = html || "";
            allowable_tags = allowable_tags || [];
            tag_replacement = tag_replacement || "";

            let context = init_context(allowable_tags, tag_replacement);

            return striptags_internal(html, context);
          }

          function init_striptags_stream(allowable_tags, tag_replacement) {
            allowable_tags = allowable_tags || [];
            tag_replacement = tag_replacement || "";

            let context = init_context(allowable_tags, tag_replacement);

            return function striptags_stream(html) {
              return striptags_internal(html || "", context);
            };
          }

          striptags.init_streaming_mode = init_striptags_stream;

          function init_context(allowable_tags, tag_replacement) {
            allowable_tags = parse_allowable_tags(allowable_tags);

            return {
              allowable_tags: allowable_tags,
              tag_replacement: tag_replacement,

              state: STATE_PLAINTEXT,
              tag_buffer: "",
              depth: 0,
              in_quote_char: "",
            };
          }

          function striptags_internal(html, context) {
            if (typeof html != "string") {
              throw new TypeError("'html' parameter must be a string");
            }

            let allowable_tags = context.allowable_tags;
            let tag_replacement = context.tag_replacement;

            let state = context.state;
            let tag_buffer = context.tag_buffer;
            let depth = context.depth;
            let in_quote_char = context.in_quote_char;
            let output = "";

            for (let idx = 0, length = html.length; idx < length; idx++) {
              let char = html[idx];

              if (state === STATE_PLAINTEXT) {
                switch (char) {
                  case "<":
                    state = STATE_HTML;
                    tag_buffer += char;
                    break;

                  default:
                    output += char;
                    break;
                }
              } else if (state === STATE_HTML) {
                switch (char) {
                  case "<":
                    // ignore '<' if inside a quote
                    if (in_quote_char) {
                      break;
                    }

                    // we're seeing a nested '<'
                    depth++;
                    break;

                  case ">":
                    // ignore '>' if inside a quote
                    if (in_quote_char) {
                      break;
                    }

                    // something like this is happening: '<<>>'
                    if (depth) {
                      depth--;

                      break;
                    }

                    // this is closing the tag in tag_buffer
                    in_quote_char = "";
                    state = STATE_PLAINTEXT;
                    tag_buffer += ">";

                    if (allowable_tags.has(normalize_tag(tag_buffer))) {
                      output += tag_buffer;
                    } else {
                      output += tag_replacement;
                    }

                    tag_buffer = "";
                    break;

                  case '"':
                  case "'":
                    // catch both single and double quotes

                    if (char === in_quote_char) {
                      in_quote_char = "";
                    } else {
                      in_quote_char = in_quote_char || char;
                    }

                    tag_buffer += char;
                    break;

                  case "-":
                    if (tag_buffer === "<!-") {
                      state = STATE_COMMENT;
                    }

                    tag_buffer += char;
                    break;

                  case " ":
                  case "\n":
                    if (tag_buffer === "<") {
                      state = STATE_PLAINTEXT;
                      output += "< ";
                      tag_buffer = "";

                      break;
                    }

                    tag_buffer += char;
                    break;

                  default:
                    tag_buffer += char;
                    break;
                }
              } else if (state === STATE_COMMENT) {
                switch (char) {
                  case ">":
                    if (tag_buffer.slice(-2) == "--") {
                      // close the comment
                      state = STATE_PLAINTEXT;
                    }

                    tag_buffer = "";
                    break;

                  default:
                    tag_buffer += char;
                    break;
                }
              }
            }

            // save the context for future iterations
            context.state = state;
            context.tag_buffer = tag_buffer;
            context.depth = depth;
            context.in_quote_char = in_quote_char;

            return output;
          }

          function parse_allowable_tags(allowable_tags) {
            let tag_set = new Set();

            if (typeof allowable_tags === "string") {
              let match;

              while ((match = ALLOWED_TAGS_REGEX.exec(allowable_tags))) {
                tag_set.add(match[1]);
              }
            } else if (
              !Symbol.nonNative &&
              typeof allowable_tags[Symbol.iterator] === "function"
            ) {
              tag_set = new Set(allowable_tags);
            } else if (typeof allowable_tags.forEach === "function") {
              // IE11 compatible
              allowable_tags.forEach(tag_set.add, tag_set);
            }

            return tag_set;
          }

          function normalize_tag(tag_buffer) {
            let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);

            return match ? match[1].toLowerCase() : null;
          }

          if (typeof define === "function" && define.amd) {
            // AMD
            define(function module_factory() {
              return striptags;
            });
          } else if (typeof module === "object" && module.exports) {
            // Node
            module.exports = striptags;
          } else {
            // Browser
            global.striptags = striptags;
          }
        })(this);
      },
      {},
    ],
    244: [
      function (require, module, exports) {
        (function (setImmediate, clearImmediate) {
          (function () {
            var nextTick = require("process/browser.js").nextTick;
            var apply = Function.prototype.apply;
            var slice = Array.prototype.slice;
            var immediateIds = {};
            var nextImmediateId = 0;

            // DOM APIs, for completeness

            exports.setTimeout = function () {
              return new Timeout(
                apply.call(setTimeout, window, arguments),
                clearTimeout
              );
            };
            exports.setInterval = function () {
              return new Timeout(
                apply.call(setInterval, window, arguments),
                clearInterval
              );
            };
            exports.clearTimeout = exports.clearInterval = function (timeout) {
              timeout.close();
            };

            function Timeout(id, clearFn) {
              this._id = id;
              this._clearFn = clearFn;
            }
            Timeout.prototype.unref = Timeout.prototype.ref = function () {};
            Timeout.prototype.close = function () {
              this._clearFn.call(window, this._id);
            };

            // Does not start the time, just sets up the members needed.
            exports.enroll = function (item, msecs) {
              clearTimeout(item._idleTimeoutId);
              item._idleTimeout = msecs;
            };

            exports.unenroll = function (item) {
              clearTimeout(item._idleTimeoutId);
              item._idleTimeout = -1;
            };

            exports._unrefActive = exports.active = function (item) {
              clearTimeout(item._idleTimeoutId);

              var msecs = item._idleTimeout;
              if (msecs >= 0) {
                item._idleTimeoutId = setTimeout(function onTimeout() {
                  if (item._onTimeout) item._onTimeout();
                }, msecs);
              }
            };

            // That's not how node.js implements it but the exposed api is the same.
            exports.setImmediate =
              typeof setImmediate === "function"
                ? setImmediate
                : function (fn) {
                    var id = nextImmediateId++;
                    var args =
                      arguments.length < 2 ? false : slice.call(arguments, 1);

                    immediateIds[id] = true;

                    nextTick(function onNextTick() {
                      if (immediateIds[id]) {
                        // fn.call() is faster so we optimize for the common use-case
                        // @see http://jsperf.com/call-apply-segu
                        if (args) {
                          fn.apply(null, args);
                        } else {
                          fn.call(null);
                        }
                        // Prevent ids from leaking
                        exports.clearImmediate(id);
                      }
                    });

                    return id;
                  };

            exports.clearImmediate =
              typeof clearImmediate === "function"
                ? clearImmediate
                : function (id) {
                    delete immediateIds[id];
                  };
          }.call(this));
        }.call(
          this,
          require("timers").setImmediate,
          require("timers").clearImmediate
        ));
      },
      { "process/browser.js": 179, timers: 244 },
    ],
    245: [
      function (require, module, exports) {
        /*!
         * to-gfm-code-block <https://github.com/jonschlinkert/to-gfm-code-block>
         *
         * Copyright (c) 2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        module.exports = function pre(str, lang) {
          if (typeof str !== "string") {
            throw new TypeError("markdown-pre expects a string.");
          }

          var code = "";
          code += "```" + (typeof lang === "string" ? lang : "");
          code += "\n";
          code += str;
          code += "\n";
          code += "```";
          return code;
        };
      },
      {},
    ],
    246: [
      function (require, module, exports) {
        /*!
         * to-object-path <https://github.com/jonschlinkert/to-object-path>
         *
         * Copyright (c) 2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        var typeOf = require("kind-of");

        module.exports = function toPath(args) {
          if (typeOf(args) !== "arguments") {
            args = arguments;
          }
          return filter(args).join(".");
        };

        function filter(arr) {
          var len = arr.length;
          var idx = -1;
          var res = [];

          while (++idx < len) {
            var ele = arr[idx];
            if (typeOf(ele) === "arguments" || Array.isArray(ele)) {
              res.push.apply(res, filter(ele));
            } else if (typeof ele === "string") {
              res.push(ele);
            }
          }
          return res;
        }
      },
      { "kind-of": 247 },
    ],
    247: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    248: [
      function (require, module, exports) {
        "use strict";

        var safe = require("safe-regex");
        var define = require("define-property");
        var extend = require("extend-shallow");
        var not = require("regex-not");
        var MAX_LENGTH = 1024 * 64;

        /**
         * Session cache
         */

        var cache = {};

        /**
         * Create a regular expression from the given `pattern` string.
         *
         * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.
         * @param {Object} `options`
         * @return {RegExp}
         * @api public
         */

        module.exports = function (patterns, options) {
          if (!Array.isArray(patterns)) {
            return makeRe(patterns, options);
          }
          return makeRe(patterns.join("|"), options);
        };

        /**
         * Create a regular expression from the given `pattern` string.
         *
         * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.
         * @param {Object} `options`
         * @return {RegExp}
         * @api public
         */

        function makeRe(pattern, options) {
          if (pattern instanceof RegExp) {
            return pattern;
          }

          if (typeof pattern !== "string") {
            throw new TypeError("expected a string");
          }

          if (pattern.length > MAX_LENGTH) {
            throw new Error(
              "expected pattern to be less than " + MAX_LENGTH + " characters"
            );
          }

          var key = pattern;
          // do this before shallow cloning options, it's a lot faster
          if (!options || (options && options.cache !== false)) {
            key = createKey(pattern, options);

            if (cache.hasOwnProperty(key)) {
              return cache[key];
            }
          }

          var opts = extend({}, options);
          if (opts.contains === true) {
            if (opts.negate === true) {
              opts.strictNegate = false;
            } else {
              opts.strict = false;
            }
          }

          if (opts.strict === false) {
            opts.strictOpen = false;
            opts.strictClose = false;
          }

          var open = opts.strictOpen !== false ? "^" : "";
          var close = opts.strictClose !== false ? "$" : "";
          var flags = opts.flags || "";
          var regex;

          if (opts.nocase === true && !/i/.test(flags)) {
            flags += "i";
          }

          try {
            if (opts.negate || typeof opts.strictNegate === "boolean") {
              pattern = not.create(pattern, opts);
            }

            var str = open + "(?:" + pattern + ")" + close;
            regex = new RegExp(str, flags);

            if (opts.safe === true && safe(regex) === false) {
              throw new Error(
                "potentially unsafe regular expression: " + regex.source
              );
            }
          } catch (err) {
            if (opts.strictErrors === true || opts.safe === true) {
              err.key = key;
              err.pattern = pattern;
              err.originalOptions = options;
              err.createdOptions = opts;
              throw err;
            }

            try {
              regex = new RegExp("^" + pattern.replace(/(\W)/g, "\\$1") + "$");
            } catch (err) {
              regex = /.^/; //<= match nothing
            }
          }

          if (opts.cache !== false) {
            memoize(regex, key, pattern, opts);
          }
          return regex;
        }

        /**
         * Memoize generated regex. This can result in dramatic speed improvements
         * and simplify debugging by adding options and pattern to the regex. It can be
         * disabled by passing setting `options.cache` to false.
         */

        function memoize(regex, key, pattern, options) {
          define(regex, "cached", true);
          define(regex, "pattern", pattern);
          define(regex, "options", options);
          define(regex, "key", key);
          cache[key] = regex;
        }

        /**
         * Create the key to use for memoization. The key is generated
         * by iterating over the options and concatenating key-value pairs
         * to the pattern string.
         */

        function createKey(pattern, options) {
          if (!options) return pattern;
          var key = pattern;
          for (var prop in options) {
            if (options.hasOwnProperty(prop)) {
              key += ";" + prop + "=" + String(options[prop]);
            }
          }
          return key;
        }

        /**
         * Expose `makeRe`
         */

        module.exports.makeRe = makeRe;
      },
      {
        "define-property": 249,
        "extend-shallow": 250,
        "regex-not": 184,
        "safe-regex": 197,
      },
    ],
    249: [
      function (require, module, exports) {
        arguments[4][147][0].apply(exports, arguments);
      },
      { dup: 147, "is-descriptor": 117, isobject: 131 },
    ],
    250: [
      function (require, module, exports) {
        arguments[4][148][0].apply(exports, arguments);
      },
      { "assign-symbols": 7, dup: 148, "is-extendable": 251 },
    ],
    251: [
      function (require, module, exports) {
        arguments[4][149][0].apply(exports, arguments);
      },
      { dup: 149, "is-plain-object": 126 },
    ],
    252: [
      function (require, module, exports) {
        "use strict";

        var typeOf = require("kind-of");
        var types = {
          arguments: "an arguments object",
          array: "an array",
          boolean: "a boolean",
          buffer: "a buffer",
          date: "a date",
          error: "an error",
          float32array: "a float32array",
          float64array: "a float64array",
          function: "a function",
          int16array: "an int16array",
          int32array: "an int32array",
          int8array: "an int8array",
          map: "a Map",
          null: "null",
          number: "a number",
          object: "an object",
          regexp: "a regular expression",
          set: "a Set",
          string: "a string",
          symbol: "a symbol",
          uint16array: "an uint16array",
          uint32array: "an uint32array",
          uint8array: "an uint8array",
          uint8clampedarray: "an uint8clampedarray",
          undefined: "undefined",
          weakmap: "a WeakMap",
          weakset: "a WeakSet",
        };

        function type(val) {
          return types[typeOf(val)];
        }

        type.types = types;
        type.typeOf = typeOf;

        /**
         * Expose `type`
         */

        module.exports = type;
      },
      { "kind-of": 253 },
    ],
    253: [
      function (require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
      },
      { dup: 17, "is-buffer": 114 },
    ],
    254: [
      function (require, module, exports) {
        "use strict";

        var isObject = require("is-extendable");
        var union = require("arr-union");
        var get = require("get-value");
        var set = require("set-value");

        module.exports = function unionValue(obj, prop, value) {
          if (!isObject(obj)) {
            throw new TypeError(
              "union-value expects the first argument to be an object."
            );
          }

          if (typeof prop !== "string") {
            throw new TypeError("union-value expects `prop` to be a string.");
          }

          var arr = arrayify(get(obj, prop));
          set(obj, prop, union(arr, arrayify(value)));
          return obj;
        };

        function arrayify(val) {
          if (val === null || typeof val === "undefined") {
            return [];
          }
          if (Array.isArray(val)) {
            return val;
          }
          return [val];
        }
      },
      {
        "arr-union": 3,
        "get-value": 79,
        "is-extendable": 119,
        "set-value": 200,
      },
    ],
    255: [
      function (require, module, exports) {
        /*!
         * unset-value <https://github.com/jonschlinkert/unset-value>
         *
         * Copyright (c) 2015, 2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        var isObject = require("isobject");
        var has = require("has-value");

        module.exports = function unset(obj, prop) {
          if (!isObject(obj)) {
            throw new TypeError("expected an object.");
          }
          if (obj.hasOwnProperty(prop)) {
            delete obj[prop];
            return true;
          }

          if (has(obj, prop)) {
            var segs = prop.split(".");
            var last = segs.pop();
            while (segs.length && segs[segs.length - 1].slice(-1) === "\\") {
              last = segs.pop().slice(0, -1) + "." + last;
            }
            while (segs.length) obj = obj[(prop = segs.shift())];
            return delete obj[last];
          }
          return true;
        };
      },
      { "has-value": 256, isobject: 131 },
    ],
    256: [
      function (require, module, exports) {
        /*!
         * has-value <https://github.com/jonschlinkert/has-value>
         *
         * Copyright (c) 2014-2016, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        var isObject = require("isobject");
        var hasValues = require("has-values");
        var get = require("get-value");

        module.exports = function (obj, prop, noZero) {
          if (isObject(obj)) {
            return hasValues(get(obj, prop), noZero);
          }
          return hasValues(obj, prop);
        };
      },
      { "get-value": 79, "has-values": 258, isobject: 257 },
    ],
    257: [
      function (require, module, exports) {
        arguments[4][188][0].apply(exports, arguments);
      },
      { dup: 188, isarray: 130 },
    ],
    258: [
      function (require, module, exports) {
        /*!
         * has-values <https://github.com/jonschlinkert/has-values>
         *
         * Copyright (c) 2014-2015, Jon Schlinkert.
         * Licensed under the MIT License.
         */

        "use strict";

        module.exports = function hasValue(o, noZero) {
          if (o === null || o === undefined) {
            return false;
          }

          if (typeof o === "boolean") {
            return true;
          }

          if (typeof o === "number") {
            if (o === 0 && noZero === true) {
              return false;
            }
            return true;
          }

          if (o.length !== undefined) {
            return o.length !== 0;
          }

          for (var key in o) {
            if (o.hasOwnProperty(key)) {
              return true;
            }
          }
          return false;
        };
      },
      {},
    ],
    259: [
      function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        "use strict";

        var punycode = require("punycode");
        var util = require("./util");

        exports.parse = urlParse;
        exports.resolve = urlResolve;
        exports.resolveObject = urlResolveObject;
        exports.format = urlFormat;

        exports.Url = Url;

        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }

        // Reference: RFC 3986, RFC 1808, RFC 2396

        // define these here so at least they only have to be
        // compiled once on the first module load.
        var protocolPattern = /^([a-z0-9.+-]+:)/i,
          portPattern = /:[0-9]*$/,
          // Special case for a simple path URL
          simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
          // RFC 2396: characters reserved for delimiting URLs.
          // We actually just auto-escape these.
          delims = ["<", ">", '"', "`", " ", "\r", "\n", "\t"],
          // RFC 2396: characters not allowed for various reasons.
          unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims),
          // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
          autoEscape = ["'"].concat(unwise),
          // Characters that are never ever allowed in a hostname.
          // Note that any invalid chars are also handled, but these
          // are the ones that are *expected* to be seen, so we fast-path
          // them.
          nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape),
          hostEndingChars = ["/", "?", "#"],
          hostnameMaxLen = 255,
          hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
          hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
          // protocols that can allow "unsafe" and "unwise" chars.
          unsafeProtocol = {
            javascript: true,
            "javascript:": true,
          },
          // protocols that never have a hostname.
          hostlessProtocol = {
            javascript: true,
            "javascript:": true,
          },
          // protocols that always contain a // bit.
          slashedProtocol = {
            http: true,
            https: true,
            ftp: true,
            gopher: true,
            file: true,
            "http:": true,
            "https:": true,
            "ftp:": true,
            "gopher:": true,
            "file:": true,
          },
          querystring = require("querystring");

        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && util.isObject(url) && url instanceof Url) return url;

          var u = new Url();
          u.parse(url, parseQueryString, slashesDenoteHost);
          return u;
        }

        Url.prototype.parse = function (
          url,
          parseQueryString,
          slashesDenoteHost
        ) {
          if (!util.isString(url)) {
            throw new TypeError(
              "Parameter 'url' must be a string, not " + typeof url
            );
          }

          // Copy chrome, IE, opera backslash-handling behavior.
          // Back slashes before the query string get converted to forward slashes
          // See: https://code.google.com/p/chromium/issues/detail?id=25916
          var queryIndex = url.indexOf("?"),
            splitter =
              queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#",
            uSplit = url.split(splitter),
            slashRegex = /\\/g;
          uSplit[0] = uSplit[0].replace(slashRegex, "/");
          url = uSplit.join(splitter);

          var rest = url;

          // trim before proceeding.
          // This is to support parse stuff like "  http://foo.com  \n"
          rest = rest.trim();

          if (!slashesDenoteHost && url.split("#").length === 1) {
            // Try fast path regexp
            var simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
              this.path = rest;
              this.href = rest;
              this.pathname = simplePath[1];
              if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                  this.query = querystring.parse(this.search.substr(1));
                } else {
                  this.query = this.search.substr(1);
                }
              } else if (parseQueryString) {
                this.search = "";
                this.query = {};
              }
              return this;
            }
          }

          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }

          // figure out if it's got a host
          // user@server is *always* interpreted as a hostname, and url
          // resolution will treat //foo/bar as host=foo,path=bar because that's
          // how the browser resolves relative URLs.
          if (
            slashesDenoteHost ||
            proto ||
            rest.match(/^\/\/[^@\/]+@[^@\/]+/)
          ) {
            var slashes = rest.substr(0, 2) === "//";
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }

          if (
            !hostlessProtocol[proto] &&
            (slashes || (proto && !slashedProtocol[proto]))
          ) {
            // there's a hostname.
            // the first instance of /, ?, ;, or # ends the host.
            //
            // If there is an @ in the hostname, then non-host chars *are* allowed
            // to the left of the last @ sign, unless some host-ending character
            // comes *before* the @-sign.
            // URLs are obnoxious.
            //
            // ex:
            // http://a@b@c/ => user:a@b host:c
            // http://a@b?@c => user:a host:c path:/?@c

            // v0.12 TODO(isaacs): This is not quite how Chrome does things.
            // Review our test case against browsers more comprehensively.

            // find the first instance of any hostEndingChars
            var hostEnd = -1;
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }

            // at this point, either we have an explicit point where the
            // auth portion cannot go past, or the last @ char is the decider.
            var auth, atSign;
            if (hostEnd === -1) {
              // atSign can be anywhere.
              atSign = rest.lastIndexOf("@");
            } else {
              // atSign must be in auth portion.
              // http://a@b/c@d => host:b auth:a path:/c@d
              atSign = rest.lastIndexOf("@", hostEnd);
            }

            // Now we have a portion which is definitely the auth.
            // Pull that off.
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }

            // the host is the remaining to the left of the first non-host char
            hostEnd = -1;
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            // if we still have not hit it, then the entire thing is a host.
            if (hostEnd === -1) hostEnd = rest.length;

            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);

            // pull out port.
            this.parseHost();

            // we've indicated that there is a hostname,
            // so even if it's empty, it has to be present.
            this.hostname = this.hostname || "";

            // if hostname begins with [ and ends with ]
            // assume that it's an IPv6 address.
            var ipv6Hostname =
              this.hostname[0] === "[" &&
              this.hostname[this.hostname.length - 1] === "]";

            // validate a little.
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(/\./);
              for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part) continue;
                if (!part.match(hostnamePartPattern)) {
                  var newpart = "";
                  for (var j = 0, k = part.length; j < k; j++) {
                    if (part.charCodeAt(j) > 127) {
                      // we replace non-ASCII char with a temporary placeholder
                      // we need this to make sure size of hostname is not
                      // broken by replacing non-ASCII by nothing
                      newpart += "x";
                    } else {
                      newpart += part[j];
                    }
                  }
                  // we test again with ASCII char only
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i);
                    var notHost = hostparts.slice(i + 1);
                    var bit = part.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = "/" + notHost.join(".") + rest;
                    }
                    this.hostname = validParts.join(".");
                    break;
                  }
                }
              }
            }

            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = "";
            } else {
              // hostnames are always lower case.
              this.hostname = this.hostname.toLowerCase();
            }

            if (!ipv6Hostname) {
              // IDNA Support: Returns a punycoded representation of "domain".
              // It only converts parts of the domain name that
              // have non-ASCII characters, i.e. it doesn't matter if
              // you call it with a domain that already is ASCII-only.
              this.hostname = punycode.toASCII(this.hostname);
            }

            var p = this.port ? ":" + this.port : "";
            var h = this.hostname || "";
            this.host = h + p;
            this.href += this.host;

            // strip [ and ] from the hostname
            // the host field still retains them, though
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== "/") {
                rest = "/" + rest;
              }
            }
          }

          // now rest is set to the post-host stuff.
          // chop off any delim chars.
          if (!unsafeProtocol[lowerProto]) {
            // First, make 100% sure that any "autoEscape" chars get
            // escaped, even if encodeURIComponent doesn't think they
            // need to be.
            for (var i = 0, l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i];
              if (rest.indexOf(ae) === -1) continue;
              var esc = encodeURIComponent(ae);
              if (esc === ae) {
                esc = escape(ae);
              }
              rest = rest.split(ae).join(esc);
            }
          }

          // chop off from the tail first.
          var hash = rest.indexOf("#");
          if (hash !== -1) {
            // got a fragment string.
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
          }
          var qm = rest.indexOf("?");
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            // no query string, but parseQueryString still requested
            this.search = "";
            this.query = {};
          }
          if (rest) this.pathname = rest;
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = "/";
          }

          //to support http.request
          if (this.pathname || this.search) {
            var p = this.pathname || "";
            var s = this.search || "";
            this.path = p + s;
          }

          // finally, reconstruct the href based on what has been validated.
          this.href = this.format();
          return this;
        };

        // format a parsed object into a url string
        function urlFormat(obj) {
          // ensure it's an object, and not a string url.
          // If it's an obj, this is a no-op.
          // this way, you can call url_format() on strings
          // to clean up potentially wonky urls.
          if (util.isString(obj)) obj = urlParse(obj);
          if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
          return obj.format();
        }

        Url.prototype.format = function () {
          var auth = this.auth || "";
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ":");
            auth += "@";
          }

          var protocol = this.protocol || "",
            pathname = this.pathname || "",
            hash = this.hash || "",
            host = false,
            query = "";

          if (this.host) {
            host = auth + this.host;
          } else if (this.hostname) {
            host =
              auth +
              (this.hostname.indexOf(":") === -1
                ? this.hostname
                : "[" + this.hostname + "]");
            if (this.port) {
              host += ":" + this.port;
            }
          }

          if (
            this.query &&
            util.isObject(this.query) &&
            Object.keys(this.query).length
          ) {
            query = querystring.stringify(this.query);
          }

          var search = this.search || (query && "?" + query) || "";

          if (protocol && protocol.substr(-1) !== ":") protocol += ":";

          // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
          // unless they had them to begin with.
          if (
            this.slashes ||
            ((!protocol || slashedProtocol[protocol]) && host !== false)
          ) {
            host = "//" + (host || "");
            if (pathname && pathname.charAt(0) !== "/")
              pathname = "/" + pathname;
          } else if (!host) {
            host = "";
          }

          if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
          if (search && search.charAt(0) !== "?") search = "?" + search;

          pathname = pathname.replace(/[?#]/g, function (match) {
            return encodeURIComponent(match);
          });
          search = search.replace("#", "%23");

          return protocol + host + pathname + search + hash;
        };

        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }

        Url.prototype.resolve = function (relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };

        function urlResolveObject(source, relative) {
          if (!source) return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }

        Url.prototype.resolveObject = function (relative) {
          if (util.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }

          var result = new Url();
          var tkeys = Object.keys(this);
          for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
          }

          // hash is always overridden, no matter what.
          // even href="" will remove it.
          result.hash = relative.hash;

          // if the relative url is empty, then there's nothing left to do here.
          if (relative.href === "") {
            result.href = result.format();
            return result;
          }

          // hrefs like //foo/bar always cut to the protocol.
          if (relative.slashes && !relative.protocol) {
            // take everything except the protocol from relative
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
              var rkey = rkeys[rk];
              if (rkey !== "protocol") result[rkey] = relative[rkey];
            }

            //urlParse appends trailing / to urls like http://www.example.com
            if (
              slashedProtocol[result.protocol] &&
              result.hostname &&
              !result.pathname
            ) {
              result.path = result.pathname = "/";
            }

            result.href = result.format();
            return result;
          }

          if (relative.protocol && relative.protocol !== result.protocol) {
            // if it's a known url protocol, then changing
            // the protocol does weird things
            // first, if it's not file:, then we MUST have a host,
            // and if there was a path
            // to begin with, then we MUST have a path.
            // if it is file:, then the host is dropped,
            // because that's known to be hostless.
            // anything else is assumed to be absolute.
            if (!slashedProtocol[relative.protocol]) {
              var keys = Object.keys(relative);
              for (var v = 0; v < keys.length; v++) {
                var k = keys[v];
                result[k] = relative[k];
              }
              result.href = result.format();
              return result;
            }

            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || "").split("/");
              while (relPath.length && !(relative.host = relPath.shift()));
              if (!relative.host) relative.host = "";
              if (!relative.hostname) relative.hostname = "";
              if (relPath[0] !== "") relPath.unshift("");
              if (relPath.length < 2) relPath.unshift("");
              result.pathname = relPath.join("/");
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || "";
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            // to support http.request
            if (result.pathname || result.search) {
              var p = result.pathname || "";
              var s = result.search || "";
              result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }

          var isSourceAbs =
              result.pathname && result.pathname.charAt(0) === "/",
            isRelAbs =
              relative.host ||
              (relative.pathname && relative.pathname.charAt(0) === "/"),
            mustEndAbs =
              isRelAbs || isSourceAbs || (result.host && relative.pathname),
            removeAllDots = mustEndAbs,
            srcPath = (result.pathname && result.pathname.split("/")) || [],
            relPath = (relative.pathname && relative.pathname.split("/")) || [],
            psychotic = result.protocol && !slashedProtocol[result.protocol];

          // if the url is a non-slashed url, then relative
          // links like ../.. should be able
          // to crawl up to the hostname, as well.  This is strange.
          // result.protocol has already been set by now.
          // Later on, put the first path part into the host field.
          if (psychotic) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
              if (srcPath[0] === "") srcPath[0] = result.host;
              else srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === "") relPath[0] = relative.host;
                else relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
          }

          if (isRelAbs) {
            // it's absolute.
            result.host =
              relative.host || relative.host === ""
                ? relative.host
                : result.host;
            result.hostname =
              relative.hostname || relative.hostname === ""
                ? relative.hostname
                : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
            // fall through to the dot-handling below.
          } else if (relPath.length) {
            // it's relative
            // throw away the existing file, and take the new path instead.
            if (!srcPath) srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!util.isNullOrUndefined(relative.search)) {
            // just pull out the search.
            // like href='?foo'.
            // Put this after the other two cases because it simplifies the booleans
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              //occationaly the auth can get stuck only in host
              //this especially happens in cases like
              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
              var authInHost =
                result.host && result.host.indexOf("@") > 0
                  ? result.host.split("@")
                  : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            //to support http.request
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path =
                (result.pathname ? result.pathname : "") +
                (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
          }

          if (!srcPath.length) {
            // no path at all.  easy.
            // we've already handled the other stuff above.
            result.pathname = null;
            //to support http.request
            if (result.search) {
              result.path = "/" + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }

          // if a url ENDs in . or .., then it must get a trailing slash.
          // however, if it ends in anything else non-slashy,
          // then it must NOT get a trailing slash.
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash =
            ((result.host || relative.host || srcPath.length > 1) &&
              (last === "." || last === "..")) ||
            last === "";

          // strip single dots, resolve double dots to parent dir
          // if the path tries to go above the root, `up` ends up > 0
          var up = 0;
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last === ".") {
              srcPath.splice(i, 1);
            } else if (last === "..") {
              srcPath.splice(i, 1);
              up++;
            } else if (up) {
              srcPath.splice(i, 1);
              up--;
            }
          }

          // if the path is allowed to go above the root, restore leading ..s
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift("..");
            }
          }

          if (
            mustEndAbs &&
            srcPath[0] !== "" &&
            (!srcPath[0] || srcPath[0].charAt(0) !== "/")
          ) {
            srcPath.unshift("");
          }

          if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
          }

          var isAbsolute =
            srcPath[0] === "" || (srcPath[0] && srcPath[0].charAt(0) === "/");

          // put the host back
          if (psychotic) {
            result.hostname = result.host = isAbsolute
              ? ""
              : srcPath.length
              ? srcPath.shift()
              : "";
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost =
              result.host && result.host.indexOf("@") > 0
                ? result.host.split("@")
                : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }

          mustEndAbs = mustEndAbs || (result.host && srcPath.length);

          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift("");
          }

          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join("/");
          }

          //to support request.http
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path =
              (result.pathname ? result.pathname : "") +
              (result.search ? result.search : "");
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };

        Url.prototype.parseHost = function () {
          var host = this.host;
          var port = portPattern.exec(host);
          if (port) {
            port = port[0];
            if (port !== ":") {
              this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
          }
          if (host) this.hostname = host;
        };
      },
      { "./util": 260, punycode: 180, querystring: 183 },
    ],
    260: [
      function (require, module, exports) {
        "use strict";

        module.exports = {
          isString: function (arg) {
            return typeof arg === "string";
          },
          isObject: function (arg) {
            return typeof arg === "object" && arg !== null;
          },
          isNull: function (arg) {
            return arg === null;
          },
          isNullOrUndefined: function (arg) {
            return arg == null;
          },
        };
      },
      {},
    ],
    261: [
      function (require, module, exports) {
        /*!
         * use <https://github.com/jonschlinkert/use>
         *
         * Copyright (c) 2015-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        "use strict";

        module.exports = function base(app, options) {
          if (!isObject(app) && typeof app !== "function") {
            throw new TypeError("expected an object or function");
          }

          var opts = isObject(options) ? options : {};
          var prop = typeof opts.prop === "string" ? opts.prop : "fns";
          if (!Array.isArray(app[prop])) {
            define(app, prop, []);
          }

          /**
           * Define a plugin function to be passed to use. The only
           * parameter exposed to the plugin is `app`, the object or function.
           * passed to `use(app)`. `app` is also exposed as `this` in plugins.
           *
           * Additionally, **if a plugin returns a function, the function will
           * be pushed onto the `fns` array**, allowing the plugin to be
           * called at a later point by the `run` method.
           *
           * ```js
           * var use = require('use');
           *
           * // define a plugin
           * function foo(app) {
           *   // do stuff
           * }
           *
           * var app = function(){};
           * use(app);
           *
           * // register plugins
           * app.use(foo);
           * app.use(bar);
           * app.use(baz);
           * ```
           * @name .use
           * @param {Function} `fn` plugin function to call
           * @api public
           */

          define(app, "use", use);

          /**
           * Run all plugins on `fns`. Any plugin that returns a function
           * when called by `use` is pushed onto the `fns` array.
           *
           * ```js
           * var config = {};
           * app.run(config);
           * ```
           * @name .run
           * @param {Object} `value` Object to be modified by plugins.
           * @return {Object} Returns the object passed to `run`
           * @api public
           */

          define(app, "run", function (val) {
            if (!isObject(val)) return;

            if (!val.use || !val.run) {
              define(val, prop, val[prop] || []);
              define(val, "use", use);
            }

            if (!val[prop] || val[prop].indexOf(base) === -1) {
              val.use(base);
            }

            var self = this || app;
            var fns = self[prop];
            var len = fns.length;
            var idx = -1;

            while (++idx < len) {
              val.use(fns[idx]);
            }
            return val;
          });

          /**
           * Call plugin `fn`. If a function is returned push it into the
           * `fns` array to be called by the `run` method.
           */

          function use(type, fn, options) {
            var offset = 1;

            if (typeof type === "string" || Array.isArray(type)) {
              fn = wrap(type, fn);
              offset++;
            } else {
              options = fn;
              fn = type;
            }

            if (typeof fn !== "function") {
              throw new TypeError("expected a function");
            }

            var self = this || app;
            var fns = self[prop];

            var args = [].slice.call(arguments, offset);
            args.unshift(self);

            if (typeof opts.hook === "function") {
              opts.hook.apply(self, args);
            }

            var val = fn.apply(self, args);
            if (typeof val === "function" && fns.indexOf(val) === -1) {
              fns.push(val);
            }
            return self;
          }

          /**
           * Wrap a named plugin function so that it's only called on objects of the
           * given `type`
           *
           * @param {String} `type`
           * @param {Function} `fn` Plugin function
           * @return {Function}
           */

          function wrap(type, fn) {
            return function plugin() {
              return this.type === type ? fn.apply(this, arguments) : plugin;
            };
          }

          return app;
        };

        function isObject(val) {
          return val && typeof val === "object" && !Array.isArray(val);
        }

        function define(obj, key, val) {
          Object.defineProperty(obj, key, {
            configurable: true,
            writable: true,
            value: val,
          });
        }
      },
      {},
    ],
    262: [
      function (require, module, exports) {
        module.exports = function isBuffer(arg) {
          return (
            arg &&
            typeof arg === "object" &&
            typeof arg.copy === "function" &&
            typeof arg.fill === "function" &&
            typeof arg.readUInt8 === "function"
          );
        };
      },
      {},
    ],
    263: [
      function (require, module, exports) {
        // Currently in sync with Node.js lib/internal/util/types.js
        // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

        "use strict";

        var isArgumentsObject = require("is-arguments");
        var isGeneratorFunction = require("is-generator-function");
        var whichTypedArray = require("which-typed-array");
        var isTypedArray = require("is-typed-array");

        function uncurryThis(f) {
          return f.call.bind(f);
        }

        var BigIntSupported = typeof BigInt !== "undefined";
        var SymbolSupported = typeof Symbol !== "undefined";

        var ObjectToString = uncurryThis(Object.prototype.toString);

        var numberValue = uncurryThis(Number.prototype.valueOf);
        var stringValue = uncurryThis(String.prototype.valueOf);
        var booleanValue = uncurryThis(Boolean.prototype.valueOf);

        if (BigIntSupported) {
          var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
        }

        if (SymbolSupported) {
          var symbolValue = uncurryThis(Symbol.prototype.valueOf);
        }

        function checkBoxedPrimitive(value, prototypeValueOf) {
          if (typeof value !== "object") {
            return false;
          }
          try {
            prototypeValueOf(value);
            return true;
          } catch (e) {
            return false;
          }
        }

        exports.isArgumentsObject = isArgumentsObject;
        exports.isGeneratorFunction = isGeneratorFunction;
        exports.isTypedArray = isTypedArray;

        // Taken from here and modified for better browser support
        // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
        function isPromise(input) {
          return (
            (typeof Promise !== "undefined" && input instanceof Promise) ||
            (input !== null &&
              typeof input === "object" &&
              typeof input.then === "function" &&
              typeof input.catch === "function")
          );
        }
        exports.isPromise = isPromise;

        function isArrayBufferView(value) {
          if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
            return ArrayBuffer.isView(value);
          }

          return isTypedArray(value) || isDataView(value);
        }
        exports.isArrayBufferView = isArrayBufferView;

        function isUint8Array(value) {
          return whichTypedArray(value) === "Uint8Array";
        }
        exports.isUint8Array = isUint8Array;

        function isUint8ClampedArray(value) {
          return whichTypedArray(value) === "Uint8ClampedArray";
        }
        exports.isUint8ClampedArray = isUint8ClampedArray;

        function isUint16Array(value) {
          return whichTypedArray(value) === "Uint16Array";
        }
        exports.isUint16Array = isUint16Array;

        function isUint32Array(value) {
          return whichTypedArray(value) === "Uint32Array";
        }
        exports.isUint32Array = isUint32Array;

        function isInt8Array(value) {
          return whichTypedArray(value) === "Int8Array";
        }
        exports.isInt8Array = isInt8Array;

        function isInt16Array(value) {
          return whichTypedArray(value) === "Int16Array";
        }
        exports.isInt16Array = isInt16Array;

        function isInt32Array(value) {
          return whichTypedArray(value) === "Int32Array";
        }
        exports.isInt32Array = isInt32Array;

        function isFloat32Array(value) {
          return whichTypedArray(value) === "Float32Array";
        }
        exports.isFloat32Array = isFloat32Array;

        function isFloat64Array(value) {
          return whichTypedArray(value) === "Float64Array";
        }
        exports.isFloat64Array = isFloat64Array;

        function isBigInt64Array(value) {
          return whichTypedArray(value) === "BigInt64Array";
        }
        exports.isBigInt64Array = isBigInt64Array;

        function isBigUint64Array(value) {
          return whichTypedArray(value) === "BigUint64Array";
        }
        exports.isBigUint64Array = isBigUint64Array;

        function isMapToString(value) {
          return ObjectToString(value) === "[object Map]";
        }
        isMapToString.working =
          typeof Map !== "undefined" && isMapToString(new Map());

        function isMap(value) {
          if (typeof Map === "undefined") {
            return false;
          }

          return isMapToString.working
            ? isMapToString(value)
            : value instanceof Map;
        }
        exports.isMap = isMap;

        function isSetToString(value) {
          return ObjectToString(value) === "[object Set]";
        }
        isSetToString.working =
          typeof Set !== "undefined" && isSetToString(new Set());
        function isSet(value) {
          if (typeof Set === "undefined") {
            return false;
          }

          return isSetToString.working
            ? isSetToString(value)
            : value instanceof Set;
        }
        exports.isSet = isSet;

        function isWeakMapToString(value) {
          return ObjectToString(value) === "[object WeakMap]";
        }
        isWeakMapToString.working =
          typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
        function isWeakMap(value) {
          if (typeof WeakMap === "undefined") {
            return false;
          }

          return isWeakMapToString.working
            ? isWeakMapToString(value)
            : value instanceof WeakMap;
        }
        exports.isWeakMap = isWeakMap;

        function isWeakSetToString(value) {
          return ObjectToString(value) === "[object WeakSet]";
        }
        isWeakSetToString.working =
          typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
        function isWeakSet(value) {
          return isWeakSetToString(value);
        }
        exports.isWeakSet = isWeakSet;

        function isArrayBufferToString(value) {
          return ObjectToString(value) === "[object ArrayBuffer]";
        }
        isArrayBufferToString.working =
          typeof ArrayBuffer !== "undefined" &&
          isArrayBufferToString(new ArrayBuffer());
        function isArrayBuffer(value) {
          if (typeof ArrayBuffer === "undefined") {
            return false;
          }

          return isArrayBufferToString.working
            ? isArrayBufferToString(value)
            : value instanceof ArrayBuffer;
        }
        exports.isArrayBuffer = isArrayBuffer;

        function isDataViewToString(value) {
          return ObjectToString(value) === "[object DataView]";
        }
        isDataViewToString.working =
          typeof ArrayBuffer !== "undefined" &&
          typeof DataView !== "undefined" &&
          isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
        function isDataView(value) {
          if (typeof DataView === "undefined") {
            return false;
          }

          return isDataViewToString.working
            ? isDataViewToString(value)
            : value instanceof DataView;
        }
        exports.isDataView = isDataView;

        // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
        var SharedArrayBufferCopy =
          typeof SharedArrayBuffer !== "undefined"
            ? SharedArrayBuffer
            : undefined;
        function isSharedArrayBufferToString(value) {
          return ObjectToString(value) === "[object SharedArrayBuffer]";
        }
        function isSharedArrayBuffer(value) {
          if (typeof SharedArrayBufferCopy === "undefined") {
            return false;
          }

          if (typeof isSharedArrayBufferToString.working === "undefined") {
            isSharedArrayBufferToString.working = isSharedArrayBufferToString(
              new SharedArrayBufferCopy()
            );
          }

          return isSharedArrayBufferToString.working
            ? isSharedArrayBufferToString(value)
            : value instanceof SharedArrayBufferCopy;
        }
        exports.isSharedArrayBuffer = isSharedArrayBuffer;

        function isAsyncFunction(value) {
          return ObjectToString(value) === "[object AsyncFunction]";
        }
        exports.isAsyncFunction = isAsyncFunction;

        function isMapIterator(value) {
          return ObjectToString(value) === "[object Map Iterator]";
        }
        exports.isMapIterator = isMapIterator;

        function isSetIterator(value) {
          return ObjectToString(value) === "[object Set Iterator]";
        }
        exports.isSetIterator = isSetIterator;

        function isGeneratorObject(value) {
          return ObjectToString(value) === "[object Generator]";
        }
        exports.isGeneratorObject = isGeneratorObject;

        function isWebAssemblyCompiledModule(value) {
          return ObjectToString(value) === "[object WebAssembly.Module]";
        }
        exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

        function isNumberObject(value) {
          return checkBoxedPrimitive(value, numberValue);
        }
        exports.isNumberObject = isNumberObject;

        function isStringObject(value) {
          return checkBoxedPrimitive(value, stringValue);
        }
        exports.isStringObject = isStringObject;

        function isBooleanObject(value) {
          return checkBoxedPrimitive(value, booleanValue);
        }
        exports.isBooleanObject = isBooleanObject;

        function isBigIntObject(value) {
          return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
        }
        exports.isBigIntObject = isBigIntObject;

        function isSymbolObject(value) {
          return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
        }
        exports.isSymbolObject = isSymbolObject;

        function isBoxedPrimitive(value) {
          return (
            isNumberObject(value) ||
            isStringObject(value) ||
            isBooleanObject(value) ||
            isBigIntObject(value) ||
            isSymbolObject(value)
          );
        }
        exports.isBoxedPrimitive = isBoxedPrimitive;

        function isAnyArrayBuffer(value) {
          return (
            typeof Uint8Array !== "undefined" &&
            (isArrayBuffer(value) || isSharedArrayBuffer(value))
          );
        }
        exports.isAnyArrayBuffer = isAnyArrayBuffer;

        ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function (
          method
        ) {
          Object.defineProperty(exports, method, {
            enumerable: false,
            value: function () {
              throw new Error(method + " is not supported in userland");
            },
          });
        });
      },
      {
        "is-arguments": 113,
        "is-generator-function": 121,
        "is-typed-array": 128,
        "which-typed-array": 265,
      },
    ],
    264: [
      function (require, module, exports) {
        (function (process) {
          (function () {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            var getOwnPropertyDescriptors =
              Object.getOwnPropertyDescriptors ||
              function getOwnPropertyDescriptors(obj) {
                var keys = Object.keys(obj);
                var descriptors = {};
                for (var i = 0; i < keys.length; i++) {
                  descriptors[keys[i]] = Object.getOwnPropertyDescriptor(
                    obj,
                    keys[i]
                  );
                }
                return descriptors;
              };

            var formatRegExp = /%[sdj%]/g;
            exports.format = function (f) {
              if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }
                return objects.join(" ");
              }

              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f).replace(formatRegExp, function (x) {
                if (x === "%%") return "%";
                if (i >= len) return x;
                switch (x) {
                  case "%s":
                    return String(args[i++]);
                  case "%d":
                    return Number(args[i++]);
                  case "%j":
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return "[Circular]";
                    }
                  default:
                    return x;
                }
              });
              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                  str += " " + x;
                } else {
                  str += " " + inspect(x);
                }
              }
              return str;
            };

            // Mark that a method should not be used.
            // Returns a modified function which warns once by default.
            // If --no-deprecation is set, then it is a no-op.
            exports.deprecate = function (fn, msg) {
              if (
                typeof process !== "undefined" &&
                process.noDeprecation === true
              ) {
                return fn;
              }

              // Allow for deprecating things in the process of starting up.
              if (typeof process === "undefined") {
                return function () {
                  return exports.deprecate(fn, msg).apply(this, arguments);
                };
              }

              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (process.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    console.error(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }

              return deprecated;
            };

            var debugs = {};
            var debugEnvRegex = /^$/;

            if (process.env.NODE_DEBUG) {
              var debugEnv = process.env.NODE_DEBUG;
              debugEnv = debugEnv
                .replace(/[|\\{}()[\]^$+?.]/g, "\\$&")
                .replace(/\*/g, ".*")
                .replace(/,/g, "$|^")
                .toUpperCase();
              debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
            }
            exports.debuglog = function (set) {
              set = set.toUpperCase();
              if (!debugs[set]) {
                if (debugEnvRegex.test(set)) {
                  var pid = process.pid;
                  debugs[set] = function () {
                    var msg = exports.format.apply(exports, arguments);
                    console.error("%s %d: %s", set, pid, msg);
                  };
                } else {
                  debugs[set] = function () {};
                }
              }
              return debugs[set];
            };

            /**
             * Echos the value of a value. Trys to print the value out
             * in the best way possible given the different types.
             *
             * @param {Object} obj The object to print out.
             * @param {Object} opts Optional options object that alters the output.
             */
            /* legacy: obj, showHidden, depth, colors*/
            function inspect(obj, opts) {
              // default options
              var ctx = {
                seen: [],
                stylize: stylizeNoColor,
              };
              // legacy...
              if (arguments.length >= 3) ctx.depth = arguments[2];
              if (arguments.length >= 4) ctx.colors = arguments[3];
              if (isBoolean(opts)) {
                // legacy...
                ctx.showHidden = opts;
              } else if (opts) {
                // got an "options" object
                exports._extend(ctx, opts);
              }
              // set default options
              if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
              if (isUndefined(ctx.depth)) ctx.depth = 2;
              if (isUndefined(ctx.colors)) ctx.colors = false;
              if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
              if (ctx.colors) ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }
            exports.inspect = inspect;

            // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
            inspect.colors = {
              bold: [1, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              white: [37, 39],
              grey: [90, 39],
              black: [30, 39],
              blue: [34, 39],
              cyan: [36, 39],
              green: [32, 39],
              magenta: [35, 39],
              red: [31, 39],
              yellow: [33, 39],
            };

            // Don't use 'blue' not visible on cmd.exe
            inspect.styles = {
              special: "cyan",
              number: "yellow",
              boolean: "yellow",
              undefined: "grey",
              null: "bold",
              string: "green",
              date: "magenta",
              // "name": intentionally not styling
              regexp: "red",
            };

            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];

              if (style) {
                return (
                  "\u001b[" +
                  inspect.colors[style][0] +
                  "m" +
                  str +
                  "\u001b[" +
                  inspect.colors[style][1] +
                  "m"
                );
              } else {
                return str;
              }
            }

            function stylizeNoColor(str, styleType) {
              return str;
            }

            function arrayToHash(array) {
              var hash = {};

              array.forEach(function (val, idx) {
                hash[val] = true;
              });

              return hash;
            }

            function formatValue(ctx, value, recurseTimes) {
              // Provide a hook for user-specified inspect functions.
              // Check that value is an object with an inspect function on it
              if (
                ctx.customInspect &&
                value &&
                isFunction(value.inspect) &&
                // Filter out the util module, it's inspect function is special
                value.inspect !== exports.inspect &&
                // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)
              ) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }

              // Primitive types cannot have properties
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }

              // Look up the keys of the object.
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);

              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }

              // IE doesn't make error fields non-enumerable
              // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
              if (
                isError(value) &&
                (keys.indexOf("message") >= 0 ||
                  keys.indexOf("description") >= 0)
              ) {
                return formatError(value);
              }

              // Some type of object without properties can be shortcutted.
              if (keys.length === 0) {
                if (isFunction(value)) {
                  var name = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name + "]", "special");
                }
                if (isRegExp(value)) {
                  return ctx.stylize(
                    RegExp.prototype.toString.call(value),
                    "regexp"
                  );
                }
                if (isDate(value)) {
                  return ctx.stylize(
                    Date.prototype.toString.call(value),
                    "date"
                  );
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }

              var base = "",
                array = false,
                braces = ["{", "}"];

              // Make Array say that they are Array
              if (isArray(value)) {
                array = true;
                braces = ["[", "]"];
              }

              // Make functions say that they are functions
              if (isFunction(value)) {
                var n = value.name ? ": " + value.name : "";
                base = " [Function" + n + "]";
              }

              // Make RegExps say that they are RegExps
              if (isRegExp(value)) {
                base = " " + RegExp.prototype.toString.call(value);
              }

              // Make dates with properties first say the date
              if (isDate(value)) {
                base = " " + Date.prototype.toUTCString.call(value);
              }

              // Make error with message first say the error
              if (isError(value)) {
                base = " " + formatError(value);
              }

              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }

              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(
                    RegExp.prototype.toString.call(value),
                    "regexp"
                  );
                } else {
                  return ctx.stylize("[Object]", "special");
                }
              }

              ctx.seen.push(value);

              var output;
              if (array) {
                output = formatArray(
                  ctx,
                  value,
                  recurseTimes,
                  visibleKeys,
                  keys
                );
              } else {
                output = keys.map(function (key) {
                  return formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    key,
                    array
                  );
                });
              }

              ctx.seen.pop();

              return reduceToSingleString(output, base, braces);
            }

            function formatPrimitive(ctx, value) {
              if (isUndefined(value))
                return ctx.stylize("undefined", "undefined");
              if (isString(value)) {
                var simple =
                  "'" +
                  JSON.stringify(value)
                    .replace(/^"|"$/g, "")
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"') +
                  "'";
                return ctx.stylize(simple, "string");
              }
              if (isNumber(value)) return ctx.stylize("" + value, "number");
              if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
              // For some reason typeof null is "object", so special case here.
              if (isNull(value)) return ctx.stylize("null", "null");
            }

            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }

            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                  output.push(
                    formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      String(i),
                      true
                    )
                  );
                } else {
                  output.push("");
                }
              }
              keys.forEach(function (key) {
                if (!key.match(/^\d+$/)) {
                  output.push(
                    formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      key,
                      true
                    )
                  );
                }
              });
              return output;
            }

            function formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              array
            ) {
              var name, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || {
                value: value[key],
              };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize("[Getter/Setter]", "special");
                } else {
                  str = ctx.stylize("[Getter]", "special");
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize("[Setter]", "special");
                }
              }
              if (!hasOwnProperty(visibleKeys, key)) {
                name = "[" + key + "]";
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf("\n") > -1) {
                    if (array) {
                      str = str
                        .split("\n")
                        .map(function (line) {
                          return "  " + line;
                        })
                        .join("\n")
                        .slice(2);
                    } else {
                      str =
                        "\n" +
                        str
                          .split("\n")
                          .map(function (line) {
                            return "   " + line;
                          })
                          .join("\n");
                    }
                  }
                } else {
                  str = ctx.stylize("[Circular]", "special");
                }
              }
              if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }
                name = JSON.stringify("" + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.slice(1, -1);
                  name = ctx.stylize(name, "name");
                } else {
                  name = name
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"')
                    .replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, "string");
                }
              }

              return name + ": " + str;
            }

            function reduceToSingleString(output, base, braces) {
              var numLinesEst = 0;
              var length = output.reduce(function (prev, cur) {
                numLinesEst++;
                if (cur.indexOf("\n") >= 0) numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);

              if (length > 60) {
                return (
                  braces[0] +
                  (base === "" ? "" : base + "\n ") +
                  " " +
                  output.join(",\n  ") +
                  " " +
                  braces[1]
                );
              }

              return (
                braces[0] + base + " " + output.join(", ") + " " + braces[1]
              );
            }

            // NOTE: These type checking functions intentionally don't use `instanceof`
            // because it is fragile and can be easily faked with `Object.create()`.
            exports.types = require("./support/types");

            function isArray(ar) {
              return Array.isArray(ar);
            }
            exports.isArray = isArray;

            function isBoolean(arg) {
              return typeof arg === "boolean";
            }
            exports.isBoolean = isBoolean;

            function isNull(arg) {
              return arg === null;
            }
            exports.isNull = isNull;

            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports.isNullOrUndefined = isNullOrUndefined;

            function isNumber(arg) {
              return typeof arg === "number";
            }
            exports.isNumber = isNumber;

            function isString(arg) {
              return typeof arg === "string";
            }
            exports.isString = isString;

            function isSymbol(arg) {
              return typeof arg === "symbol";
            }
            exports.isSymbol = isSymbol;

            function isUndefined(arg) {
              return arg === void 0;
            }
            exports.isUndefined = isUndefined;

            function isRegExp(re) {
              return isObject(re) && objectToString(re) === "[object RegExp]";
            }
            exports.isRegExp = isRegExp;
            exports.types.isRegExp = isRegExp;

            function isObject(arg) {
              return typeof arg === "object" && arg !== null;
            }
            exports.isObject = isObject;

            function isDate(d) {
              return isObject(d) && objectToString(d) === "[object Date]";
            }
            exports.isDate = isDate;
            exports.types.isDate = isDate;

            function isError(e) {
              return (
                isObject(e) &&
                (objectToString(e) === "[object Error]" || e instanceof Error)
              );
            }
            exports.isError = isError;
            exports.types.isNativeError = isError;

            function isFunction(arg) {
              return typeof arg === "function";
            }
            exports.isFunction = isFunction;

            function isPrimitive(arg) {
              return (
                arg === null ||
                typeof arg === "boolean" ||
                typeof arg === "number" ||
                typeof arg === "string" ||
                typeof arg === "symbol" || // ES6 symbol
                typeof arg === "undefined"
              );
            }
            exports.isPrimitive = isPrimitive;

            exports.isBuffer = require("./support/isBuffer");

            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }

            function pad(n) {
              return n < 10 ? "0" + n.toString(10) : n.toString(10);
            }

            var months = [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec",
            ];

            // 26 Feb 16:19:34
            function timestamp() {
              var d = new Date();
              var time = [
                pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds()),
              ].join(":");
              return [d.getDate(), months[d.getMonth()], time].join(" ");
            }

            // log is just a thin wrapper to console.log that prepends a timestamp
            exports.log = function () {
              console.log(
                "%s - %s",
                timestamp(),
                exports.format.apply(exports, arguments)
              );
            };

            /**
             * Inherit the prototype methods from one constructor into another.
             *
             * The Function.prototype.inherits from lang.js rewritten as a standalone
             * function (not on Function.prototype). NOTE: If this file is to be loaded
             * during bootstrapping this function needs to be rewritten using some native
             * functions as prototype setup using normal JavaScript does not work as
             * expected during bootstrapping (see mirror.js in r114903).
             *
             * @param {function} ctor Constructor function which needs to inherit the
             *     prototype.
             * @param {function} superCtor Constructor function to inherit prototype from.
             */
            exports.inherits = require("inherits");

            exports._extend = function (origin, add) {
              // Don't do anything if add isn't an object
              if (!add || !isObject(add)) return origin;

              var keys = Object.keys(add);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }
              return origin;
            };

            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }

            var kCustomPromisifiedSymbol =
              typeof Symbol !== "undefined"
                ? Symbol("util.promisify.custom")
                : undefined;

            exports.promisify = function promisify(original) {
              if (typeof original !== "function")
                throw new TypeError(
                  'The "original" argument must be of type Function'
                );

              if (
                kCustomPromisifiedSymbol &&
                original[kCustomPromisifiedSymbol]
              ) {
                var fn = original[kCustomPromisifiedSymbol];
                if (typeof fn !== "function") {
                  throw new TypeError(
                    'The "util.promisify.custom" argument must be of type Function'
                  );
                }
                Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                  value: fn,
                  enumerable: false,
                  writable: false,
                  configurable: true,
                });
                return fn;
              }

              function fn() {
                var promiseResolve, promiseReject;
                var promise = new Promise(function (resolve, reject) {
                  promiseResolve = resolve;
                  promiseReject = reject;
                });

                var args = [];
                for (var i = 0; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }
                args.push(function (err, value) {
                  if (err) {
                    promiseReject(err);
                  } else {
                    promiseResolve(value);
                  }
                });

                try {
                  original.apply(this, args);
                } catch (err) {
                  promiseReject(err);
                }

                return promise;
              }

              Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

              if (kCustomPromisifiedSymbol)
                Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                  value: fn,
                  enumerable: false,
                  writable: false,
                  configurable: true,
                });
              return Object.defineProperties(
                fn,
                getOwnPropertyDescriptors(original)
              );
            };

            exports.promisify.custom = kCustomPromisifiedSymbol;

            function callbackifyOnRejected(reason, cb) {
              // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
              // Because `null` is a special error value in callbacks which means "no error
              // occurred", we error-wrap so the callback consumer can distinguish between
              // "the promise rejected with null" or "the promise fulfilled with undefined".
              if (!reason) {
                var newReason = new Error(
                  "Promise was rejected with a falsy value"
                );
                newReason.reason = reason;
                reason = newReason;
              }
              return cb(reason);
            }

            function callbackify(original) {
              if (typeof original !== "function") {
                throw new TypeError(
                  'The "original" argument must be of type Function'
                );
              }

              // We DO NOT return the promise as it gives the user a false sense that
              // the promise is actually somehow related to the callback's execution
              // and that the callback throwing will reject the promise.
              function callbackified() {
                var args = [];
                for (var i = 0; i < arguments.length; i++) {
                  args.push(arguments[i]);
                }

                var maybeCb = args.pop();
                if (typeof maybeCb !== "function") {
                  throw new TypeError(
                    "The last argument must be of type Function"
                  );
                }
                var self = this;
                var cb = function () {
                  return maybeCb.apply(self, arguments);
                };
                // In true node style we process the callback on `nextTick` with all the
                // implications (stack, `uncaughtException`, `async_hooks`)
                original.apply(this, args).then(
                  function (ret) {
                    process.nextTick(cb.bind(null, null, ret));
                  },
                  function (rej) {
                    process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                  }
                );
              }

              Object.setPrototypeOf(
                callbackified,
                Object.getPrototypeOf(original)
              );
              Object.defineProperties(
                callbackified,
                getOwnPropertyDescriptors(original)
              );
              return callbackified;
            }
            exports.callbackify = callbackify;
          }.call(this));
        }.call(this, require("_process")));
      },
      {
        "./support/isBuffer": 262,
        "./support/types": 263,
        _process: 179,
        inherits: 111,
      },
    ],
    265: [
      function (require, module, exports) {
        (function (global) {
          (function () {
            "use strict";

            var forEach = require("for-each");
            var availableTypedArrays = require("available-typed-arrays");
            var callBound = require("call-bind/callBound");
            var gOPD = require("gopd");

            var $toString = callBound("Object.prototype.toString");
            var hasToStringTag = require("has-tostringtag/shams")();

            var g = typeof globalThis === "undefined" ? global : globalThis;
            var typedArrays = availableTypedArrays();

            var $slice = callBound("String.prototype.slice");
            var toStrTags = {};
            var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
            if (hasToStringTag && gOPD && getPrototypeOf) {
              forEach(typedArrays, function (typedArray) {
                if (typeof g[typedArray] === "function") {
                  var arr = new g[typedArray]();
                  if (Symbol.toStringTag in arr) {
                    var proto = getPrototypeOf(arr);
                    var descriptor = gOPD(proto, Symbol.toStringTag);
                    if (!descriptor) {
                      var superProto = getPrototypeOf(proto);
                      descriptor = gOPD(superProto, Symbol.toStringTag);
                    }
                    toStrTags[typedArray] = descriptor.get;
                  }
                }
              });
            }

            var tryTypedArrays = function tryAllTypedArrays(value) {
              var foundName = false;
              forEach(toStrTags, function (getter, typedArray) {
                if (!foundName) {
                  try {
                    var name = getter.call(value);
                    if (name === typedArray) {
                      foundName = name;
                    }
                  } catch (e) {}
                }
              });
              return foundName;
            };

            var isTypedArray = require("is-typed-array");

            module.exports = function whichTypedArray(value) {
              if (!isTypedArray(value)) {
                return false;
              }
              if (!hasToStringTag || !(Symbol.toStringTag in value)) {
                return $slice($toString(value), 8, -1);
              }
              return tryTypedArrays(value);
            };
          }.call(this));
        }.call(
          this,
          typeof global !== "undefined"
            ? global
            : typeof self !== "undefined"
            ? self
            : typeof window !== "undefined"
            ? window
            : {}
        ));
      },
      {
        "available-typed-arrays": 8,
        "call-bind/callBound": 12,
        "for-each": 69,
        gopd: 80,
        "has-tostringtag/shams": 102,
        "is-typed-array": 128,
      },
    ],
    266: [
      function (require, module, exports) {
        /**
         * year <https://github.com/jonschlinkert/year>
         *
         * Copyright (c) 2014 Jon Schlinkert, contributors.
         * Licensed under the MIT license.
         */

        "use strict";

        module.exports = function (pattern) {
          var year = new Date().getUTCFullYear().toString();
          if (typeof pattern !== "string") {
            return year;
          }

          if (/[Yy]{4}/.test(pattern)) {
            return year;
          }

          if (/[Yy]{2}/.test(pattern)) {
            return year.substr(2, 2);
          }
        };
      },
      {},
    ],
    267: [
      function (require, module, exports) {
        const array = require(`handlebars-helpers/lib/array`);
        const collection = require(`handlebars-helpers/lib/collection`);
        const comparison = require(`handlebars-helpers/lib/comparison`);
        const date = require(`handlebars-helpers/lib/date`);
        const html = require(`handlebars-helpers/lib/html`);
        const i18n = require(`handlebars-helpers/lib/i18n`);
        const inflection = require(`handlebars-helpers/lib/inflection`);
        const math = require(`handlebars-helpers/lib/math`);
        const number = require(`handlebars-helpers/lib/number`);
        const object = require(`handlebars-helpers/lib/object`);
        const regex = require(`handlebars-helpers/lib/regex`);
        const string = require(`handlebars-helpers/lib/string`);
        const url = require(`handlebars-helpers/lib/url`);

        const helpers = [
          array,
          collection,
          comparison,
          date,
          html,
          i18n,
          inflection,
          math,
          number,
          object,
          regex,
          string,
          url,
        ];

        const layouts = require("handlebars-layouts");

        helpers.forEach((helper) => {
          Object.keys(helper).forEach((name) => {
            Handlebars.registerHelper(name, helper[name]);
          });
        });

        Handlebars.registerHelper(layouts);
      },
      {
        "handlebars-helpers/lib/array": 81,
        "handlebars-helpers/lib/collection": 82,
        "handlebars-helpers/lib/comparison": 83,
        "handlebars-helpers/lib/date": 84,
        "handlebars-helpers/lib/html": 85,
        "handlebars-helpers/lib/i18n": 86,
        "handlebars-helpers/lib/inflection": 87,
        "handlebars-helpers/lib/math": 88,
        "handlebars-helpers/lib/number": 89,
        "handlebars-helpers/lib/object": 90,
        "handlebars-helpers/lib/regex": 91,
        "handlebars-helpers/lib/string": 92,
        "handlebars-helpers/lib/url": 93,
        "handlebars-layouts": 98,
      },
    ],
  },
  {},
  [267]
);
